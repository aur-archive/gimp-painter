diff -Naur gimp-2.8.14/app/actions/actions.c gimp-2.8.14-new/app/actions/actions.c
--- gimp-2.8.14/app/actions/actions.c	2015-01-27 17:28:36.907833808 +0800
+++ gimp-2.8.14-new/app/actions/actions.c	2015-01-27 17:48:39.670752639 +0800
@@ -93,6 +93,8 @@
 #include "vectors-actions.h"
 #include "view-actions.h"
 #include "windows-actions.h"
+#include "mypaint-brush-editor-actions.h"
+#include "mypaint-brushes-actions.h"
 
 #include "gimp-intl.h"
 
@@ -234,7 +236,13 @@
     view_actions_update },
   { "windows", N_("Windows"), NULL,
     windows_actions_setup,
-    windows_actions_update }
+    windows_actions_update },
+  { "mypaint-brush-editor", N_("Mypaint Brush Editor"), GIMP_STOCK_BRUSH,
+    mypaint_brush_editor_actions_setup,
+    mypaint_brush_editor_actions_update },
+  { "mypaint-brushes", N_("Mypaint Brushes"), GIMP_STOCK_BRUSH,
+    mypaint_brushes_actions_setup,
+    mypaint_brushes_actions_update },
 };
 
 
diff -Naur gimp-2.8.14/app/actions/context-commands.c gimp-2.8.14-new/app/actions/context-commands.c
--- gimp-2.8.14/app/actions/context-commands.c	2015-01-27 17:28:36.906833808 +0800
+++ gimp-2.8.14-new/app/actions/context-commands.c	2015-01-27 17:48:39.670752639 +0800
@@ -71,7 +71,11 @@
   GIMP_HUE_MODE,
   GIMP_SATURATION_MODE,
   GIMP_COLOR_MODE,
-  GIMP_VALUE_MODE
+  GIMP_VALUE_MODE,
+  GIMP_SRC_IN_MODE,
+  GIMP_DST_IN_MODE,
+  GIMP_SRC_OUT_MODE,
+  GIMP_DST_OUT_MODE,
 };
 
 
diff -Naur gimp-2.8.14/app/actions/dialogs-actions.c gimp-2.8.14-new/app/actions/dialogs-actions.c
--- gimp-2.8.14/app/actions/dialogs-actions.c	2015-01-27 17:28:36.908833808 +0800
+++ gimp-2.8.14-new/app/actions/dialogs-actions.c	2015-01-27 17:48:39.671752639 +0800
@@ -180,6 +180,18 @@
         "gimp-font-list|gimp-font-grid",
         GIMP_HELP_FONT_DIALOG },
 
+    { "dialogs-mypaint-brushes", GIMP_STOCK_MYPAINT_BRUSH,
+        NC_("dialogs-action", "My_paint Brushes"), NULL,
+        NC_("dialogs-action", "Open the mypaint brushes dialog"),
+        "gimp-mypaint_brush-grid|gimp-mypaint_brush-list",
+        GIMP_HELP_MYPAINT_BRUSH_DIALOG },
+
+    { "dialogs-mypaint-brush-editor", GIMP_STOCK_MYPAINT_BRUSH,
+        NC_("dialogs-action", "Mypaint Brush Editor"), NULL,
+        NC_("dialogs-action", "Open the mypaint brush editor"),
+        "gimp-mypaint-brush-editor",
+        GIMP_HELP_MYPAINT_BRUSH_EDIT },
+
     { "dialogs-buffers", GIMP_STOCK_BUFFER, NC_("dialogs-action", "B_uffers"),
         "", NC_("dialogs-action", "Open the named buffers dialog"),
         "gimp-buffer-list|gimp-buffer-grid",
diff -Naur gimp-2.8.14/app/actions/layers-commands.c gimp-2.8.14-new/app/actions/layers-commands.c
--- gimp-2.8.14/app/actions/layers-commands.c	2015-01-27 17:28:36.912833807 +0800
+++ gimp-2.8.14-new/app/actions/layers-commands.c	2015-01-27 17:48:39.672752639 +0800
@@ -96,7 +96,11 @@
   GIMP_HUE_MODE,
   GIMP_SATURATION_MODE,
   GIMP_COLOR_MODE,
-  GIMP_VALUE_MODE
+  GIMP_VALUE_MODE,
+  GIMP_SRC_IN_MODE,
+  GIMP_DST_IN_MODE,
+  GIMP_SRC_OUT_MODE,
+  GIMP_DST_OUT_MODE,
 };
 
 
diff -Naur gimp-2.8.14/app/actions/Makefile.am gimp-2.8.14-new/app/actions/Makefile.am
--- gimp-2.8.14/app/actions/Makefile.am	2015-01-27 17:28:36.910833808 +0800
+++ gimp-2.8.14-new/app/actions/Makefile.am	2015-01-27 17:48:39.669752639 +0800
@@ -23,6 +23,8 @@
 	brush-editor-actions.h		\
 	brushes-actions.c		\
 	brushes-actions.h		\
+	mypaint-brushes-actions.c		\
+	mypaint-brushes-actions.h		\
 	buffers-actions.c		\
 	buffers-actions.h		\
 	buffers-commands.c		\
@@ -184,4 +186,6 @@
 	windows-actions.c		\
 	windows-actions.h		\
 	windows-commands.c		\
-	windows-commands.h
+	windows-commands.h		\
+	mypaint-brush-editor-actions.c		\
+	mypaint-brush-editor-actions.h
diff -Naur gimp-2.8.14/app/actions/mypaint-brush-editor-actions.c gimp-2.8.14-new/app/actions/mypaint-brush-editor-actions.c
--- gimp-2.8.14/app/actions/mypaint-brush-editor-actions.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/actions/mypaint-brush-editor-actions.c	2015-01-27 17:48:39.672752639 +0800
@@ -0,0 +1,86 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "actions-types.h"
+
+#include "core/gimp.h"
+#include "core/gimpcontext.h"
+
+#include "widgets/gimpactiongroup.h"
+#include "widgets/gimphelp-ids.h"
+#include "widgets/gimpmypaintbrusheditor.h"
+
+#include "mypaint-brush-editor-actions.h"
+#include "data-editor-commands.h"
+
+#include "gimp-intl.h"
+
+
+static const GimpActionEntry mypaint_brush_editor_actions[] =
+{
+  { "mypaint-brush-editor-popup", GIMP_STOCK_MYPAINT_BRUSH,
+    NC_("mypaint-brush-editor-action", "Mypaint Brush Editor Menu"), NULL, NULL, NULL,
+    GIMP_HELP_MYPAINT_BRUSH_EDITOR_DIALOG }
+};
+
+static const GimpToggleActionEntry mypaint_brush_editor_toggle_actions[] =
+{
+  { "mypaint-brush-editor-edit-active", GIMP_STOCK_LINKED,
+    NC_("mypaint-brush-editor-action", "Edit Active Mypaint Brush"), NULL, NULL,
+    G_CALLBACK (data_editor_edit_active_cmd_callback),
+    FALSE,
+    GIMP_HELP_MYPAINT_BRUSH_EDITOR_EDIT_ACTIVE }
+};
+
+
+void
+mypaint_brush_editor_actions_setup (GimpActionGroup *group)
+{
+  gimp_action_group_add_actions (group, "mypaint-brush-editor-action",
+                                 mypaint_brush_editor_actions,
+                                 G_N_ELEMENTS (mypaint_brush_editor_actions));
+
+  gimp_action_group_add_toggle_actions (group, "mypaint-brush-editor-action",
+                                        mypaint_brush_editor_toggle_actions,
+                                        G_N_ELEMENTS (mypaint_brush_editor_toggle_actions));
+}
+
+void
+mypaint_brush_editor_actions_update (GimpActionGroup *group,
+                             gpointer         user_data)
+{
+  GimpDataEditor  *data_editor = GIMP_DATA_EDITOR (user_data);
+  gboolean         edit_active = FALSE;
+
+  edit_active = gimp_data_editor_get_edit_active (data_editor);
+
+#define SET_SENSITIVE(action,condition) \
+        gimp_action_group_set_action_sensitive (group, action, (condition) != 0)
+#define SET_ACTIVE(action,condition) \
+        gimp_action_group_set_action_active (group, action, (condition) != 0)
+
+  SET_ACTIVE ("mypaint-brush-editor-edit-active", edit_active);
+
+#undef SET_SENSITIVE
+#undef SET_ACTIVE
+}
diff -Naur gimp-2.8.14/app/actions/mypaint-brush-editor-actions.h gimp-2.8.14-new/app/actions/mypaint-brush-editor-actions.h
--- gimp-2.8.14/app/actions/mypaint-brush-editor-actions.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/actions/mypaint-brush-editor-actions.h	2015-01-27 17:48:39.673752639 +0800
@@ -0,0 +1,27 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __MYPAINT_BRUSH_EDITOR_ACTIONS_H__
+#define __MYPAINT_BRUSH_EDITOR_ACTIONS_H__
+
+
+void   mypaint_brush_editor_actions_setup  (GimpActionGroup *group);
+void   mypaint_brush_editor_actions_update (GimpActionGroup *group,
+                                    gpointer         data);
+
+
+#endif /* __MYPAINT_BRUSH_EDITOR_ACTIONS_H__ */
diff -Naur gimp-2.8.14/app/actions/mypaint-brushes-actions.c gimp-2.8.14-new/app/actions/mypaint-brushes-actions.c
--- gimp-2.8.14/app/actions/mypaint-brushes-actions.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/actions/mypaint-brushes-actions.c	2015-01-27 17:48:39.674752639 +0800
@@ -0,0 +1,139 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "actions-types.h"
+
+#include "core/gimpmypaintbrush.h"
+#include "core/gimpcontext.h"
+
+#include "widgets/gimpactiongroup.h"
+#include "widgets/gimphelp-ids.h"
+
+#include "actions.h"
+#include "mypaint-brushes-actions.h"
+#include "data-commands.h"
+
+#include "gimp-intl.h"
+
+
+static const GimpActionEntry mypaint_brushes_actions[] =
+{
+  { "mypaint-brushes-popup", GIMP_STOCK_BRUSH,
+    NC_("mypaint-brushes-action", "Mypaint Brushes Menu"), NULL, NULL, NULL,
+    GIMP_HELP_MYPAINT_BRUSH_DIALOG },
+#if 0
+  { "brushes-open-as-image", GTK_STOCK_OPEN,
+    NC_("brushes-action", "_Open Brush as Image"), "",
+    NC_("brushes-action", "Open brush as image"),
+    G_CALLBACK (data_open_as_image_cmd_callback),
+    GIMP_HELP_MYPAINT_BRUSH_OPEN_AS_IMAGE },
+
+  { "brushes-new", GTK_STOCK_NEW,
+    NC_("brushes-action", "_New Brush"), "",
+    NC_("brushes-action", "Create a new brush"),
+    G_CALLBACK (data_new_cmd_callback),
+    GIMP_HELP_MYPAINT_BRUSH_NEW },
+#endif
+
+  { "brushes-duplicate", GIMP_STOCK_DUPLICATE,
+    NC_("brushes-action", "D_uplicate Brush"), NULL,
+    NC_("brushes-action", "Duplicate this brush"),
+    G_CALLBACK (data_duplicate_cmd_callback),
+    GIMP_HELP_MYPAINT_BRUSH_DUPLICATE },
+
+  { "mypaint-brushes-copy-location", GTK_STOCK_COPY,
+    NC_("mypaint-brushes-action", "Copy Mypaint Brush _Location"), "",
+    NC_("mypaint-brushes-action", "Copy mypaint brush file location to clipboard"),
+    G_CALLBACK (data_copy_location_cmd_callback),
+    GIMP_HELP_MYPAINT_BRUSH_COPY_LOCATION },
+
+  { "mypaint-brushes-delete", GTK_STOCK_DELETE,
+    NC_("mypaint-brushes-action", "_Delete Mypaint Brush"), "",
+    NC_("mypaint-brushes-action", "Delete this mypaint brush"),
+    G_CALLBACK (data_delete_cmd_callback),
+    GIMP_HELP_MYPAINT_BRUSH_DELETE },
+
+  { "mypaint-brushes-refresh", GTK_STOCK_REFRESH,
+    NC_("mypaint-brushes-action", "_Refresh Mypaint Brushes"), "",
+    NC_("mypaint-brushes-action", "Refresh Mypaint brushes"),
+    G_CALLBACK (data_refresh_cmd_callback),
+    GIMP_HELP_MYPAINT_BRUSH_REFRESH }
+};
+
+static const GimpStringActionEntry mypaint_brushes_edit_actions[] =
+{
+  { "mypaint-brushes-edit", GTK_STOCK_EDIT,
+    NC_("mypaint-brushes-action", "Edit _Mypaint Brush..."), NULL,
+    NC_("mypaint-brushes-action", "Mypaint Edit this brush"),
+    "gimp-mypaint-brush-editor",
+    GIMP_HELP_MYPAINT_BRUSH_EDIT }
+};
+
+
+void
+mypaint_brushes_actions_setup (GimpActionGroup *group)
+{
+  gimp_action_group_add_actions (group, "mypaint-brushes-action",
+                                 mypaint_brushes_actions,
+                                 G_N_ELEMENTS (mypaint_brushes_actions));
+  gimp_action_group_add_string_actions (group, "mypaint-brushes-action",
+                                        mypaint_brushes_edit_actions,
+                                        G_N_ELEMENTS (mypaint_brushes_edit_actions),
+                                        G_CALLBACK (data_edit_cmd_callback));
+}
+
+void
+mypaint_brushes_actions_update (GimpActionGroup *group,
+                        gpointer         user_data)
+{
+  GimpContext *context  = action_data_get_context (user_data);
+  GimpMypaintBrush   *mypaint_brush    = NULL;
+  GimpData    *data     = NULL;
+  const gchar *filename = NULL;
+
+  if (context)
+    {
+      mypaint_brush = gimp_context_get_mypaint_brush (context);
+
+      if (action_data_sel_count (user_data) > 1)
+        {
+          mypaint_brush = NULL;
+        }
+
+      if (mypaint_brush)
+        {
+          data = GIMP_DATA (mypaint_brush);
+
+          filename = gimp_data_get_filename (data);
+        }
+    }
+
+#define SET_SENSITIVE(action,condition) \
+        gimp_action_group_set_action_sensitive (group, action, (condition) != 0)
+  SET_SENSITIVE ("mypaint-brushes-edit",          mypaint_brush);
+  SET_SENSITIVE ("mypaint-brushes-duplicate",     mypaint_brush && GIMP_DATA_GET_CLASS (data)->duplicate);
+  SET_SENSITIVE ("mypaint-brushes-copy-location", mypaint_brush && filename);
+  SET_SENSITIVE ("mypaint-brushes-delete",        mypaint_brush && gimp_data_is_deletable (data));
+
+#undef SET_SENSITIVE
+}
diff -Naur gimp-2.8.14/app/actions/mypaint-brushes-actions.h gimp-2.8.14-new/app/actions/mypaint-brushes-actions.h
--- gimp-2.8.14/app/actions/mypaint-brushes-actions.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/actions/mypaint-brushes-actions.h	2015-01-27 17:48:39.674752639 +0800
@@ -0,0 +1,27 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __MYPAINT_BRUSHES_ACTIONS_H__
+#define __MYPAINT_BRUSHES_ACTIONS_H__
+
+
+void   mypaint_brushes_actions_setup  (GimpActionGroup *group);
+void   mypaint_brushes_actions_update (GimpActionGroup *group,
+                               gpointer         data);
+
+
+#endif /* __MYPAINT_BRUSHES_ACTIONS_H__ */
diff -Naur gimp-2.8.14/app/base/base-enums.c gimp-2.8.14-new/app/base/base-enums.c
--- gimp-2.8.14/app/base/base-enums.c	2015-01-27 17:28:36.871833810 +0800
+++ gimp-2.8.14-new/app/base/base-enums.c	2015-01-27 17:48:39.675752639 +0800
@@ -105,6 +105,10 @@
     { GIMP_ERASE_MODE, "GIMP_ERASE_MODE", "erase-mode" },
     { GIMP_REPLACE_MODE, "GIMP_REPLACE_MODE", "replace-mode" },
     { GIMP_ANTI_ERASE_MODE, "GIMP_ANTI_ERASE_MODE", "anti-erase-mode" },
+    { GIMP_SRC_IN_MODE, "GIMP_SRC_IN_MODE", "src-in-mode" },
+    { GIMP_DST_IN_MODE, "GIMP_DST_IN_MODE", "dst-in-mode" },
+    { GIMP_SRC_OUT_MODE, "GIMP_SRC_OUT_MODE", "src-out-mode" },
+    { GIMP_DST_OUT_MODE, "GIMP_DST_OUT_MODE", "dst-out-mode" },
     { 0, NULL, NULL }
   };
 
@@ -136,6 +140,10 @@
     { GIMP_ERASE_MODE, NC_("layer-mode-effects", "Erase"), NULL },
     { GIMP_REPLACE_MODE, NC_("layer-mode-effects", "Replace"), NULL },
     { GIMP_ANTI_ERASE_MODE, NC_("layer-mode-effects", "Anti erase"), NULL },
+    { GIMP_SRC_IN_MODE, NC_("layer-mode-effects", "svg:src-in"), NULL },
+    { GIMP_DST_IN_MODE, NC_("layer-mode-effects", "svg:dst-in"), NULL },
+    { GIMP_SRC_OUT_MODE, NC_("layer-mode-effects", "svg:src-out"), NULL },
+    { GIMP_DST_OUT_MODE, NC_("layer-mode-effects", "svg:dst-out"), NULL },
     { 0, NULL, NULL }
   };
 
diff -Naur gimp-2.8.14/app/base/base-enums.h gimp-2.8.14-new/app/base/base-enums.h
--- gimp-2.8.14/app/base/base-enums.h	2015-01-27 17:28:36.879833810 +0800
+++ gimp-2.8.14-new/app/base/base-enums.h	2015-01-27 17:48:39.675752639 +0800
@@ -91,7 +91,11 @@
   GIMP_COLOR_ERASE_MODE,     /*< desc="Color erase"          >*/
   GIMP_ERASE_MODE,           /*< pdb-skip, desc="Erase"      >*/
   GIMP_REPLACE_MODE,         /*< pdb-skip, desc="Replace"    >*/
-  GIMP_ANTI_ERASE_MODE       /*< pdb-skip, desc="Anti erase" >*/
+  GIMP_ANTI_ERASE_MODE,      /*< pdb-skip, desc="Anti erase" >*/
+  GIMP_SRC_IN_MODE,          /*< desc="svg:src-in"           >*/
+  GIMP_DST_IN_MODE,          /*< desc="svg:dst-in"           >*/
+  GIMP_SRC_OUT_MODE,         /*< desc="svg:src-out"          >*/
+  GIMP_DST_OUT_MODE,         /*< desc="svg:dst-out"          >*/
 } GimpLayerModeEffects;
 
 
diff -Naur gimp-2.8.14/app/base/delegators.hpp gimp-2.8.14-new/app/base/delegators.hpp
--- gimp-2.8.14/app/base/delegators.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/base/delegators.hpp	2015-01-27 17:48:39.676752639 +0800
@@ -0,0 +1,398 @@
+#ifndef __DELEGATORS_HPP__
+#define __DELEGATORS_HPP__
+
+
+#include <glib-object.h>
+
+namespace Delegator {
+
+template<typename T>
+void destroy_cxx_object_callback(gpointer ptr) {
+  delete reinterpret_cast<T*>(ptr);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+template<typename Function>
+class Delegator {};
+
+///////////////////////////////////////////////////////////////////////////////
+class Delegator_arg0 {
+public:
+  virtual ~Delegator_arg0() {}
+  virtual void emit(GObject* t) = 0;
+  
+  static void callback(GObject* t, gpointer ptr) {
+    Delegator_arg0* delegator = reinterpret_cast<Delegator_arg0*>(ptr);
+    delegator->emit(t);
+  }
+};
+
+
+template<typename Arg1>
+class Delegator_arg1 {
+public:
+  virtual ~Delegator_arg1() {}
+  virtual void emit(GObject* t, Arg1 a1) = 0;
+  
+  static void callback(GObject* t, Arg1 a1, gpointer ptr) {
+    Delegator_arg1* delegator = reinterpret_cast<Delegator_arg1*>(ptr);
+    delegator->emit(t, a1);
+  }
+};
+
+
+template<typename Arg1, typename Arg2>
+class Delegator_arg2 {
+public:
+  virtual ~Delegator_arg2() {}
+  virtual void emit(GObject* t, Arg1 a1, Arg2 a2) = 0;
+  
+  static void callback(GObject* t, Arg1 a1, Arg2 a2, gpointer ptr) {
+    Delegator_arg2* delegator = reinterpret_cast<Delegator_arg2*>(ptr);
+    delegator->emit(t, a1, a2);
+  }
+};
+
+
+template<typename Arg1, typename Arg2, typename Arg3>
+class Delegator_arg3 {
+public:
+  virtual ~Delegator_arg3() {}
+  virtual void emit(GObject* t, Arg1 a1, Arg2 a2, Arg3 a3) = 0;
+  
+  static void callback(GObject* t, Arg1 a1, Arg2 a2, Arg3 a3, gpointer ptr) {
+    Delegator_arg3* delegator = reinterpret_cast<Delegator_arg3*>(ptr);
+    delegator->emit(t, a1, a2, a3);
+  }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+template<>
+class Delegator<void (*)(GObject*)> : public Delegator_arg0 {
+};
+
+template<typename Arg1>
+class Delegator<void (*)(GObject*,Arg1)> : public Delegator_arg1<Arg1> {
+};
+
+template<typename Arg1, typename Arg2>
+class Delegator<void (*)(GObject*,Arg1, Arg2)> : public Delegator_arg2<Arg1, Arg2> {
+};
+
+template<typename Arg1, typename Arg2, typename Arg3>
+class Delegator<void (*)(GObject*,Arg1, Arg2, Arg3)> : 
+  public Delegator_arg3<Arg1, Arg2, Arg3> {
+};
+
+///////////////////////////////////////////////////////////////////////////////
+template<typename Type>
+class ObjectDelegator_arg0 :
+  public Delegator<void (*)(GObject*)> 
+{
+public:
+  typedef Type type;
+  typedef void (Type::*Function)(GObject*);
+
+private:  
+  Type*    obj;
+  Function   func_ptr;
+
+public:
+  ObjectDelegator_arg0(Type* o, Function f) : obj(o), func_ptr(f) {};
+  void emit(GObject* t) {
+    if (obj)
+      (obj->*func_ptr)(t);
+  }
+};
+
+template<typename Type, typename Arg1>
+class ObjectDelegator_arg1 :
+  public Delegator<void (*)(GObject*, Arg1)> 
+{
+public:
+  typedef Type type;
+  typedef void (Type::*Function)(GObject*, Arg1 a1);
+
+private:  
+  Type*    obj;
+  Function func_ptr;
+
+public:
+  ObjectDelegator_arg1(Type* o, Function f) : obj(o), func_ptr(f) {}; 
+  void emit(GObject* t, Arg1 a1) {
+    if (obj)
+      (obj->*func_ptr)(t, a1);
+  }
+};
+
+template<typename Type, typename Arg1, typename Arg2>
+class ObjectDelegator_arg2 : 
+  public Delegator<void (*)(GObject*,Arg1, Arg2)> 
+{
+public:
+  typedef Type type;
+  typedef void (Type::*Function)(GObject*, Arg1 a1, Arg2 a2);
+
+private:  
+  Type*    obj;
+  Function func_ptr;
+
+public:
+  ObjectDelegator_arg2(Type* o, Function f) : obj(o), func_ptr(f) {};
+  void emit(GObject* t, Arg1 a1, Arg2 a2) {
+    g_print("emit:obj=%ld\n", (unsigned long)obj);
+    if (obj)
+      (obj->*func_ptr)(t, a1, a2);
+  }
+};
+
+template<typename Type, typename Arg1, typename Arg2, typename Arg3>
+class ObjectDelegator_arg3 :
+  public Delegator<void (*)(GObject*,Arg1, Arg2, Arg3)> 
+{
+public:
+  typedef Type type;
+  typedef void (Type::*Function)(GObject*, Arg1 a1, Arg2 a2, Arg3 a3);
+
+private:  
+  Type*    obj;
+  Function func_ptr;
+
+public:
+  ObjectDelegator_arg3(Type* o, Function f) : obj(o), func_ptr(f) {};
+  void emit(GObject* t, Arg1 a1, Arg2 a2, Arg3 a3) {
+    if (obj)
+      (obj->*func_ptr)(t, a1, a2, a3);
+  }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+class FunctionDelegator_arg0 :
+  public Delegator<void (*)(GObject*)> 
+{
+public:
+  typedef void (*Function)(GObject*);
+
+private:  
+  Function   func_ptr;
+
+public:
+  FunctionDelegator_arg0(Function f) : func_ptr(f) {};
+  void emit(GObject* t) {
+    if (func_ptr)
+      (*func_ptr)(t);
+  }
+};
+
+template<typename Arg1>
+class FunctionDelegator_arg1 :
+  public Delegator<void (*)(GObject*, Arg1)> 
+{
+public:
+  typedef void (*Function)(GObject*, Arg1 a1);
+
+private:  
+  Function func_ptr;
+
+public:
+  FunctionDelegator_arg1(Function f) : func_ptr(f) {};
+  void emit(GObject* t, Arg1 a1) {
+    if (func_ptr)
+      (*func_ptr)(t, a1);
+  }
+};
+
+template<typename Arg1, typename Arg2>
+class FunctionDelegator_arg2 : 
+  public Delegator<void (*)(GObject*,Arg1, Arg2)> 
+{
+public:
+  typedef void (*Function)(GObject*, Arg1 a1, Arg2 a2);
+
+private:  
+  Function func_ptr;
+
+public:
+  FunctionDelegator_arg2(Function f) : func_ptr(f) {};
+  void emit(GObject* t, Arg1 a1, Arg2 a2) {
+    if (func_ptr)
+      (*func_ptr)(t, a1, a2);
+  }
+};
+
+template<typename Arg1, typename Arg2, typename Arg3>
+class FunctionDelegator_arg3 :
+  public Delegator<void (*)(GObject*,Arg1, Arg2, Arg3)> 
+{
+public:
+  typedef void (*Function)(GObject*, Arg1 a1, Arg2 a2, Arg3 a3);
+
+private:  
+  Function func_ptr;
+
+public:
+  FunctionDelegator_arg3(Function f) : func_ptr(f) {};
+  void emit(GObject* t, Arg1 a1, Arg2 a2, Arg3 a3) {
+    if (func_ptr)
+      (*func_ptr)(t, a1, a2, a3);
+  }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+template<typename Type>
+inline ObjectDelegator_arg0<Type>* 
+delegator(Type* obj,
+          void (Type::*f)(GObject*)) 
+{
+  return new ObjectDelegator_arg0<Type>(obj, f);
+}
+
+template<typename Type, typename Arg1>
+inline ObjectDelegator_arg1<Type, Arg1>* 
+delegator(Type* obj,
+          void (Type::*f)(GObject*, Arg1)) 
+{
+  return new ObjectDelegator_arg1<Type, Arg1>(obj, f);
+}
+
+template<typename Type, typename Arg1, typename Arg2>
+inline ObjectDelegator_arg2<Type, Arg1, Arg2>* 
+delegator(Type* obj,
+          void (Type::*f)(GObject*, Arg1, Arg2)) 
+{
+  return new ObjectDelegator_arg2<Type, Arg1, Arg2>(obj, f);
+}
+
+template<typename Type, typename Arg1, typename Arg2, typename Arg3>
+inline ObjectDelegator_arg3<Type,Arg1, Arg2, Arg3>* 
+delegator(Type* obj,
+          void (Type::*f)(GObject*, Arg1, Arg2, Arg3)) 
+{
+  return new ObjectDelegator_arg3<Type, Arg1, Arg2, Arg3>(obj, f);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+inline FunctionDelegator_arg0* 
+delegator(void (*f)(GObject*)) 
+{
+  return new FunctionDelegator_arg0(f);
+}
+
+template<typename Arg1>
+inline FunctionDelegator_arg1<Arg1>* 
+delegator(void (*f)(GObject*, Arg1)) 
+{
+  return new FunctionDelegator_arg1<Arg1>(f);
+}
+
+template<typename Arg1, typename Arg2>
+inline FunctionDelegator_arg2<Arg1, Arg2>* 
+delegator(void (*f)(GObject*, Arg1, Arg2)) 
+{
+  return new FunctionDelegator_arg2<Arg1, Arg2>(f);
+}
+
+template<typename Arg1, typename Arg2, typename Arg3>
+inline FunctionDelegator_arg3<Arg1, Arg2, Arg3>* 
+delegator(void (*f)(GObject*, Arg1, Arg2, Arg3)) 
+{
+  return new FunctionDelegator_arg3<Arg1, Arg2, Arg3>(f);
+}
+///////////////////////////////////////////////////////////////////////////////
+class Connection {
+  GObject*  target;
+  gchar*    signal;
+  GClosure* closure;
+public:
+  Connection(GObject* target_,
+             const gchar*   signal_,
+             GClosure* closure_)
+  {
+    target  = target_;
+    signal  = g_strdup(signal_);
+    closure = closure_;
+  };
+
+  ~Connection()
+  {
+      disconnect();
+  }
+  
+  void disconnect() {
+    if (target && closure) {
+      gulong handler_id = g_signal_handler_find(gpointer(target), G_SIGNAL_MATCH_CLOSURE, 0, 0, closure, NULL, NULL);
+      g_signal_handler_disconnect(gpointer(target), handler_id);
+    }
+    target  = NULL;
+    closure = NULL;
+  };
+  
+  void block() {
+    if (target && closure) {
+      g_signal_handlers_block_matched (target,
+                                       GSignalMatchType(G_SIGNAL_MATCH_DETAIL|G_SIGNAL_MATCH_CLOSURE),
+                                       0, g_quark_from_static_string (signal), closure, NULL, NULL);
+    }
+  }
+  
+  void unblock() {
+    if (target && closure) {
+      g_signal_handlers_unblock_matched (target,
+                                       GSignalMatchType(G_SIGNAL_MATCH_DETAIL|G_SIGNAL_MATCH_CLOSURE),
+                                       0, g_quark_from_static_string (signal), closure, NULL, NULL);
+    }
+  }
+};
+
+
+}; // namespace
+///////////////////////////////////////////////////////////////////////////////
+template<typename T>
+void closure_destroy_notify(gpointer data, GClosure* closure)
+{
+  Delegator::destroy_cxx_object_callback<T>(data);
+}
+
+template<typename Function>
+Delegator::Connection *
+g_signal_connect_delegator (GObject* target, 
+                            const gchar* event, 
+                            Delegator::Delegator<Function>* delegator, 
+                            bool after=false)
+{
+  GClosure *closure;  
+  closure = g_cclosure_new (G_CALLBACK (Delegator::Delegator<Function>::callback),
+                            (gpointer)delegator, 
+                            closure_destroy_notify<Delegator::Delegator<Function> >);
+  g_signal_connect_closure (target, event, closure, after);
+  return new Delegator::Connection(target, event, closure);
+}
+
+template<typename T>
+inline void g_object_set_cxx_object (GObject* target, const gchar* key, T* object)
+{
+  g_object_set_data_full(target, key, (gpointer)object, Delegator::destroy_cxx_object_callback<T>);
+}
+
+inline gulong
+g_signal_handler_get_id(GObject* target, GClosure* closure)
+{
+  return g_signal_handler_find(gpointer(target), G_SIGNAL_MATCH_CLOSURE, 0, 0, closure, NULL, NULL);
+}
+
+inline void
+g_signal_disconnect (GObject* target,
+                     GClosure* closure)
+{
+  gulong handler_id = g_signal_handler_get_id(target, closure);
+	g_signal_handler_disconnect(gpointer(target), handler_id);
+}
+
+inline void
+g_signal_disconnect (GObject* target,
+                     gulong handler_id)
+{
+	g_signal_handler_disconnect(gpointer(target), handler_id);
+}
+
+#endif
diff -Naur gimp-2.8.14/app/base/glib-cxx-utils.hpp gimp-2.8.14-new/app/base/glib-cxx-utils.hpp
--- gimp-2.8.14/app/base/glib-cxx-utils.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/base/glib-cxx-utils.hpp	2015-01-27 17:48:39.676752639 +0800
@@ -0,0 +1,57 @@
+#ifndef __GLIB_CXX_UTILS_HPP__
+#define __GLIB_CXX_UTILS_HPP__
+
+extern "C" {
+#include <glib.h>
+}
+
+#include "base/scopeguard.hpp"
+
+class MemoryHolder : public ScopeGuard<gchar, void(gpointer)>
+{
+public:
+  MemoryHolder(const gpointer data) : ScopeGuard<gchar, void(gpointer)>((gchar*)data, g_free) {};
+  template<typename T> operator T*() { return (T*)obj; };
+  template<typename T> operator T* const() { return (T*)obj; };
+};
+
+class StringHolder : public ScopeGuard<gchar, void(gpointer)>
+{
+public:
+  StringHolder(gchar* str) : ScopeGuard<gchar, void(gpointer)>(str, g_free) {};
+};
+
+template<typename Key, typename Data>
+class GHashTableHolder : public ScopeGuard<GHashTable, void(GHashTable*)>
+{
+public:
+  GHashTableHolder(GHashTable* table) : ScopeGuard<GHashTable, void(GHashTable*)>(table, g_hash_table_unref) {};
+
+  Data lookup(const Key data) {
+    return reinterpret_cast<Data>(g_hash_table_lookup(obj, (const gpointer)data));
+  }
+  Data operator[](const Key data) {
+    return lookup(data);
+  }
+};
+
+class GListHolder : public ScopeGuard<GList, void(GList*)>
+{
+public:
+  GListHolder(GList* list) : ScopeGuard<GList, void(GList*)>(list, g_list_free) {};
+};
+
+class GObjectRefPtr : public ScopeGuard<GObject, void(gpointer)>
+{
+public:
+  GObjectRefPtr(GObject* object) : ScopeGuard<GObject, void(gpointer)>(object, g_object_unref) {};
+};
+
+template<typename Class>
+class RefPtr : public GObjectRefPtr
+{
+public:
+  RefPtr(Class* object) : GObjectRefPtr(G_OBJECT(object)) {};
+  Class* as(GType type_id) { return G_TYPE_CHECK_INSTANCE_CAST ((obj), type_id, Class); }
+};
+#endif
diff -Naur gimp-2.8.14/app/base/Makefile.am gimp-2.8.14-new/app/base/Makefile.am
--- gimp-2.8.14/app/base/Makefile.am	2015-01-27 17:28:36.876833810 +0800
+++ gimp-2.8.14-new/app/base/Makefile.am	2015-01-27 17:48:39.674752639 +0800
@@ -71,7 +71,10 @@
 	tile-rowhints.c		\
 	tile-rowhints.h		\
 	tile-swap.c		\
-	tile-swap.h
+	tile-swap.h		\
+	pixel.hpp		\
+	delegators.hpp		\
+	scopeguard.hpp
 
 #
 # rules to generate built sources
diff -Naur gimp-2.8.14/app/base/pixel.hpp gimp-2.8.14-new/app/base/pixel.hpp
--- gimp-2.8.14/app/base/pixel.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/base/pixel.hpp	2015-01-27 17:48:39.679752639 +0800
@@ -0,0 +1,358 @@
+#ifndef __PIXEL_HPP__
+#define __PIXEL_HPP__
+
+struct Pixel {
+  // Currently BPP=8 is assumed.
+  typedef guchar  data_t;
+  typedef guint32 internal_t;
+  typedef float  real;
+  
+  template<typename T> struct expressions {
+    typedef T E_TYPE;
+    T e; 
+    expressions(const T& src) : e(src) {};
+  };
+  
+  
+  struct value_t {
+    static const int DEGREE = 1;
+    data_t v;
+    value_t(const data_t src) : v(src) {}
+    expressions<value_t> wrap() const { return expressions<value_t>(*this); }
+  };
+  struct real_t {
+    static const int DEGREE = 1;
+    real v;
+    real_t(const real src) : v(src) {}
+    expressions<real_t> wrap() const { return expressions<real_t>(*this); }
+  };
+  template<typename T1, typename T2> struct prod_t {
+    static const int DEGREE = T1::E_TYPE::DEGREE + T2::E_TYPE::DEGREE;
+    T1 left;
+    T2 right;
+    prod_t(const T1& l, const T2& r) : left(l), right(r) {}
+    expressions<prod_t> wrap() const { return expressions<prod_t>(*this); }
+  };
+  template<typename T1, typename T2> struct add_t {
+    static const int DEGREE = T1::E_TYPE::DEGREE > T2::E_TYPE::DEGREE ? 
+      T1::E_TYPE::DEGREE : T2::E_TYPE::DEGREE;
+    T1 left;
+    T2 right;
+    add_t(const T1& l, const T2& r) : left(l), right(r) {}
+    expressions<add_t> wrap() const { return expressions<add_t>(*this); }
+  };
+  template<typename T1, typename T2> struct sub_t {
+    static const int DEGREE = T1::E_TYPE::DEGREE > T2::E_TYPE::DEGREE ? 
+      T1::E_TYPE::DEGREE : T2::E_TYPE::DEGREE;
+    T1 left;
+    T2 right;
+    sub_t(const T1& l, const T2& r) : left(l), right(r) {}
+    expressions<sub_t> wrap() const { return expressions<sub_t>(*this); }
+  };
+  template<typename T1, typename T2> struct div_t {
+    static const int DEGREE = T1::E_TYPE::DEGREE - T2::E_TYPE::DEGREE;
+    T1 numer;
+    T2 denom;
+    div_t(const T1& l, const T2& r) : numer(l), denom(r) {}
+    expressions<div_t> wrap() const { return expressions<div_t>(*this); }
+  };
+  static const int DEPTH = sizeof(data_t) * 8;
+  static const data_t MAX_VALUE = (data_t)((internal_t)(1 << DEPTH) - 1);
+  
+  static data_t from_f(const float v) { 
+    return (data_t)(CLAMP(CLAMP(v, 0, 1.0) * MAX_VALUE + 0.5f, 0, MAX_VALUE));
+  };
+  static float to_f(const data_t v) {
+    return ((float)v) / (float)MAX_VALUE;
+  };
+  static data_t from_u8(const guchar v) {
+    return v;
+  };
+  static guchar to_u8(const data_t v) {
+    return v;
+  };
+  typedef expressions<Pixel::value_t> pixel_t;
+  typedef expressions<Pixel::real_t>  rpixel_t;
+  static data_t clamp(const internal_t value, const internal_t min, const internal_t max) {
+    return (data_t)((value < min)? min: (value > max)? max: value);
+  }
+  static real clamp(const real value, const real min, const real max) {
+    return (real)((value < min)? min: (value > max)? max: value);
+  }
+};
+
+
+
+template<typename T1, typename T2>
+inline
+Pixel::expressions<Pixel::prod_t<Pixel::expressions<T1>, Pixel::expressions<T2> > > 
+operator * (const Pixel::expressions<T1>& l,
+             const Pixel::expressions<T2>& r) {
+  return Pixel::prod_t<Pixel::expressions<T1>, Pixel::expressions<T2> >(l, r).wrap();
+}
+
+template<typename T1, typename T2>
+inline
+Pixel::expressions<Pixel::div_t<Pixel::expressions<T1>, Pixel::expressions<T2> > > 
+operator / (const Pixel::expressions<T1>& l,
+             const Pixel::expressions<T2>& r) {
+  return Pixel::div_t<Pixel::expressions<T1>,Pixel::expressions<T2> >(l, r).wrap();
+}
+
+template<typename T1, typename T2>
+inline
+Pixel::expressions<Pixel::add_t<Pixel::expressions<T1>, Pixel::expressions<T2> > >
+operator + (const Pixel::expressions<T1>& l, const Pixel::expressions<T2>& r) {
+  return Pixel::add_t<Pixel::expressions<T1>,Pixel::expressions<T2> >(l, r).wrap();
+}
+
+
+template<typename T1, typename T2>
+inline
+Pixel::expressions<Pixel::sub_t<Pixel::expressions<T1>, Pixel::expressions<T2> > >
+operator - (const Pixel::expressions<T1>& l, const Pixel::expressions<T2>& r) {
+  return Pixel::sub_t<Pixel::expressions<T1>,Pixel::expressions<T2> >(l, r).wrap();
+}
+
+#ifndef REAL_CALC
+
+typedef Pixel::pixel_t pixel_t;
+typedef Pixel::internal_t internal_t;
+typedef Pixel::data_t result_t;
+
+// x -> P(x)
+inline
+pixel_t pix(const Pixel::data_t v) { 
+  return Pixel::value_t(v).wrap();
+}
+
+inline
+pixel_t pix(const Pixel::real v) { 
+  return Pixel::value_t(Pixel::from_f(v)).wrap();
+}
+// f -> P(_(f))
+inline
+pixel_t f2p(const Pixel::real f) { 
+  return pix(f);
+}
+
+inline
+internal_t raw(const pixel_t& c) {
+  return (Pixel::internal_t)c.e.v;
+}
+
+inline
+internal_t raw(const Pixel::expressions<Pixel::real_t>& c) {
+  return (Pixel::internal_t)(Pixel::from_f(c.e.v));
+}
+
+inline
+result_t eval(const pixel_t& c) {
+  return (result_t)c.e.v;
+}
+
+template<typename T1, typename T2>
+inline
+internal_t raw(const Pixel::expressions<Pixel::prod_t<T1, T2> >& t) {
+  return raw(t.e.left) * raw(t.e.right);
+}
+
+template<typename T1, typename T2>
+inline
+internal_t raw(const Pixel::expressions<Pixel::div_t<T1, T2> >& t) {
+  return raw(t.e.numer) / raw(t.e.denom);
+}
+
+template<typename T1, typename T2>
+inline
+internal_t raw(const Pixel::expressions<Pixel::add_t<T1, T2> >& t) {
+  switch (T1::E_TYPE::DEGREE - T2::E_TYPE::DEGREE) {
+  case -3:
+    return raw(t.e.left * f2p(1.0) * f2p(1.0) * f2p(1.0)) + raw(t.e.right);
+  case -2:
+    return raw(t.e.left * f2p(1.0) * f2p(1.0)) + raw(t.e.right);
+  case -1:
+    return raw(t.e.left * f2p(1.0)) + raw(t.e.right);
+  case  0:
+    return raw(t.e.left) + raw(t.e.right);
+  case  1:
+    return raw(t.e.left) + raw(t.e.right * f2p(1.0));
+  case  2:
+    return raw(t.e.left) + raw(t.e.right * f2p(1.0) * f2p(1.0));
+  case  3:
+    return raw(t.e.left) + raw(t.e.right * f2p(1.0) * f2p(1.0) * f2p(1.0));
+  default:
+    throw "unsupported complexity";
+  }
+}
+
+template<typename T1, typename T2>
+inline
+internal_t raw(const Pixel::expressions<Pixel::sub_t<T1, T2> >& t) {
+  switch (T1::E_TYPE::DEGREE - T2::E_TYPE::DEGREE) {
+  case -3:
+    return raw(t.e.left * f2p(1.0) * f2p(1.0) * f2p(1.0)) - raw(t.e.right);
+  case -2:
+    return raw(t.e.left * f2p(1.0) * f2p(1.0)) - raw(t.e.right);
+  case -1:
+    return raw(t.e.left * f2p(1.0)) - raw(t.e.right);
+  case  0:
+    return raw(t.e.left) - raw(t.e.right);
+  case  1:
+    return raw(t.e.left) - raw(t.e.right * f2p(1.0));
+  case  2:
+    return raw(t.e.left) - raw(t.e.right * f2p(1.0) * f2p(1.0));
+  case  3:
+    return raw(t.e.left) - raw(t.e.right * f2p(1.0) * f2p(1.0) * f2p(1.0));
+  default:
+    throw "unsupported complexity";
+  }
+}
+
+template<typename T>
+inline
+result_t eval(const Pixel::expressions<T>& t) {
+  const int deg = T::DEGREE;
+  Pixel::internal_t value = 0;
+  switch (deg) {
+  case 3:
+    value = raw(t) / raw(f2p(1.0)*f2p(1.0));
+    break;
+  case 2:
+    value = raw(t) / raw(f2p(1.0));
+    break;
+  case 1:
+    value = raw(t);
+    break;
+  case 0:
+    value = raw(t) * raw(f2p(1.0));
+    break;
+  case -1:
+    value = raw(t) * raw(f2p(1.0) * f2p(1.0));
+    break;
+  case -2:
+    value = raw(t) * raw(f2p(1.0) * f2p(1.0) * f2p(1.0));
+    break;
+  default:
+    throw "unsupported type";
+  }
+  return Pixel::clamp(value, Pixel::from_f(0.0), Pixel::from_f(1.0));
+}
+template<typename T1, typename T2>
+inline
+result_t eval(const Pixel::expressions<Pixel::div_t<T1, T2> >& t) {
+  const int deg = Pixel::div_t<T1, T2>::DEGREE;
+  Pixel::internal_t value = 0;
+  switch (deg) {
+  case 3:
+    value = raw(t) / raw(f2p(1.0)*f2p(1.0));
+    break;
+  case 2:
+    value = raw(t) / raw(f2p(1.0));
+    break;
+  case 1:
+    value = raw(t);
+    break;
+  case 0:
+    value = raw(t.e.numer) * raw(f2p(1.0)) / raw(t.e.denom);
+    break;
+  case -1:
+    value = raw(t.e.numer) * raw(f2p(1.0) * f2p(1.0)) / raw(t.e.denom);
+    break;
+  case -2:
+    value = raw(t.e.numer) * raw(f2p(1.0) * f2p(1.0) * f2p(1.0)) / raw(t.e.denom);
+    break;
+  default:
+    throw "unsupported type";
+  }
+  return Pixel::clamp(value, Pixel::from_f(0.0), Pixel::from_f(1.0));
+}
+
+inline Pixel::data_t r2d(const result_t v) {
+  return v;
+}
+
+inline internal_t r2i(const result_t v) {
+  return (internal_t)v;
+}
+
+inline Pixel::real r2f(const result_t v) {
+  return Pixel::to_f(v);
+}
+
+
+#else /* REAL_CALC */
+
+typedef Pixel::rpixel_t pixel_t;
+typedef Pixel::real internal_t;
+typedef Pixel::real result_t;
+
+// x -> P(x)
+inline
+pixel_t pix(const Pixel::data_t v) { 
+  return Pixel::real_t((float)v / (float)(Pixel::MAX_VALUE)).wrap();
+}
+
+inline
+pixel_t pix(const Pixel::real v) { 
+  return Pixel::real_t(v).wrap();
+}
+// f -> P(_(f))
+inline
+pixel_t f2p(const Pixel::real f) { 
+  return pix(f);
+}
+
+inline
+internal_t raw(const Pixel::pixel_t& c) {
+  return (internal_t)Pixel::to_f(c.e.v);
+}
+
+inline
+internal_t raw(const pixel_t& c) {
+  return (internal_t)c.e.v;
+}
+
+template<typename T1, typename T2>
+inline
+internal_t raw(const Pixel::expressions<Pixel::prod_t<T1, T2> >& t) {
+  return raw(t.e.left) * raw(t.e.right);
+}
+
+template<typename T1, typename T2>
+inline
+internal_t raw(const Pixel::expressions<Pixel::div_t<T1, T2> >& t) {
+  return raw(t.e.numer) / raw(t.e.denom);
+}
+
+template<typename T1, typename T2>
+inline
+internal_t raw(const Pixel::expressions<Pixel::add_t<T1, T2> >& t) {
+  return raw(t.e.left) + raw(t.e.right);
+}
+
+template<typename T1, typename T2>
+inline
+internal_t raw(const Pixel::expressions<Pixel::sub_t<T1, T2> >& t) {
+  return raw(t.e.left) - raw(t.e.right);
+}
+
+template<typename T>
+inline result_t eval(const Pixel::expressions<T>& t) {
+  return Pixel::clamp(raw(t), 0.0, 1.0);
+}
+
+inline Pixel::data_t r2d(const result_t v) {
+  return (Pixel::data_t)Pixel::clamp(((float)Pixel::MAX_VALUE) * v + 0.5f, 0.0f, (Pixel::real)Pixel::MAX_VALUE);
+}
+
+inline internal_t r2i(const result_t v) {
+  return v;
+}
+
+inline Pixel::real r2f(const result_t v) {
+  return v;
+}
+
+#endif
+#endif
diff -Naur gimp-2.8.14/app/base/pixel-processor.c gimp-2.8.14-new/app/base/pixel-processor.c
--- gimp-2.8.14/app/base/pixel-processor.c	2015-01-27 17:28:36.880833810 +0800
+++ gimp-2.8.14-new/app/base/pixel-processor.c	2015-01-27 17:48:39.677752639 +0800
@@ -58,6 +58,12 @@
                            PixelRegion  *region2,
                            PixelRegion  *region3,
                            PixelRegion  *region4);
+typedef void  (* p5_func) (gpointer      data,
+                           PixelRegion  *region1,
+                           PixelRegion  *region2,
+                           PixelRegion  *region3,
+                           PixelRegion  *region4,
+                           PixelRegion  *region5);
 
 
 typedef struct _PixelProcessor PixelProcessor;
@@ -75,7 +81,7 @@
 
   PixelRegionIterator *PRI;
   gint                 num_regions;
-  PixelRegion         *regions[4];
+  PixelRegion         *regions[5];
 
   gulong               progress;
 };
@@ -85,7 +91,7 @@
 static void
 do_parallel_regions (PixelProcessor *processor)
 {
-  PixelRegion tr[4];
+  PixelRegion tr[5];
   gint        i;
 
   g_mutex_lock (processor->mutex);
@@ -141,6 +147,14 @@
                                        processor->regions[2] ? &tr[2] : NULL,
                                        processor->regions[3] ? &tr[3] : NULL);
           break;
+        case 5:
+          ((p5_func) processor->func) (processor->data,
+                                       processor->regions[0] ? &tr[0] : NULL,
+                                       processor->regions[1] ? &tr[1] : NULL,
+                                       processor->regions[2] ? &tr[2] : NULL,
+                                       processor->regions[3] ? &tr[3] : NULL,
+                                       processor->regions[4] ? &tr[4] : NULL);
+          break;
 
         default:
           g_warning ("do_parallel_regions: Bad number of regions %d\n",
@@ -231,6 +245,15 @@
                                        processor->regions[3]);
           break;
 
+        case 5:
+          ((p5_func) processor->func) (processor->data,
+                                       processor->regions[0],
+                                       processor->regions[1],
+                                       processor->regions[2],
+                                       processor->regions[3],
+                                       processor->regions[4]);
+          break;
+
         default:
           g_warning ("do_parallel_regions_single: Bad number of regions %d\n",
                      processor->num_regions);
@@ -384,6 +407,15 @@
                                               processor.regions[3]);
       break;
 
+    case 5:
+      processor.PRI = pixel_regions_register (num_regions,
+                                              processor.regions[0],
+                                              processor.regions[1],
+                                              processor.regions[2],
+                                              processor.regions[3],
+                                              processor.regions[4]);
+      break;
+
     default:
       g_warning ("pixel_regions_process_parallel: "
                  "bad number of regions (%d)", processor.num_regions);
diff -Naur gimp-2.8.14/app/base/pixel-region.c gimp-2.8.14-new/app/base/pixel-region.c
--- gimp-2.8.14/app/base/pixel-region.c	2015-01-27 17:28:36.880833810 +0800
+++ gimp-2.8.14-new/app/base/pixel-region.c	2015-01-27 17:48:39.678752639 +0800
@@ -80,6 +80,9 @@
   PR->h             = h;
   PR->dirty         = dirty;
   PR->process_count = 0;
+  PR->closed_loop   = FALSE;
+  PR->loop_w        = w;
+  PR->loop_h        = h;
 }
 
 void
@@ -96,13 +99,16 @@
   PR->offx          = 0;
   PR->offy          = 0;
   PR->bytes         = temp_buf->bytes;
-  PR->rowstride     = temp_buf->width * temp_buf->bytes;
+  PR->rowstride     = temp_buf_get_rowstride (temp_buf);
   PR->x             = x;
   PR->y             = y;
   PR->w             = w;
   PR->h             = h;
   PR->dirty         = FALSE;
   PR->process_count = 0;
+  PR->closed_loop   = FALSE;
+  PR->loop_w        = w;
+  PR->loop_h        = h;
 }
 
 void
@@ -128,6 +134,9 @@
   PR->h             = h;
   PR->dirty         = FALSE;
   PR->process_count = 0;
+  PR->closed_loop   = FALSE;
+  PR->loop_w        = w;
+  PR->loop_h        = h;
 }
 
 void
@@ -141,6 +150,10 @@
   PR->y = y;
   PR->w = w;
   PR->h = h;
+  if (PR->closed_loop) {
+    PR->loop_w = PR->w;
+    PR->loop_h = PR->h;
+  }
 }
 
 void
@@ -274,6 +287,23 @@
   tile_manager_write_pixel_data (PR->tiles, x, y, x, end-1, data, bpp);
 }
 
+void
+pixel_region_set_closed_loop (PixelRegion  *PR,
+                              gboolean value)
+{
+  PR->closed_loop = value;
+  if (PR->closed_loop) {
+    PR->loop_w = PR->w;
+    PR->loop_h = PR->h;
+  }
+}
+
+gboolean
+pixel_region_get_closed_loop (PixelRegion  *PR)
+{
+  return PR->closed_loop;
+}
+
 gboolean
 pixel_region_has_alpha (PixelRegion *PR)
 {
@@ -321,7 +351,7 @@
           PRH->starty            = PR->y;
           PRH->PR->process_count = 0;
 
-          if (! found)
+          if (! found && !PRH->PR->closed_loop)
             {
               found = TRUE;
 
@@ -437,19 +467,30 @@
       if (PRH->PR)
         {
           /*  Check if we're past the point of no return  */
-          if ((PRH->PR->y - PRH->starty) >= PRI->region_height)
+          if (!PRH->PR->closed_loop &&
+              (PRH->PR->y - PRH->starty) >= PRI->region_height)
             return 0;
 
           if (PRH->PR->tiles)
             {
-              height = TILE_HEIGHT - (PRH->PR->y % TILE_HEIGHT);
-              height = CLAMP (height,
-                              0,
-                              (PRI->region_height - (PRH->PR->y - PRH->starty)));
+              if (PRH->PR->closed_loop) {
+                gint y = PRH->PR->y % PRH->PR->loop_h;
+                height = TILE_HEIGHT - (y % TILE_HEIGHT);
+              } else {
+                height = TILE_HEIGHT - (PRH->PR->y % TILE_HEIGHT);
+                height = CLAMP (height,
+                                0,
+                                (PRI->region_height - (PRH->PR->y - PRH->starty)));
+              }
             }
           else
             {
-              height = (PRI->region_height - (PRH->PR->y - PRH->starty));
+              if (PRH->PR->closed_loop) {
+                gint y = PRH->PR->y % PRH->PR->loop_h;
+                height = (PRH->PR->loop_h - y);
+              } else {
+                height = (PRI->region_height - (PRH->PR->y - PRH->starty));
+              }
             }
 
           if (height < min_height)
@@ -480,19 +521,29 @@
       if (PRH->PR)
         {
           /*  Check if we're past the point of no return  */
-          if ((PRH->PR->x - PRH->startx) >= PRI->region_width)
+          if (!PRH->PR->closed_loop &&
+              (PRH->PR->x - PRH->startx) >= PRI->region_width)
             return 0;
 
           if (PRH->PR->tiles)
             {
-              width = TILE_WIDTH - (PRH->PR->x % TILE_WIDTH);
-              width = CLAMP (width,
-                             0,
-                             (PRI->region_width - (PRH->PR->x - PRH->startx)));
+              if (PRH->PR->closed_loop) {
+                gint x = PRH->PR->x % PRH->PR->loop_w;
+                width = TILE_WIDTH - (x % TILE_WIDTH);
+              } else {
+                width = TILE_WIDTH - (PRH->PR->x % TILE_WIDTH);
+                width = CLAMP (width,
+                               0,
+                               (PRI->region_width - (PRH->PR->x - PRH->startx)));
+              }
             }
           else
             {
-              width = (PRI->region_width - (PRH->PR->x - PRH->startx));
+              if (PRH->PR->closed_loop) {
+                gint x = PRH->PR->x % PRH->PR->loop_w;
+                width = (PRH->PR->loop_w - x);
+              } else
+                width = (PRI->region_width - (PRH->PR->x - PRH->startx));
             }
 
           if (width < min_width)
@@ -556,6 +607,12 @@
 pixel_region_configure (PixelRegionHolder   *PRH,
                         PixelRegionIterator *PRI)
 {
+  gint x = PRH->PR->x;
+  gint y = PRH->PR->y;
+  if (PRH->PR->closed_loop)
+    x = x % PRH->PR->loop_w;
+  if (PRH->PR->closed_loop)
+    y = y % PRH->PR->loop_h;
   /*  Configure the rowstride and data pointer for the pixel region
    *  based on the current offsets into the region and whether the
    *  region is represented by a tile manager or not
@@ -563,13 +620,13 @@
   if (PRH->PR->tiles)
     {
       PRH->PR->curtile = tile_manager_get_tile (PRH->PR->tiles,
-                                                PRH->PR->x,
-                                                PRH->PR->y,
+                                                x,
+                                                y,
                                                 TRUE,
                                                 PRH->PR->dirty);
 
-      PRH->PR->offx = PRH->PR->x % TILE_WIDTH;
-      PRH->PR->offy = PRH->PR->y % TILE_HEIGHT;
+      PRH->PR->offx = x % TILE_WIDTH;
+      PRH->PR->offy = y % TILE_HEIGHT;
 
       PRH->PR->rowstride = tile_ewidth (PRH->PR->curtile) * PRH->PR->bytes;
       PRH->PR->data = tile_data_pointer (PRH->PR->curtile,
@@ -578,9 +635,10 @@
     }
   else
     {
+      if (PRH->PR->closed_loop);
       PRH->PR->data = (PRH->original_data +
-                       PRH->PR->y * PRH->PR->rowstride +
-                       PRH->PR->x * PRH->PR->bytes);
+                       y * PRH->PR->rowstride +
+                       x * PRH->PR->bytes);
     }
 
   PRH->PR->w = PRI->portion_width;
diff -Naur gimp-2.8.14/app/base/pixel-region.h gimp-2.8.14-new/app/base/pixel-region.h
--- gimp-2.8.14/app/base/pixel-region.h	2015-01-27 17:28:36.877833810 +0800
+++ gimp-2.8.14-new/app/base/pixel-region.h	2015-01-27 17:48:39.678752639 +0800
@@ -34,6 +34,9 @@
   gint         bytes;          /*  bytes per pixel               */
   gboolean     dirty;          /*  will this region be dirtied?  */
   gint         process_count;  /*  used internally               */
+  gboolean     closed_loop;
+  gint         loop_w;
+  gint         loop_h;
 };
 
 struct _PixelRegionHolder
@@ -106,6 +109,10 @@
                                      gint                 y,
                                      gint                 h,
                                      const guchar        *data);
+void     pixel_region_set_closed_loop (PixelRegion       *PR,
+                                       gboolean           value);
+gboolean  pixel_region_get_closed_loop (PixelRegion       *PR);
+
 gboolean pixel_region_has_alpha     (PixelRegion         *PR);
 
 PixelRegionIterator * pixel_regions_register     (gint    num_regions,
diff -Naur gimp-2.8.14/app/base/scopeguard.hpp gimp-2.8.14-new/app/base/scopeguard.hpp
--- gimp-2.8.14/app/base/scopeguard.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/base/scopeguard.hpp	2015-01-27 17:48:39.679752639 +0800
@@ -0,0 +1,22 @@
+#ifndef __SCOPE_GUARD_HPP__
+#define __SCOPE_GUARD_HPP__
+
+template<class T, class F>
+class ScopeGuard {
+protected:
+  T* obj;
+  F* func;
+public:
+  ScopeGuard(T* ptr, F* f) : obj(ptr), func(f) {};
+  ~ScopeGuard() {
+    if (func && obj)
+      func(obj);
+  }
+  T& operator *() { return *obj; }
+  T* operator ->() { return obj; }
+  T* ptr() { return obj; }
+  operator T*() { return obj; }
+  operator T*() const { return obj; }
+};
+
+#endif
diff -Naur gimp-2.8.14/app/base/temp-buf.c gimp-2.8.14-new/app/base/temp-buf.c
--- gimp-2.8.14/app/base/temp-buf.c	2015-01-27 17:28:36.874833810 +0800
+++ gimp-2.8.14-new/app/base/temp-buf.c	2015-01-27 17:48:39.680752639 +0800
@@ -65,6 +65,7 @@
   temp->y       = y;
 
   temp->data = g_new (guchar, width * height * bytes);
+  temp->parent  = NULL; 
 
   /*  initialize the data  */
   if (color)
@@ -147,6 +148,49 @@
   return dest;
 }
 
+
+TempBuf *
+temp_buf_subwindow (TempBuf *parent,
+                    gint x,
+                    gint y,
+                    gint w,
+                    gint h)
+{
+  TempBuf *temp;
+  gint     x2, y2;
+  gint     parent_x2, parent_y2;
+  gint     ofs_x, ofs_y;
+  gint     rowstride;
+
+  g_return_val_if_fail (parent != NULL, NULL);
+  g_return_val_if_fail (w > 0 && h > 0, NULL);
+
+  x2        = x + w;
+  y2        = y + h;  
+  parent_x2 = parent->x + parent->width;
+  parent_y2 = parent->y + parent->height;
+    
+  g_return_val_if_fail (x < parent_x2 && y < parent_y2, NULL);
+  g_return_val_if_fail (parent->x < x2 && parent->y < y2, NULL);
+
+  temp = g_slice_new (TempBuf);
+
+  temp->bytes   = parent->bytes;
+  temp->x       = MAX (parent->x, x);
+  temp->y       = MAX (parent->y, y);
+  temp->width   = MIN (x2, parent_x2) - temp->x;
+  temp->height  = MIN (y2, parent_y2) - temp->y;
+  temp->parent  = parent;
+  
+  ofs_x     = temp->x - parent->x;
+  ofs_y     = temp->y - parent->y;
+  rowstride = temp_buf_get_rowstride (parent);
+
+  temp->data    = parent->data + ofs_y * rowstride + temp->bytes * ofs_x;
+
+  return temp;
+}
+
 TempBuf *
 temp_buf_resize (TempBuf *buf,
                  gint     bytes,
@@ -346,6 +390,9 @@
 {
   g_return_if_fail (buf != NULL);
 
+  if (buf->parent)
+    return;
+
   if (buf->data)
     g_free (buf->data);
 
@@ -500,3 +547,13 @@
       break;
     }
 }
+
+gint
+temp_buf_get_rowstride (TempBuf *buf)
+{
+  g_return_val_if_fail (buf, -1);
+  
+  if (buf->parent)
+    return temp_buf_get_rowstride (buf->parent);
+  return buf->width * buf->bytes;
+}
diff -Naur gimp-2.8.14/app/base/temp-buf.h gimp-2.8.14-new/app/base/temp-buf.h
--- gimp-2.8.14/app/base/temp-buf.h	2015-01-27 17:28:36.881833810 +0800
+++ gimp-2.8.14-new/app/base/temp-buf.h	2015-01-27 17:48:39.680752639 +0800
@@ -27,6 +27,10 @@
   gint      x, y;       /*  origin of data source                          */
   guchar   *data;       /*  The data buffer. Do never access this field
                             directly, use temp_buf_get_data() instead !!   */
+  TempBuf  *parent;     /* parent temp_buf. subwindowed TempBuf has a      */
+                        /* pointer to the windowing parent TempBuf. subwindowed */ 
+                        /* TempBuf does no memory management, so should be */
+                        /* managed its lifecycle carefully.                */
 };
 
 
@@ -69,5 +73,12 @@
 void      temp_buf_dump          (TempBuf       *buf,
                                   const gchar   *filename);
 
+TempBuf * temp_buf_subwindow     (TempBuf       *parent,
+                                  gint           x,
+                                  gint           y,
+                                  gint           width,
+                                  gint           height);
+
+gint      temp_buf_get_rowstride (TempBuf       *buf);
 
 #endif  /*  __TEMP_BUF_H__  */
diff -Naur gimp-2.8.14/app/composite/gimp-composite.c gimp-2.8.14-new/app/composite/gimp-composite.c
--- gimp-2.8.14/app/composite/gimp-composite.c	2015-01-27 17:28:36.802833815 +0800
+++ gimp-2.8.14-new/app/composite/gimp-composite.c	2015-01-27 17:48:39.684752638 +0800
@@ -145,6 +145,10 @@
     { TRUE,  FALSE, TRUE,  },     /*  GIMP_ERASE_MODE         */
     { TRUE,  TRUE,  TRUE,  },     /*  GIMP_REPLACE_MODE       */
     { TRUE,  TRUE,  FALSE, },     /*  GIMP_ANTI_ERASE_MODE    */
+    { TRUE,  FALSE, TRUE   },     /*  GIMP_SRC_IN_MODE */
+    { TRUE,  FALSE, TRUE   },     /*  GIMP_DST_IN_MODE */
+    { TRUE,  FALSE, TRUE   },     /*  GIMP_SRC_OUT_MODE */
+    { TRUE,  FALSE, TRUE   },     /*  GIMP_DST_OUT_MODE */
 
     { FALSE, FALSE, FALSE },      /*  GIMP_SWAP */
     { FALSE, FALSE, FALSE },      /*  GIMP_SCALE */
@@ -268,6 +272,10 @@
     case GIMP_COMPOSITE_SCALE:         return ("GIMP_COMPOSITE_SCALE");
     case GIMP_COMPOSITE_CONVERT:       return ("GIMP_COMPOSITE_CONVERT");
     case GIMP_COMPOSITE_XOR:           return ("GIMP_COMPOSITE_XOR");
+    case GIMP_COMPOSITE_SRC_IN:        return ("GIMP_COMPOSITE_SRC_IN");
+    case GIMP_COMPOSITE_DST_IN:        return ("GIMP_COMPOSITE_DST_IN");
+    case GIMP_COMPOSITE_SRC_OUT:       return ("GIMP_COMPOSITE_SRC_OUT");
+    case GIMP_COMPOSITE_DST_OUT:       return ("GIMP_COMPOSITE_DST_OUT");
     default:
       break;
     }
@@ -380,6 +388,24 @@
                     can_use_altivec ? '+' : '-',
                     can_use_vis     ? '+' : '-');
     }
+  {
+	// FIXME: dump table for debugging
+	int i, j, k, l;
+  for (i = 0; i < GIMP_COMPOSITE_N; i ++) {
+    g_print("CompositeOp:%s \n", gimp_composite_mode_astext (i));
+	for (j = 0; j < GIMP_PIXELFORMAT_N; j ++) {
+	  for (k = 0; k < GIMP_PIXELFORMAT_N; k ++) {
+	    for (l = 0; l < GIMP_PIXELFORMAT_N; l ++) {
+		  if (gimp_composite_function[i][j][k][l])
+			g_print ("  %s %s %s\n",
+					  gimp_composite_pixelformat_astext (j),
+					  gimp_composite_pixelformat_astext (k),
+					  gimp_composite_pixelformat_astext (l));
+	    }
+	  }
+	}
+  }
+  }
 }
 
 gboolean
diff -Naur gimp-2.8.14/app/composite/gimp-composite-generic.c gimp-2.8.14-new/app/composite/gimp-composite-generic.c
--- gimp-2.8.14/app/composite/gimp-composite-generic.c	2015-01-27 17:28:36.801833815 +0800
+++ gimp-2.8.14-new/app/composite/gimp-composite-generic.c	2015-01-27 17:48:39.683752638 +0800
@@ -1415,6 +1415,112 @@
 }
 
 /**
+ * gimp_composite_src_in_any_any_any_generic:
+ * @ctx: The compositing context.
+ *
+ * Perform a dst-in operation between sources ctx->A and ctx->B, using
+ * the generalised algorithm: D = A * (255 - &beta;) + B * &beta;
+ *
+ * The result is left in ctx->D
+ **/
+void
+gimp_composite_src_in_any_any_any_generic (GimpCompositeContext *ctx)
+{
+  const guchar *src1 = ctx->A;
+  const guchar *src2 = ctx->B;
+  guchar *dest = ctx->D;
+  guint length = ctx->n_pixels;
+  guint bytes1 = gimp_composite_pixel_bpp[ctx->pixelformat_A];
+  guint bytes2 = gimp_composite_pixel_bpp[ctx->pixelformat_B];
+  const guint has_alpha1 = HAS_ALPHA(bytes1);
+  const guint has_alpha2 = HAS_ALPHA(bytes2);
+  const guint alpha = (has_alpha1 || has_alpha2) ? MAX(bytes1, bytes2) - 1 : bytes1;
+  guint b, tmp;
+
+  if (has_alpha1 && has_alpha2) {
+    while (length--)
+      {
+        for (b = 0; b < alpha; b++)
+          dest[b] = src2[b];
+
+        dest[alpha] = INT_MULT(src1[alpha], src2[alpha], tmp);
+
+        src1 += bytes1;
+        src2 += bytes2;
+        dest += bytes2;
+      }
+  } else if (has_alpha1) {
+    while (length--)
+      {
+        for (b = 0; b < alpha; b++)
+          dest[b] = src2[b];
+
+        dest[alpha] = src1[alpha];
+
+        src1 += bytes1;
+        src2 += bytes2;
+        dest += bytes2;
+      }
+  } else {
+    ctx->D = ctx->B;
+  }
+  ctx->combine = REPLACE_INTEN;
+}
+
+/**
+ * gimp_composite_src_out_any_any_any_generic:
+ * @ctx: The compositing context.
+ *
+ * Perform a dst-out operation between sources ctx->A and ctx->B, using
+ * the generalised algorithm: D = A * (255 - &beta;) + B * &beta;
+ *
+ * The result is left in ctx->D
+ **/
+void
+gimp_composite_src_out_any_any_any_generic (GimpCompositeContext *ctx)
+{
+  const guchar *src1 = ctx->A;
+  const guchar *src2 = ctx->B;
+  guchar *dest = ctx->D;
+  guint length = ctx->n_pixels;
+  guint bytes1 = gimp_composite_pixel_bpp[ctx->pixelformat_A];
+  guint bytes2 = gimp_composite_pixel_bpp[ctx->pixelformat_B];
+  const guint has_alpha1 = HAS_ALPHA(bytes1);
+  const guint has_alpha2 = HAS_ALPHA(bytes2);
+  const guint alpha = (has_alpha1 || has_alpha2) ? MAX(bytes1, bytes2) - 1 : bytes1;
+  guint b, tmp;
+
+  if (has_alpha1 && has_alpha2) {
+    while (length--)
+      {
+        for (b = 0; b < alpha; b++)
+          dest[b] = src2[b];
+
+        dest[alpha] = INT_MULT(255 - src1[alpha], src2[alpha], tmp);
+
+        src1 += bytes1;
+        src2 += bytes2;
+        dest += bytes2;
+      }
+  } else if (has_alpha1) {
+    while (length--)
+      {
+        for (b = 0; b < alpha; b++)
+          dest[b] = src2[b];
+
+        dest[alpha] = src1[alpha];
+
+        src1 += bytes1;
+        src2 += bytes2;
+        dest += bytes2;
+      }
+  } else {
+    ctx->D = ctx->B;
+  }
+  ctx->combine = REPLACE_INTEN;
+}
+
+/**
  * gimp_composite_generic_init:
  *
  * Initialise the generic set of compositing functions.
diff -Naur gimp-2.8.14/app/composite/gimp-composite-generic.h gimp-2.8.14-new/app/composite/gimp-composite-generic.h
--- gimp-2.8.14/app/composite/gimp-composite-generic.h	2015-01-27 17:28:36.811833814 +0800
+++ gimp-2.8.14-new/app/composite/gimp-composite-generic.h	2015-01-27 17:48:39.684752638 +0800
@@ -43,4 +43,6 @@
 void gimp_composite_swap_any_any_any_generic (GimpCompositeContext *ctx);
 void gimp_composite_value_any_any_any_generic (GimpCompositeContext *ctx);
 void gimp_composite_behind_any_any_any_generic (GimpCompositeContext *ctx);
+void gimp_composite_src_in_any_any_any_generic (GimpCompositeContext *ctx);
+void gimp_composite_src_out_any_any_any_generic (GimpCompositeContext *ctx);
 #endif
diff -Naur gimp-2.8.14/app/composite/gimp-composite-generic-installer.c gimp-2.8.14-new/app/composite/gimp-composite-generic-installer.c
--- gimp-2.8.14/app/composite/gimp-composite-generic-installer.c	2015-01-27 17:28:36.807833815 +0800
+++ gimp-2.8.14-new/app/composite/gimp-composite-generic-installer.c	2015-01-27 17:48:39.683752638 +0800
@@ -1680,6 +1680,262 @@
  { GIMP_COMPOSITE_ANTI_ERASE, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_anti_erase_any_any_any_generic },
  { GIMP_COMPOSITE_ANTI_ERASE, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_anti_erase_any_any_any_generic },
  { GIMP_COMPOSITE_ANTI_ERASE, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_anti_erase_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_IN, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_in_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_SRC_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_V8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_VA8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGB8, gimp_composite_src_out_any_any_any_generic },
+ { GIMP_COMPOSITE_DST_OUT, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, GIMP_PIXELFORMAT_RGBA8, gimp_composite_src_out_any_any_any_generic },
  { GIMP_COMPOSITE_BLEND, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, gimp_composite_blend_any_any_any_generic },
  { GIMP_COMPOSITE_BLEND, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_VA8, gimp_composite_blend_any_any_any_generic },
  { GIMP_COMPOSITE_BLEND, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_V8, GIMP_PIXELFORMAT_RGB8, gimp_composite_blend_any_any_any_generic },
diff -Naur gimp-2.8.14/app/composite/gimp-composite.h gimp-2.8.14-new/app/composite/gimp-composite.h
--- gimp-2.8.14/app/composite/gimp-composite.h	2015-01-27 17:28:36.804833815 +0800
+++ gimp-2.8.14-new/app/composite/gimp-composite.h	2015-01-27 17:48:39.684752638 +0800
@@ -98,6 +98,10 @@
   GIMP_COMPOSITE_ERASE         = GIMP_ERASE_MODE,
   GIMP_COMPOSITE_REPLACE       = GIMP_REPLACE_MODE,
   GIMP_COMPOSITE_ANTI_ERASE    = GIMP_ANTI_ERASE_MODE,
+  GIMP_COMPOSITE_SRC_IN        = GIMP_SRC_IN_MODE,
+  GIMP_COMPOSITE_DST_IN        = GIMP_DST_IN_MODE,
+  GIMP_COMPOSITE_SRC_OUT       = GIMP_SRC_OUT_MODE,
+  GIMP_COMPOSITE_DST_OUT       = GIMP_DST_OUT_MODE,
   GIMP_COMPOSITE_BLEND,
   GIMP_COMPOSITE_SHADE,
   GIMP_COMPOSITE_SWAP,
diff -Naur gimp-2.8.14/app/config/gimpcoreconfig.c gimp-2.8.14-new/app/config/gimpcoreconfig.c
--- gimp-2.8.14/app/config/gimpcoreconfig.c	2015-01-27 17:28:36.882833809 +0800
+++ gimp-2.8.14-new/app/config/gimpcoreconfig.c	2015-01-27 17:48:39.685752638 +0800
@@ -47,7 +47,7 @@
 #define DEFAULT_TOOL_PRESET "Current Options"
 #define DEFAULT_FONT        "Sans"
 #define DEFAULT_COMMENT     "Created with GIMP"
-
+#define DEFAULT_MYPAINT_BRUSH "Standard"
 
 enum
 {
@@ -73,6 +73,8 @@
   PROP_TOOL_PRESET_PATH_WRITABLE,
   PROP_FONT_PATH,
   PROP_FONT_PATH_WRITABLE,
+  PROP_MYPAINT_BRUSH_PATH,
+  PROP_MYPAINT_BRUSH_PATH_WRITABLE,
   PROP_DEFAULT_BRUSH,
   PROP_DEFAULT_DYNAMICS,
   PROP_DEFAULT_PATTERN,
@@ -80,12 +82,14 @@
   PROP_DEFAULT_GRADIENT,
   PROP_DEFAULT_TOOL_PRESET,
   PROP_DEFAULT_FONT,
+  PROP_DEFAULT_MYPAINT_BRUSH,
   PROP_GLOBAL_BRUSH,
   PROP_GLOBAL_DYNAMICS,
   PROP_GLOBAL_PATTERN,
   PROP_GLOBAL_PALETTE,
   PROP_GLOBAL_GRADIENT,
   PROP_GLOBAL_FONT,
+  PROP_GLOBAL_MYPAINT_BRUSH,
   PROP_DEFAULT_IMAGE,
   PROP_DEFAULT_GRID,
   PROP_UNDO_LEVELS,
@@ -308,6 +312,24 @@
                                  GIMP_CONFIG_PATH_DIR_LIST, NULL,
                                  GIMP_PARAM_STATIC_STRINGS |
                                  GIMP_CONFIG_PARAM_IGNORE);
+
+  path = gimp_config_build_data_path ("mypaint-brushes");
+  GIMP_CONFIG_INSTALL_PROP_PATH (object_class, PROP_MYPAINT_BRUSH_PATH,
+                                 "mypaint-brush-path", MYPAINT_BRUSH_PATH_BLURB,
+                                 GIMP_CONFIG_PATH_DIR_LIST, path,
+                                 GIMP_PARAM_STATIC_STRINGS |
+                                 GIMP_CONFIG_PARAM_RESTART);
+  g_free (path);
+
+  path = gimp_config_build_writable_path ("mypaint-brushes");
+  GIMP_CONFIG_INSTALL_PROP_PATH (object_class, PROP_MYPAINT_BRUSH_PATH_WRITABLE,
+                                 "mypaint-brush-path-writable",
+                                 MYPAINT_BRUSH_PATH_WRITABLE_BLURB,
+                                 GIMP_CONFIG_PATH_DIR_LIST, path,
+                                 GIMP_PARAM_STATIC_STRINGS |
+                                 GIMP_CONFIG_PARAM_RESTART);
+  g_free (path);
+
   GIMP_CONFIG_INSTALL_PROP_STRING (object_class, PROP_DEFAULT_BRUSH,
                                    "default-brush", DEFAULT_BRUSH_BLURB,
                                    DEFAULT_BRUSH,
@@ -336,6 +358,10 @@
                                    "default-font", DEFAULT_FONT_BLURB,
                                    DEFAULT_FONT,
                                    GIMP_PARAM_STATIC_STRINGS);
+  GIMP_CONFIG_INSTALL_PROP_STRING (object_class, PROP_DEFAULT_MYPAINT_BRUSH,
+                                   "default-mypaint-brush", DEFAULT_MYPAINT_BRUSH_BLURB,
+                                   DEFAULT_MYPAINT_BRUSH,
+                                   GIMP_PARAM_STATIC_STRINGS);
   GIMP_CONFIG_INSTALL_PROP_BOOLEAN (object_class, PROP_GLOBAL_BRUSH,
                                     "global-brush", GLOBAL_BRUSH_BLURB,
                                     TRUE,
@@ -360,6 +386,10 @@
                                     "global-font", GLOBAL_FONT_BLURB,
                                     TRUE,
                                     GIMP_PARAM_STATIC_STRINGS);
+  GIMP_CONFIG_INSTALL_PROP_BOOLEAN (object_class, PROP_GLOBAL_MYPAINT_BRUSH,
+                                    "global-mypaint-brush", GLOBAL_MYPAINT_BRUSH_BLURB,
+                                    TRUE,
+                                    GIMP_PARAM_STATIC_STRINGS);
   GIMP_CONFIG_INSTALL_PROP_OBJECT (object_class, PROP_DEFAULT_IMAGE,
                                    "default-image", DEFAULT_IMAGE_BLURB,
                                    GIMP_TYPE_TEMPLATE,
@@ -621,6 +651,14 @@
       g_free (core_config->font_path_writable);
       core_config->font_path_writable = g_value_dup_string (value);
       break;
+    case PROP_MYPAINT_BRUSH_PATH:
+      g_free (core_config->mypaint_brush_path);
+      core_config->mypaint_brush_path = g_value_dup_string (value);
+      break;
+    case PROP_MYPAINT_BRUSH_PATH_WRITABLE:
+      g_free (core_config->mypaint_brush_path_writable);
+      core_config->mypaint_brush_path_writable = g_value_dup_string (value);
+      break;
     case PROP_DEFAULT_BRUSH:
       g_free (core_config->default_brush);
       core_config->default_brush = g_value_dup_string (value);
@@ -649,6 +687,10 @@
       g_free (core_config->default_font);
       core_config->default_font = g_value_dup_string (value);
       break;
+    case PROP_DEFAULT_MYPAINT_BRUSH:
+      g_free (core_config->default_mypaint_brush);
+      core_config->default_mypaint_brush = g_value_dup_string (value);
+      break;
     case PROP_GLOBAL_BRUSH:
       core_config->global_brush = g_value_get_boolean (value);
       break;
@@ -667,6 +709,9 @@
     case PROP_GLOBAL_FONT:
       core_config->global_font = g_value_get_boolean (value);
       break;
+    case PROP_GLOBAL_MYPAINT_BRUSH:
+      core_config->global_mypaint_brush = g_value_get_boolean (value);
+      break;
     case PROP_DEFAULT_IMAGE:
       if (g_value_get_object (value))
         gimp_config_sync (g_value_get_object (value) ,
@@ -807,6 +852,12 @@
     case PROP_FONT_PATH_WRITABLE:
       g_value_set_string (value, core_config->font_path_writable);
       break;
+    case PROP_MYPAINT_BRUSH_PATH:
+      g_value_set_string (value, core_config->mypaint_brush_path);
+      break;
+    case PROP_MYPAINT_BRUSH_PATH_WRITABLE:
+      g_value_set_string (value, core_config->mypaint_brush_path_writable);
+      break;
     case PROP_DEFAULT_BRUSH:
       g_value_set_string (value, core_config->default_brush);
       break;
@@ -828,6 +879,9 @@
     case PROP_DEFAULT_FONT:
       g_value_set_string (value, core_config->default_font);
       break;
+    case PROP_DEFAULT_MYPAINT_BRUSH:
+      g_value_set_string (value, core_config->default_mypaint_brush);
+      break;
     case PROP_GLOBAL_BRUSH:
       g_value_set_boolean (value, core_config->global_brush);
       break;
@@ -846,6 +900,8 @@
     case PROP_GLOBAL_FONT:
       g_value_set_boolean (value, core_config->global_font);
       break;
+    case PROP_GLOBAL_MYPAINT_BRUSH:
+      g_value_set_boolean (value, core_config->global_mypaint_brush);
     case PROP_DEFAULT_IMAGE:
       g_value_set_object (value, core_config->default_image);
       break;
diff -Naur gimp-2.8.14/app/config/gimpcoreconfig.h gimp-2.8.14-new/app/config/gimpcoreconfig.h
--- gimp-2.8.14/app/config/gimpcoreconfig.h	2015-01-27 17:28:36.882833809 +0800
+++ gimp-2.8.14-new/app/config/gimpcoreconfig.h	2015-01-27 17:48:39.685752638 +0800
@@ -60,6 +60,8 @@
   gchar                  *tool_preset_path_writable;
   gchar                  *font_path;
   gchar                  *font_path_writable;  /*  unused  */
+  gchar                  *mypaint_brush_path;
+  gchar                  *mypaint_brush_path_writable;
   gchar                  *default_brush;
   gchar                  *default_dynamics;
   gchar                  *default_pattern;
@@ -67,12 +69,14 @@
   gchar                  *default_tool_preset;
   gchar                  *default_gradient;
   gchar                  *default_font;
+  gchar                  *default_mypaint_brush;
   gboolean                global_brush;
   gboolean                global_dynamics;
   gboolean                global_pattern;
   gboolean                global_palette;
   gboolean                global_gradient;
   gboolean                global_font;
+  gboolean                global_mypaint_brush;
   GimpTemplate           *default_image;
   GimpGrid               *default_grid;
   gint                    levels_of_undo;
diff -Naur gimp-2.8.14/app/config/gimpguiconfig.c gimp-2.8.14-new/app/config/gimpguiconfig.c
--- gimp-2.8.14/app/config/gimpguiconfig.c	2015-01-27 17:28:36.881833810 +0800
+++ gimp-2.8.14-new/app/config/gimpguiconfig.c	2015-01-27 17:48:39.686752638 +0800
@@ -202,7 +202,7 @@
   GIMP_CONFIG_INSTALL_PROP_BOOLEAN (object_class, PROP_TOOLBOX_WILBER,
                                     "toolbox-wilber",
                                     TOOLBOX_WILBER_BLURB,
-                                    TRUE,
+                                    FALSE,
                                     GIMP_PARAM_STATIC_STRINGS);
   path = gimp_config_build_data_path ("themes");
   GIMP_CONFIG_INSTALL_PROP_PATH (object_class, PROP_THEME_PATH,
diff -Naur gimp-2.8.14/app/config/gimprc-blurbs.h gimp-2.8.14-new/app/config/gimprc-blurbs.h
--- gimp-2.8.14/app/config/gimprc-blurbs.h	2015-01-27 17:28:36.884833809 +0800
+++ gimp-2.8.14-new/app/config/gimprc-blurbs.h	2015-01-27 17:48:39.686752638 +0800
@@ -74,6 +74,9 @@
 #define DEFAULT_FONT_BLURB \
 "Specify a default font."
 
+#define DEFAULT_MYPAINT_BRUSH_BLURB \
+"Specify a default mypaint-compatible brush."
+
 #define DEFAULT_GRADIENT_BLURB \
 "Specify a default gradient."
 
@@ -159,6 +162,9 @@
 #define GLOBAL_FONT_BLURB \
 "When enabled, the selected font will be used for all tools."
 
+#define GLOBAL_MYPAINT_BRUSH_BLURB \
+"When enabled, the selected mypaint-compatible brush will be used for all tools."
+
 #define GLOBAL_GRADIENT_BLURB \
 N_("When enabled, the selected gradient will be used for all tools.")
 
@@ -176,6 +182,11 @@
 #define FONT_PATH_BLURB \
 "Where to look for fonts in addition to the system-wide installed fonts."
 
+#define MYPAINT_BRUSH_PATH_BLURB \
+"Where to look for mypaint-compatible-brush in addition to the system-wide installed fonts."
+
+#define MYPAINT_BRUSH_PATH_WRITABLE_BLURB ""
+
 #define HELP_BROWSER_BLURB \
 N_("Sets the browser used by the help system.")
 
diff -Naur gimp-2.8.14/app/core/core-enums.c gimp-2.8.14-new/app/core/core-enums.c
--- gimp-2.8.14/app/core/core-enums.c	2015-01-27 17:28:36.674833824 +0800
+++ gimp-2.8.14-new/app/core/core-enums.c	2015-01-27 17:48:39.687752638 +0800
@@ -778,6 +778,7 @@
     { GIMP_UNDO_GROUP_TEXT, "GIMP_UNDO_GROUP_TEXT", "group-text" },
     { GIMP_UNDO_GROUP_TRANSFORM, "GIMP_UNDO_GROUP_TRANSFORM", "group-transform" },
     { GIMP_UNDO_GROUP_PAINT, "GIMP_UNDO_GROUP_PAINT", "group-paint" },
+    { GIMP_UNDO_GROUP_MYPAINT, "GIMP_UNDO_GROUP_MYPAINT", "group-mypaint" },
     { GIMP_UNDO_GROUP_PARASITE_ATTACH, "GIMP_UNDO_GROUP_PARASITE_ATTACH", "group-parasite-attach" },
     { GIMP_UNDO_GROUP_PARASITE_REMOVE, "GIMP_UNDO_GROUP_PARASITE_REMOVE", "group-parasite-remove" },
     { GIMP_UNDO_GROUP_VECTORS_IMPORT, "GIMP_UNDO_GROUP_VECTORS_IMPORT", "group-vectors-import" },
@@ -820,6 +821,7 @@
     { GIMP_UNDO_FS_TO_LAYER, "GIMP_UNDO_FS_TO_LAYER", "fs-to-layer" },
     { GIMP_UNDO_TRANSFORM, "GIMP_UNDO_TRANSFORM", "transform" },
     { GIMP_UNDO_PAINT, "GIMP_UNDO_PAINT", "paint" },
+    { GIMP_UNDO_MYPAINT, "GIMP_UNDO_MYPAINT", "mypaint" },
     { GIMP_UNDO_INK, "GIMP_UNDO_INK", "ink" },
     { GIMP_UNDO_FOREGROUND_SELECT, "GIMP_UNDO_FOREGROUND_SELECT", "foreground-select" },
     { GIMP_UNDO_PARASITE_ATTACH, "GIMP_UNDO_PARASITE_ATTACH", "parasite-attach" },
@@ -864,6 +866,7 @@
     { GIMP_UNDO_GROUP_TEXT, NC_("undo-type", "Text"), NULL },
     { GIMP_UNDO_GROUP_TRANSFORM, NC_("undo-type", "Transform"), NULL },
     { GIMP_UNDO_GROUP_PAINT, NC_("undo-type", "Paint"), NULL },
+    { GIMP_UNDO_GROUP_MYPAINT, NC_("undo-type", "Mypaint"), NULL },
     { GIMP_UNDO_GROUP_PARASITE_ATTACH, NC_("undo-type", "Attach parasite"), NULL },
     { GIMP_UNDO_GROUP_PARASITE_REMOVE, NC_("undo-type", "Remove parasite"), NULL },
     { GIMP_UNDO_GROUP_VECTORS_IMPORT, NC_("undo-type", "Import paths"), NULL },
@@ -906,6 +909,7 @@
     { GIMP_UNDO_FS_TO_LAYER, NC_("undo-type", "Floating selection to layer"), NULL },
     { GIMP_UNDO_TRANSFORM, NC_("undo-type", "Transform"), NULL },
     { GIMP_UNDO_PAINT, NC_("undo-type", "Paint"), NULL },
+    { GIMP_UNDO_MYPAINT, NC_("undo-type", "Mypaint"), NULL },
     { GIMP_UNDO_INK, NC_("undo-type", "Ink"), NULL },
     { GIMP_UNDO_FOREGROUND_SELECT, NC_("undo-type", "Select foreground"), NULL },
     { GIMP_UNDO_PARASITE_ATTACH, NC_("undo-type", "Attach parasite"), NULL },
@@ -1284,6 +1288,7 @@
     { GIMP_DYNAMICS_OUTPUT_RATE, "GIMP_DYNAMICS_OUTPUT_RATE", "rate" },
     { GIMP_DYNAMICS_OUTPUT_FLOW, "GIMP_DYNAMICS_OUTPUT_FLOW", "flow" },
     { GIMP_DYNAMICS_OUTPUT_JITTER, "GIMP_DYNAMICS_OUTPUT_JITTER", "jitter" },
+    { GIMP_DYNAMICS_OUTPUT_BLENDING, "GIMP_DYNAMICS_OUTPUT_BLENDING", "blending" },
     { 0, NULL, NULL }
   };
 
@@ -1300,6 +1305,7 @@
     { GIMP_DYNAMICS_OUTPUT_RATE, NC_("dynamics-output-type", "Rate"), NULL },
     { GIMP_DYNAMICS_OUTPUT_FLOW, NC_("dynamics-output-type", "Flow"), NULL },
     { GIMP_DYNAMICS_OUTPUT_JITTER, NC_("dynamics-output-type", "Jitter"), NULL },
+    { GIMP_DYNAMICS_OUTPUT_BLENDING, NC_("dynamics-output-type", "Bleding"), NULL },
     { 0, NULL, NULL }
   };
 
diff -Naur gimp-2.8.14/app/core/core-enums.h gimp-2.8.14-new/app/core/core-enums.h
--- gimp-2.8.14/app/core/core-enums.h	2015-01-27 17:28:36.703833822 +0800
+++ gimp-2.8.14-new/app/core/core-enums.h	2015-01-27 17:48:39.688752638 +0800
@@ -376,6 +376,7 @@
   GIMP_UNDO_GROUP_TEXT,               /*< desc="Text"                        >*/
   GIMP_UNDO_GROUP_TRANSFORM,          /*< desc="Transform"                   >*/
   GIMP_UNDO_GROUP_PAINT,              /*< desc="Paint"                       >*/
+  GIMP_UNDO_GROUP_MYPAINT,            /*< desc="Mypaint"                     >*/
   GIMP_UNDO_GROUP_PARASITE_ATTACH,    /*< desc="Attach parasite"             >*/
   GIMP_UNDO_GROUP_PARASITE_REMOVE,    /*< desc="Remove parasite"             >*/
   GIMP_UNDO_GROUP_VECTORS_IMPORT,     /*< desc="Import paths"                >*/
@@ -423,6 +424,7 @@
   GIMP_UNDO_FS_TO_LAYER,              /*< desc="Floating selection to layer" >*/
   GIMP_UNDO_TRANSFORM,                /*< desc="Transform"                   >*/
   GIMP_UNDO_PAINT,                    /*< desc="Paint"                       >*/
+  GIMP_UNDO_MYPAINT,                  /*< desc="Mypaint"                     >*/
   GIMP_UNDO_INK,                      /*< desc="Ink"                         >*/
   GIMP_UNDO_FOREGROUND_SELECT,        /*< desc="Select foreground"           >*/
   GIMP_UNDO_PARASITE_ATTACH,          /*< desc="Attach parasite"             >*/
@@ -587,6 +589,7 @@
   GIMP_DYNAMICS_OUTPUT_RATE,         /*< desc="Rate"         >*/
   GIMP_DYNAMICS_OUTPUT_FLOW,         /*< desc="Flow"         >*/
   GIMP_DYNAMICS_OUTPUT_JITTER,       /*< desc="Jitter"       >*/
+  GIMP_DYNAMICS_OUTPUT_BLENDING,     /*< desc="Bleding"      >*/
 } GimpDynamicsOutputType;
 
 
@@ -614,11 +617,12 @@
   GIMP_CONTEXT_PROP_PALETTE     = 14,
   GIMP_CONTEXT_PROP_TOOL_PRESET = 15,
   GIMP_CONTEXT_PROP_FONT        = 16,
-  GIMP_CONTEXT_PROP_BUFFER      = 17,
-  GIMP_CONTEXT_PROP_IMAGEFILE   = 18,
-  GIMP_CONTEXT_PROP_TEMPLATE    = 19,
+  GIMP_CONTEXT_PROP_MYPAINT_BRUSH = 17,
+  GIMP_CONTEXT_PROP_BUFFER      = 18,
+  GIMP_CONTEXT_PROP_IMAGEFILE   = 19,
+  GIMP_CONTEXT_PROP_TEMPLATE    = 20,
 
-  GIMP_CONTEXT_LAST_PROP        = GIMP_CONTEXT_PROP_TEMPLATE
+  GIMP_CONTEXT_LAST_PROP        = GIMP_CONTEXT_PROP_MYPAINT_BRUSH
 } GimpContextPropType;
 
 
@@ -639,9 +643,11 @@
   GIMP_CONTEXT_PALETTE_MASK     = 1 << 14,
   GIMP_CONTEXT_TOOL_PRESET_MASK = 1 << 15,
   GIMP_CONTEXT_FONT_MASK        = 1 << 16,
-  GIMP_CONTEXT_BUFFER_MASK      = 1 << 17,
-  GIMP_CONTEXT_IMAGEFILE_MASK   = 1 << 18,
-  GIMP_CONTEXT_TEMPLATE_MASK    = 1 << 19,
+  GIMP_CONTEXT_MYPAINT_BRUSH_MASK = 1 << 17,
+  GIMP_CONTEXT_BUFFER_MASK      = 1 << 18,
+  GIMP_CONTEXT_IMAGEFILE_MASK   = 1 << 19,
+  GIMP_CONTEXT_TEMPLATE_MASK    = 1 << 20,
+  GIMP_CONTEXT_MYPAINT_MODE_MASK = 1<<21,
 
   /*  aliases  */
   GIMP_CONTEXT_PAINT_PROPS_MASK = (GIMP_CONTEXT_FOREGROUND_MASK |
@@ -651,7 +657,8 @@
                                    GIMP_CONTEXT_BRUSH_MASK      |
                                    GIMP_CONTEXT_DYNAMICS_MASK   |
                                    GIMP_CONTEXT_PATTERN_MASK    |
-                                   GIMP_CONTEXT_GRADIENT_MASK),
+                                   GIMP_CONTEXT_GRADIENT_MASK   |
+                                   GIMP_CONTEXT_MYPAINT_BRUSH_MASK),
   GIMP_CONTEXT_ALL_PROPS_MASK   = (GIMP_CONTEXT_IMAGE_MASK      |
                                    GIMP_CONTEXT_DISPLAY_MASK    |
                                    GIMP_CONTEXT_TOOL_MASK       |
@@ -661,7 +668,8 @@
                                    GIMP_CONTEXT_BUFFER_MASK     |
                                    GIMP_CONTEXT_IMAGEFILE_MASK  |
                                    GIMP_CONTEXT_TEMPLATE_MASK   |
-                                   GIMP_CONTEXT_PAINT_PROPS_MASK)
+                                   GIMP_CONTEXT_PAINT_PROPS_MASK|
+                                   GIMP_CONTEXT_MYPAINT_BRUSH_MASK)
 } GimpContextPropMask;
 
 
diff -Naur gimp-2.8.14/app/core/core-types.h gimp-2.8.14-new/app/core/core-types.h
--- gimp-2.8.14/app/core/core-types.h	2015-01-27 17:28:36.677833823 +0800
+++ gimp-2.8.14-new/app/core/core-types.h	2015-01-27 17:48:39.688752638 +0800
@@ -93,6 +93,7 @@
 
 typedef struct _GimpPaintInfo       GimpPaintInfo;
 typedef struct _GimpToolInfo        GimpToolInfo;
+typedef struct _GimpMypaintInfo     GimpMypaintInfo;
 
 
 /*  data objects  */
@@ -113,6 +114,7 @@
 typedef struct _GimpPatternClipboard GimpPatternClipboard;
 typedef struct _GimpToolPreset       GimpToolPreset;
 typedef struct _GimpTagCache         GimpTagCache;
+typedef struct _GimpMypaintBrush     GimpMypaintBrush;
 
 
 /*  drawable objects  */
diff -Naur gimp-2.8.14/app/core/gimp.c gimp-2.8.14-new/app/core/gimp.c
--- gimp-2.8.14/app/core/gimp.c	2015-01-27 17:28:36.642833826 +0800
+++ gimp-2.8.14-new/app/core/gimp.c	2015-01-27 17:48:39.689752638 +0800
@@ -54,6 +54,8 @@
 #include "gimpbrushclipboard.h"
 #include "gimpbrushgenerated-load.h"
 #include "gimpbrushpipe-load.h"
+#include "gimpmypaintbrush.h"
+#include "gimpmypaintbrush-load.h"
 #include "gimpbuffer.h"
 #include "gimpcontext.h"
 #include "gimpdatafactory.h"
@@ -585,6 +587,11 @@
   {
     { gimp_tool_preset_load,     GIMP_TOOL_PRESET_FILE_EXTENSION,     TRUE  }
   };
+  
+  static const GimpDataFactoryLoaderEntry mypaint_brush_loader_entries[] =
+  {
+    {gimp_mypaint_brush_load,    GIMP_MYPAINT_BRUSH_FILE_EXTENSION,   TRUE },
+  };
 
   GimpData *clipboard_brush;
   GimpData *clipboard_pattern;
@@ -662,6 +669,17 @@
   gimp_object_set_static_name (GIMP_OBJECT (gimp->tool_preset_factory),
                                "tool preset factory");
 
+  gimp->mypaint_brush_factory =
+    gimp_data_factory_new (gimp,
+                           GIMP_TYPE_MYPAINT_BRUSH,
+                           "mypaint-brush-path", "mypaint-brush-path-writable",
+                           mypaint_brush_loader_entries,
+                           G_N_ELEMENTS (mypaint_brush_loader_entries),
+                           gimp_mypaint_brush_new,
+                           NULL);
+  gimp_object_set_static_name (GIMP_OBJECT (gimp->mypaint_brush_factory),
+                               "mypaint-brush");
+
   gimp->tag_cache = gimp_tag_cache_new ();
 
   gimp_paint_init (gimp);
@@ -733,6 +751,7 @@
   gimp_data_factory_data_save (gimp->gradient_factory);
   gimp_data_factory_data_save (gimp->palette_factory);
   gimp_data_factory_data_save (gimp->tool_preset_factory);
+  gimp_data_factory_data_save (gimp->mypaint_brush_factory);
 
   gimp_fonts_reset (gimp);
 
@@ -952,6 +971,11 @@
   gimp_data_factory_data_init (gimp->brush_factory, gimp->user_context,
                                gimp->no_data);
 
+  /*  initialize the list of fonts  */
+  status_callback (NULL, _("Mypaint Brushes"), 0.15);
+  gimp_data_factory_data_init (gimp->mypaint_brush_factory, gimp->user_context,
+                               gimp->no_data);
+
   /*  initialize the list of gimp dynamics   */
   status_callback (NULL, _("Dynamics"), 0.2);
   gimp_data_factory_data_init (gimp->dynamics_factory, gimp->user_context,
diff -Naur gimp-2.8.14/app/core/gimpcontext.c gimp-2.8.14-new/app/core/gimpcontext.c
--- gimp-2.8.14/app/core/gimpcontext.c	2015-01-27 17:28:36.632833826 +0800
+++ gimp-2.8.14-new/app/core/gimpcontext.c	2015-01-27 17:48:39.691752638 +0800
@@ -34,6 +34,7 @@
 #include "gimp.h"
 #include "gimp-utils.h"
 #include "gimpbrush.h"
+#include "gimpmypaintbrush.h"
 #include "gimpbuffer.h"
 #include "gimpcontainer.h"
 #include "gimpcontext.h"
@@ -227,6 +228,17 @@
 static void gimp_context_real_set_font       (GimpContext      *context,
                                               GimpFont         *font);
 
+/*  mypaint compatible brush  */
+static void gimp_context_mypaint_brush_dirty(GimpMypaintBrush *brush,
+                                              GimpContext      *context);
+static void gimp_context_mypaint_brush_removed (GimpContainer    *brush_list,
+                                              GimpMypaintBrush *brush,
+                                              GimpContext      *context);
+static void gimp_context_mypaint_brush_list_thaw (GimpContainer    *container,
+                                              GimpContext      *context);
+static void gimp_context_real_set_mypaint_brush (GimpContext      *context,
+                                              GimpMypaintBrush *brush);
+
 /*  buffer  */
 static void gimp_context_buffer_dirty        (GimpBuffer       *buffer,
                                               GimpContext      *context);
@@ -297,6 +309,7 @@
   PALETTE_CHANGED,
   TOOL_PRESET_CHANGED,
   FONT_CHANGED,
+  MYPAINT_BRUSH_CHANGED,
   BUFFER_CHANGED,
   IMAGEFILE_CHANGED,
   TEMPLATE_CHANGED,
@@ -322,6 +335,7 @@
   "palette",
   "tool-preset",
   "font",
+  "mypaint-brush",
   "buffer",
   "imagefile",
   "template"
@@ -348,6 +362,7 @@
   0,
   0,
   0,
+  0,
   0
 };
 
@@ -522,6 +537,16 @@
                   G_TYPE_NONE, 1,
                   GIMP_TYPE_FONT);
 
+  gimp_context_signals[MYPAINT_BRUSH_CHANGED] =
+    g_signal_new ("mypaint-brush-changed",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GimpContextClass, mypaint_brush_changed),
+                  NULL, NULL,
+                  gimp_marshal_VOID__OBJECT,
+                  G_TYPE_NONE, 1,
+                  GIMP_TYPE_MYPAINT_BRUSH);
+
   gimp_context_signals[BUFFER_CHANGED] =
     g_signal_new ("buffer-changed",
                   G_TYPE_FROM_CLASS (klass),
@@ -575,6 +600,7 @@
   klass->palette_changed         = NULL;
   klass->tool_preset_changed     = NULL;
   klass->font_changed            = NULL;
+  klass->mypaint_brush_changed   = NULL;
   klass->buffer_changed          = NULL;
   klass->imagefile_changed       = NULL;
   klass->template_changed        = NULL;
@@ -589,6 +615,7 @@
   gimp_context_prop_types[GIMP_CONTEXT_PROP_PALETTE]     = GIMP_TYPE_PALETTE;
   gimp_context_prop_types[GIMP_CONTEXT_PROP_TOOL_PRESET] = GIMP_TYPE_TOOL_PRESET;
   gimp_context_prop_types[GIMP_CONTEXT_PROP_FONT]        = GIMP_TYPE_FONT;
+  gimp_context_prop_types[GIMP_CONTEXT_PROP_MYPAINT_BRUSH] = GIMP_TYPE_MYPAINT_BRUSH;
   gimp_context_prop_types[GIMP_CONTEXT_PROP_BUFFER]      = GIMP_TYPE_BUFFER;
   gimp_context_prop_types[GIMP_CONTEXT_PROP_IMAGEFILE]   = GIMP_TYPE_IMAGEFILE;
   gimp_context_prop_types[GIMP_CONTEXT_PROP_TEMPLATE]    = GIMP_TYPE_TEMPLATE;
@@ -691,6 +718,12 @@
                                    GIMP_TYPE_FONT,
                                    GIMP_PARAM_STATIC_STRINGS);
 
+  GIMP_CONFIG_INSTALL_PROP_OBJECT (object_class, GIMP_CONTEXT_PROP_MYPAINT_BRUSH,
+                                   gimp_context_prop_names[GIMP_CONTEXT_PROP_MYPAINT_BRUSH],
+                                   NULL,
+                                   GIMP_TYPE_MYPAINT_BRUSH,
+                                   GIMP_PARAM_STATIC_STRINGS);
+
   g_object_class_install_property (object_class, GIMP_CONTEXT_PROP_BUFFER,
                                    g_param_spec_object (gimp_context_prop_names[GIMP_CONTEXT_PROP_BUFFER],
                                                         NULL, NULL,
@@ -750,6 +783,9 @@
   context->font            = NULL;
   context->font_name       = NULL;
 
+  context->mypaint_brush   = NULL;
+  context->mypaint_brush_name = NULL;
+
   context->buffer          = NULL;
   context->buffer_name     = NULL;
 
@@ -859,6 +895,14 @@
                            G_CALLBACK (gimp_context_font_list_thaw),
                            object, 0);
 
+  container = gimp_data_factory_get_container (gimp->mypaint_brush_factory);
+  g_signal_connect_object (container, "remove",
+                           G_CALLBACK (gimp_context_mypaint_brush_removed),
+                           object, 0);
+  g_signal_connect_object (container, "thaw",
+                           G_CALLBACK (gimp_context_mypaint_brush_list_thaw),
+                           object, 0);
+
   g_signal_connect_object (gimp->named_buffers, "remove",
                            G_CALLBACK (gimp_context_buffer_removed),
                            object, 0);
@@ -947,6 +991,12 @@
       context->font = NULL;
     }
 
+  if (context->mypaint_brush)
+    {
+      g_object_unref (context->mypaint_brush);
+      context->mypaint_brush = NULL;
+    }
+
   if (context->buffer)
     {
       g_object_unref (context->buffer);
@@ -1031,6 +1081,12 @@
       context->font_name = NULL;
     }
 
+  if (context->mypaint_brush_name)
+    {
+      g_free (context->mypaint_brush_name);
+      context->mypaint_brush_name = NULL;
+    }
+
   if (context->buffer_name)
     {
       g_free (context->buffer_name);
@@ -1110,6 +1166,9 @@
     case GIMP_CONTEXT_PROP_FONT:
       gimp_context_set_font (context, g_value_get_object (value));
       break;
+    case GIMP_CONTEXT_PROP_MYPAINT_BRUSH:
+      gimp_context_set_mypaint_brush (context, g_value_get_object (value));
+      break;
     case GIMP_CONTEXT_PROP_BUFFER:
       gimp_context_set_buffer (context, g_value_get_object (value));
       break;
@@ -1193,6 +1252,9 @@
     case GIMP_CONTEXT_PROP_FONT:
       g_value_set_object (value, gimp_context_get_font (context));
       break;
+    case GIMP_CONTEXT_PROP_MYPAINT_BRUSH:
+      g_value_set_object (value, gimp_context_get_mypaint_brush (context));
+      break;
     case GIMP_CONTEXT_PROP_BUFFER:
       g_value_set_object (value, gimp_context_get_buffer (context));
       break;
@@ -1223,6 +1285,7 @@
   memsize += gimp_string_get_memsize (context->palette_name);
   memsize += gimp_string_get_memsize (context->tool_preset_name);
   memsize += gimp_string_get_memsize (context->font_name);
+  memsize += gimp_string_get_memsize (context->mypaint_brush_name);
   memsize += gimp_string_get_memsize (context->buffer_name);
   memsize += gimp_string_get_memsize (context->imagefile_name);
   memsize += gimp_string_get_memsize (context->template_name);
@@ -1264,6 +1327,7 @@
     case GIMP_CONTEXT_PROP_PALETTE:
     case GIMP_CONTEXT_PROP_TOOL_PRESET:
     case GIMP_CONTEXT_PROP_FONT:
+    case GIMP_CONTEXT_PROP_MYPAINT_BRUSH:
       serialize_obj = g_value_get_object (value);
       break;
 
@@ -1356,6 +1420,12 @@
       name_loc  = &context->font_name;
       break;
 
+    case GIMP_CONTEXT_PROP_MYPAINT_BRUSH:
+      container = gimp_data_factory_get_container (context->gimp->mypaint_brush_factory);
+      current   = (GimpObject *) context->mypaint_brush;
+      name_loc  = &context->mypaint_brush_name;
+      break;
+
     default:
       return FALSE;
     }
@@ -1682,6 +1752,14 @@
       dest_name_loc   = &dest->font_name;
       break;
 
+    case GIMP_CONTEXT_PROP_MYPAINT_BRUSH:
+      gimp_context_real_set_mypaint_brush (dest, src->mypaint_brush);
+      object          = src->mypaint_brush;
+      standard_object = gimp_mypaint_brush_get_standard (src);
+      src_name        = src->mypaint_brush_name;
+      dest_name_loc   = &dest->mypaint_brush_name;
+      break;
+
     case GIMP_CONTEXT_PROP_BUFFER:
       gimp_context_real_set_buffer (dest, src->buffer);
       break;
@@ -3318,6 +3396,127 @@
 }
 
 
+/*****************************************************************************/
+/*  mypaint compatible brush  ************************************************/
+
+GimpMypaintBrush *
+gimp_context_get_mypaint_brush (GimpContext *context)
+{
+  g_return_val_if_fail (GIMP_IS_CONTEXT (context), NULL);
+
+  return context->mypaint_brush;
+}
+
+void
+gimp_context_set_mypaint_brush (GimpContext *context,
+                        GimpMypaintBrush   *mypaint_brush)
+{
+  g_return_if_fail (GIMP_IS_CONTEXT (context));
+  g_return_if_fail (! mypaint_brush || GIMP_IS_MYPAINT_BRUSH (mypaint_brush));
+  context_find_defined (context, GIMP_CONTEXT_PROP_MYPAINT_BRUSH);
+
+  gimp_context_real_set_mypaint_brush (context, mypaint_brush);
+}
+
+void
+gimp_context_mypaint_brush_changed (GimpContext *context)
+{
+  g_return_if_fail (GIMP_IS_CONTEXT (context));
+
+  g_signal_emit (context,
+                 gimp_context_signals[MYPAINT_BRUSH_CHANGED], 0,
+                 context->mypaint_brush);
+}
+
+/*  the active brush was modified  */
+static void
+gimp_context_mypaint_brush_dirty (GimpMypaintBrush   *mypaint_brush,
+                          GimpContext *context)
+{
+  g_free (context->mypaint_brush_name);
+  context->mypaint_brush_name = g_strdup (gimp_object_get_name (mypaint_brush));
+}
+
+/*  the global brush list is there again after refresh  */
+static void
+gimp_context_mypaint_brush_list_thaw (GimpContainer *container,
+                                      GimpContext   *context)
+{
+  GimpMypaintBrush *mypaint_brush;
+
+  if (! context->mypaint_brush_name)
+    context->mypaint_brush_name = g_strdup (context->gimp->config->default_mypaint_brush);
+
+  mypaint_brush = gimp_context_find_object (context, container,
+                                            context->mypaint_brush_name,
+                                            gimp_mypaint_brush_get_standard (context));
+
+  gimp_context_real_set_mypaint_brush (context, mypaint_brush);
+}
+
+/*  the active brush disappeared  */
+static void
+gimp_context_mypaint_brush_removed (GimpContainer *container,
+                                    GimpMypaintBrush     *mypaint_brush,
+                                    GimpContext   *context)
+{
+  if (mypaint_brush == context->mypaint_brush)
+    {
+      context->mypaint_brush = NULL;
+
+      g_signal_handlers_disconnect_by_func (mypaint_brush,
+                                            gimp_context_mypaint_brush_dirty,
+                                            context);
+      g_object_unref (mypaint_brush);
+
+      if (! gimp_container_frozen (container))
+        gimp_context_mypaint_brush_list_thaw (container, context);
+    }
+}
+
+static void
+gimp_context_real_set_mypaint_brush (GimpContext *context,
+                                     GimpMypaintBrush   *mypaint_brush)
+{
+  if (context->mypaint_brush == mypaint_brush)
+    return;
+
+  if (context->mypaint_brush_name &&
+      mypaint_brush != GIMP_MYPAINT_BRUSH (gimp_mypaint_brush_get_standard (context)))
+    {
+      g_free (context->mypaint_brush_name);
+      context->mypaint_brush_name = NULL;
+    }
+
+  /*  disconnect from the old brush's signals  */
+  if (context->mypaint_brush)
+    {
+      g_signal_handlers_disconnect_by_func (context->mypaint_brush,
+                                            gimp_context_mypaint_brush_dirty,
+                                            context);
+      g_object_unref (context->mypaint_brush);
+    }
+
+  context->mypaint_brush = mypaint_brush;
+
+  if (mypaint_brush)
+    {
+      g_object_ref (mypaint_brush);
+
+      g_signal_connect_object (mypaint_brush, "name-changed",
+                               G_CALLBACK (gimp_context_mypaint_brush_dirty),
+                               context,
+                               0);
+
+      if (mypaint_brush != GIMP_MYPAINT_BRUSH (gimp_mypaint_brush_get_standard (context)))
+        context->mypaint_brush_name = g_strdup (gimp_object_get_name (mypaint_brush));
+    }
+
+  g_object_notify (G_OBJECT (context), "mypaint-brush");
+  gimp_context_mypaint_brush_changed (context);
+}
+
+
 /*****************************************************************************/
 /*  buffer  ******************************************************************/
 
diff -Naur gimp-2.8.14/app/core/gimpcontext.h gimp-2.8.14-new/app/core/gimpcontext.h
--- gimp-2.8.14/app/core/gimpcontext.h	2015-01-27 17:28:36.597833829 +0800
+++ gimp-2.8.14-new/app/core/gimpcontext.h	2015-01-27 17:48:39.692752638 +0800
@@ -91,13 +91,20 @@
   GimpFont             *font;
   gchar                *font_name;
 
+  GimpMypaintBrush     *mypaint_brush;
+  gchar                *mypaint_brush_name;
+
   GimpBuffer           *buffer;
   gchar                *buffer_name;
 
   GimpImagefile        *imagefile;
   gchar                *imagefile_name;
 
+#ifdef __cplusplus
+  GimpTemplate         *template_;
+#else
   GimpTemplate         *template;
+#endif
   gchar                *template_name;
 };
 
@@ -137,12 +144,14 @@
                                GimpToolPreset       *tool_preset);
   void (* font_changed)       (GimpContext          *context,
                                GimpFont             *font);
+  void (* mypaint_brush_changed)(GimpContext          *context,
+                               GimpMypaintBrush     *brush);
   void (* buffer_changed)     (GimpContext          *context,
                                GimpBuffer           *buffer);
   void (* imagefile_changed)  (GimpContext          *context,
                                GimpImagefile        *imagefile);
   void (* template_changed)   (GimpContext          *context,
-                               GimpTemplate         *template);
+                               GimpTemplate         *template_);
 };
 
 
@@ -150,7 +159,7 @@
 
 GimpContext * gimp_context_new               (Gimp                *gimp,
                                               const gchar         *name,
-                                              GimpContext         *template);
+                                              GimpContext         *template_);
 
 GimpContext * gimp_context_get_parent        (const GimpContext   *context);
 void          gimp_context_set_parent        (GimpContext         *context,
@@ -322,6 +331,13 @@
 void             gimp_context_font_changed        (GimpContext     *context);
 
 
+/*  mypaint compatible brush  */
+GimpMypaintBrush* gimp_context_get_mypaint_brush  (GimpContext     *context);
+void             gimp_context_set_mypaint_brush   (GimpContext     *context,
+                                                   GimpMypaintBrush*brush);
+void             gimp_context_mypaint_brush_changed (GimpContext     *context);
+
+
 /*  buffer  */
 GimpBuffer     * gimp_context_get_buffer          (GimpContext     *context);
 void             gimp_context_set_buffer          (GimpContext     *context,
@@ -339,7 +355,7 @@
 /*  template  */
 GimpTemplate   * gimp_context_get_template        (GimpContext     *context);
 void             gimp_context_set_template        (GimpContext     *context,
-                                                   GimpTemplate    *template);
+                                                   GimpTemplate    *template_);
 void             gimp_context_template_changed    (GimpContext     *context);
 
 
diff -Naur gimp-2.8.14/app/core/gimpcurve.c gimp-2.8.14-new/app/core/gimpcurve.c
--- gimp-2.8.14/app/core/gimpcurve.c	2015-01-27 17:28:36.647833825 +0800
+++ gimp-2.8.14-new/app/core/gimpcurve.c	2015-01-27 17:48:39.692752638 +0800
@@ -154,7 +154,7 @@
   GIMP_CONFIG_INSTALL_PROP_INT (object_class, PROP_N_POINTS,
                                 "n-points",
                                 "The number of points",
-                                17, 17, 17, 0);
+                                1, 17, 17, 0);
 
   array_spec = g_param_spec_double ("point", NULL, NULL,
                                     -1.0, 1.0, 0.0, GIMP_PARAM_READWRITE);
diff -Naur gimp-2.8.14/app/core/gimpdatafactory.c gimp-2.8.14-new/app/core/gimpdatafactory.c
--- gimp-2.8.14/app/core/gimpdatafactory.c	2015-01-27 17:28:36.604833828 +0800
+++ gimp-2.8.14-new/app/core/gimpdatafactory.c	2015-01-27 17:48:39.692752638 +0800
@@ -319,7 +319,7 @@
 {
   gchar *path;
   gchar *writable_path;
-
+  
   g_object_get (factory->priv->gimp->config,
                 factory->priv->path_property_name,     &path,
                 factory->priv->writable_property_name, &writable_path,
diff -Naur gimp-2.8.14/app/core/gimpdrawable.c gimp-2.8.14-new/app/core/gimpdrawable.c
--- gimp-2.8.14/app/core/gimpdrawable.c	2015-01-27 17:28:36.655833825 +0800
+++ gimp-2.8.14-new/app/core/gimpdrawable.c	2015-01-27 17:48:39.693752638 +0800
@@ -938,7 +938,7 @@
 
               src_tile = tile_manager_get_tile (tiles, j, i, FALSE, FALSE);
 
-              if (tile_is_valid (src_tile))
+              if (src_tile && tile_is_valid (src_tile))
                 {
                   /* swap tiles, not pixels! */
 
diff -Naur gimp-2.8.14/app/core/gimpdrawable.h gimp-2.8.14-new/app/core/gimpdrawable.h
--- gimp-2.8.14/app/core/gimpdrawable.h	2015-01-27 17:28:36.601833828 +0800
+++ gimp-2.8.14-new/app/core/gimpdrawable.h	2015-01-27 17:48:39.694752638 +0800
@@ -37,7 +37,11 @@
 {
   GimpItem             parent_instance;
 
+#ifdef __cplusplus
+  GimpDrawablePrivate *private_;
+#else
   GimpDrawablePrivate *private;
+#endif
 };
 
 struct _GimpDrawableClass
diff -Naur gimp-2.8.14/app/core/gimpdynamics.c gimp-2.8.14-new/app/core/gimpdynamics.c
--- gimp-2.8.14/app/core/gimpdynamics.c	2015-01-27 17:28:36.618833827 +0800
+++ gimp-2.8.14-new/app/core/gimpdynamics.c	2015-01-27 17:48:39.694752638 +0800
@@ -51,7 +51,8 @@
   PROP_SPACING_OUTPUT,
   PROP_RATE_OUTPUT,
   PROP_FLOW_OUTPUT,
-  PROP_JITTER_OUTPUT
+  PROP_JITTER_OUTPUT,
+  PROP_BLENDING_OUTPUT
 };
 
 
@@ -70,6 +71,7 @@
   GimpDynamicsOutput *angle_output;
   GimpDynamicsOutput *jitter_output;
   GimpDynamicsOutput *spacing_output;
+  GimpDynamicsOutput *blending_output;
 };
 
 #define GET_PRIVATE(output) \
@@ -188,6 +190,10 @@
                                    GIMP_TYPE_DYNAMICS_OUTPUT,
                                    GIMP_CONFIG_PARAM_AGGREGATE);
 
+  GIMP_CONFIG_INSTALL_PROP_OBJECT (object_class, PROP_BLENDING_OUTPUT,
+                                   "blending-output", NULL,
+                                   GIMP_TYPE_DYNAMICS_OUTPUT,
+                                   GIMP_CONFIG_PARAM_AGGREGATE);
   g_type_class_add_private (klass, sizeof (GimpDynamicsPrivate));
 }
 
@@ -250,6 +256,10 @@
     gimp_dynamics_create_output (dynamics,
                                  "spacing-output",
                                  GIMP_DYNAMICS_OUTPUT_SPACING);
+  private->blending_output = 
+    gimp_dynamics_create_output (dynamics,
+                                 "blending-output",
+                                 GIMP_DYNAMICS_OUTPUT_BLENDING);
 }
 
 static void
@@ -268,6 +278,7 @@
   g_object_unref (private->angle_output);
   g_object_unref (private->jitter_output);
   g_object_unref (private->spacing_output);
+  g_object_unref (private->blending_output);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -343,6 +354,11 @@
       dest_output = private->spacing_output;
       break;
 
+    case PROP_BLENDING_OUTPUT:
+      src_output  = g_value_get_object (value);
+      dest_output = private->blending_output;
+      break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -414,6 +430,10 @@
       g_value_set_object (value, private->spacing_output);
       break;
 
+    case PROP_BLENDING_OUTPUT:
+      g_value_set_object (value, private->blending_output);
+      break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -547,6 +567,10 @@
       return private->spacing_output;
       break;
 
+    case GIMP_DYNAMICS_OUTPUT_BLENDING:
+      return private->blending_output;
+      break;
+
     default:
       return NULL;
       break;
diff -Naur gimp-2.8.14/app/core/gimp.h gimp-2.8.14-new/app/core/gimp.h
--- gimp-2.8.14/app/core/gimp.h	2015-01-27 17:28:36.682833823 +0800
+++ gimp-2.8.14-new/app/core/gimp.h	2015-01-27 17:48:39.689752638 +0800
@@ -67,6 +67,7 @@
 
   GimpContainer          *paint_info_list;
   GimpPaintInfo          *standard_paint_info;
+  GimpMypaintInfo        *standard_mypaint_info;
 
   GimpModuleDB           *module_db;
   gboolean                write_modulerc;
@@ -96,6 +97,7 @@
   GimpDataFactory        *gradient_factory;
   GimpDataFactory        *palette_factory;
   GimpDataFactory        *tool_preset_factory;
+  GimpDataFactory        *mypaint_brush_factory;
 
   GimpTagCache           *tag_cache;
 
diff -Naur gimp-2.8.14/app/core/gimplayer.c gimp-2.8.14-new/app/core/gimplayer.c
--- gimp-2.8.14/app/core/gimplayer.c	2015-01-27 17:28:36.693833822 +0800
+++ gimp-2.8.14-new/app/core/gimplayer.c	2015-01-27 17:48:39.695752638 +0800
@@ -1119,6 +1119,10 @@
         case GIMP_ERASE_MODE:
         case GIMP_REPLACE_MODE:
         case GIMP_ANTI_ERASE_MODE:
+        case GIMP_SRC_IN_MODE:
+        case GIMP_DST_IN_MODE:
+        case GIMP_SRC_OUT_MODE:
+        case GIMP_DST_OUT_MODE:
           gegl_node_set (mode_node,
                          "operation",  "gimp:point-layer-mode",
                          "blend-mode", layer->mode,
diff -Naur gimp-2.8.14/app/core/gimpmypaintbrush.cpp gimp-2.8.14-new/app/core/gimpmypaintbrush.cpp
--- gimp-2.8.14/app/core/gimpmypaintbrush.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/gimpmypaintbrush.cpp	2015-01-27 17:48:39.698752637 +0800
@@ -0,0 +1,638 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+extern "C" {
+#include "config.h"
+
+#include <glib-object.h>
+#include <cairo.h>
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpmath/gimpmath.h"
+
+#include "core-types.h"
+
+#include "base/temp-buf.h"
+
+#include "gimpbezierdesc.h"
+#include "gimpmypaintbrush.h"
+#include "gimpmypaintbrush-private.hpp"
+#include "gimpmypaintbrush-load.h"
+#include "gimpmypaintbrush-save.h"
+#include "gimpmarshal.h"
+#include "gimptagged.h"
+
+#include "gimp-intl.h"
+
+
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  PROP_0,
+};
+
+
+static void          gimp_mypaint_brush_tagged_iface_init     (GimpTaggedInterface  *iface);
+
+static void          gimp_mypaint_brush_finalize              (GObject              *object);
+static void          gimp_mypaint_brush_set_property          (GObject              *object,
+                                                       guint                 property_id,
+                                                       const GValue         *value,
+                                                       GParamSpec           *pspec);
+static void          gimp_mypaint_brush_get_property          (GObject              *object,
+                                                       guint                 property_id,
+                                                       GValue               *value,
+                                                       GParamSpec           *pspec);
+
+static gint64        gimp_mypaint_brush_get_memsize           (GimpObject           *object,
+                                                       gint64               *gui_size);
+
+static gboolean      gimp_mypaint_brush_get_size              (GimpViewable         *viewable,
+                                                       gint                 *width,
+                                                       gint                 *height);
+static TempBuf     * gimp_mypaint_brush_get_new_preview       (GimpViewable         *viewable,
+                                                       GimpContext          *context,
+                                                       gint                  width,
+                                                       gint                  height);
+static gchar       * gimp_mypaint_brush_get_description       (GimpViewable         *viewable,
+                                                       gchar               **tooltip);
+
+static void          gimp_mypaint_brush_dirty                 (GimpData             *data);
+static const gchar * gimp_mypaint_brush_get_extension         (GimpData             *data);
+
+static void          gimp_mypaint_brush_real_begin_use        (GimpMypaintBrush            *mypaint_brush);
+static void          gimp_mypaint_brush_real_end_use          (GimpMypaintBrush            *mypaint_brush);
+static GimpMypaintBrush   * gimp_mypaint_brush_real_select_mypaint_brush     (GimpMypaintBrush            *mypaint_brush,
+                                                       const GimpCoords     *last_coords,
+                                                       const GimpCoords     *current_coords);
+static gboolean      gimp_mypaint_brush_real_want_null_motion (GimpMypaintBrush            *mypaint_brush,
+                                                       const GimpCoords     *last_coords,
+                                                       const GimpCoords     *current_coords);
+
+static gchar       * gimp_mypaint_brush_get_checksum          (GimpTagged           *tagged);
+
+
+G_DEFINE_TYPE_WITH_CODE (GimpMypaintBrush, gimp_mypaint_brush, GIMP_TYPE_DATA,
+                         G_IMPLEMENT_INTERFACE (GIMP_TYPE_TAGGED,
+                                                gimp_mypaint_brush_tagged_iface_init))
+
+#define parent_class gimp_mypaint_brush_parent_class
+
+//static guint mypaint_brush_signals[LAST_SIGNAL] = { 0 };
+
+
+static void
+gimp_mypaint_brush_class_init (GimpMypaintBrushClass *klass)
+{
+  GObjectClass        *object_class      = G_OBJECT_CLASS (klass);
+  GimpObjectClass   *gimp_object_class = GIMP_OBJECT_CLASS (klass);
+  GimpViewableClass *viewable_class    = GIMP_VIEWABLE_CLASS (klass);
+  GimpDataClass      *data_class        = GIMP_DATA_CLASS (klass);
+
+  object_class->finalize           = gimp_mypaint_brush_finalize;
+  object_class->get_property       = gimp_mypaint_brush_get_property;
+  object_class->set_property       = gimp_mypaint_brush_set_property;
+
+  gimp_object_class->get_memsize   = gimp_mypaint_brush_get_memsize;
+
+  viewable_class->default_stock_id = "gimp-tool-mypaint-brush";
+  viewable_class->get_size         = gimp_mypaint_brush_get_size;
+  viewable_class->get_new_preview  = gimp_mypaint_brush_get_new_preview;
+  viewable_class->get_description  = gimp_mypaint_brush_get_description;
+
+  data_class->dirty                = gimp_mypaint_brush_dirty;
+  data_class->get_extension        = gimp_mypaint_brush_get_extension;
+  data_class->save                 = gimp_mypaint_brush_save;
+
+  klass->begin_use                 = gimp_mypaint_brush_real_begin_use;
+  klass->end_use                   = gimp_mypaint_brush_real_end_use;
+  klass->select_mypaint_brush      = gimp_mypaint_brush_real_select_mypaint_brush;
+  klass->want_null_motion          = gimp_mypaint_brush_real_want_null_motion;
+}
+
+static void
+gimp_mypaint_brush_tagged_iface_init (GimpTaggedInterface *iface)
+{
+  iface->get_checksum = gimp_mypaint_brush_get_checksum;
+}
+
+static void
+gimp_mypaint_brush_init (GimpMypaintBrush *mypaint_brush)
+{
+  mypaint_brush->p = (gpointer)(new GimpMypaintBrushPrivate());
+}
+
+static void
+gimp_mypaint_brush_finalize (GObject *object)
+{
+  GimpMypaintBrush *mypaint_brush = GIMP_MYPAINT_BRUSH (object);
+
+  if (mypaint_brush->p) {
+    GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(mypaint_brush->p);
+    delete priv;
+    mypaint_brush->p = NULL;
+  }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gimp_mypaint_brush_set_property (GObject      *object,
+                         guint         property_id,
+                         const GValue *value,
+                         GParamSpec   *pspec)
+{
+  GimpMypaintBrush *mypaint_brush = GIMP_MYPAINT_BRUSH (object);
+
+  switch (property_id)
+    {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+static void
+gimp_mypaint_brush_get_property (GObject    *object,
+                         guint       property_id,
+                         GValue     *value,
+                         GParamSpec *pspec)
+{
+  GimpMypaintBrush *mypaint_brush = GIMP_MYPAINT_BRUSH (object);
+
+  switch (property_id)
+    {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+static gint64
+gimp_mypaint_brush_get_memsize (GimpObject *object,
+                        gint64     *gui_size)
+{
+  GimpMypaintBrush *mypaint_brush   = GIMP_MYPAINT_BRUSH (object);
+  gint64     memsize = 0;
+
+//  memsize += temp_buf_get_memsize (mypaint_brush->mask);
+//  memsize += temp_buf_get_memsize (mypaint_brush->pixmap);
+
+  return memsize + GIMP_OBJECT_CLASS (parent_class)->get_memsize (object,
+                                                                  gui_size);
+}
+
+static gboolean
+gimp_mypaint_brush_get_size (GimpViewable *viewable,
+                     gint         *width,
+                     gint         *height)
+{
+  GimpMypaintBrush *mypaint_brush = GIMP_MYPAINT_BRUSH (viewable);
+
+//  *width  = mypaint_brush->mask->width;
+//  *height = mypaint_brush->mask->height;
+
+  return TRUE;
+}
+
+static TempBuf *
+gimp_mypaint_brush_get_new_preview (GimpViewable *viewable,
+                            GimpContext  *context,
+                            gint          width,
+                            gint          height)
+{
+  GimpMypaintBrush      *mypaint_brush       = GIMP_MYPAINT_BRUSH (viewable);
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(mypaint_brush->p);  
+  TempBuf       *return_buf  = NULL;
+  guchar transp[4]   = { 0, 0, 0, 0 };
+
+  return_buf = temp_buf_new (width, height, 4, 0, 0, transp);
+  guchar *dest_buf   = temp_buf_get_data (return_buf);
+
+  gimp_mypaint_brush_begin_use (mypaint_brush);
+
+  priv->get_new_preview(dest_buf, width, height, 4, 4 * width);
+
+  gimp_mypaint_brush_end_use (mypaint_brush);
+
+  return return_buf;
+}
+
+static gchar *
+gimp_mypaint_brush_get_description (GimpViewable  *viewable,
+                            gchar        **tooltip)
+{
+  GimpMypaintBrush *mypaint_brush = GIMP_MYPAINT_BRUSH (viewable);
+  g_return_val_if_fail (mypaint_brush != NULL, NULL);
+
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(mypaint_brush->p);  
+  g_return_val_if_fail (priv != NULL, NULL);
+  
+  gchar *desc1 = priv->get_parent_brush_name();
+  
+  if (desc1[0] != '\0')
+    return g_strdup (desc1);
+    
+  g_object_get (G_OBJECT (viewable), "name", &desc1, NULL);
+  return g_strdup (desc1);
+}
+
+static void
+gimp_mypaint_brush_dirty (GimpData *data)
+{
+  GimpMypaintBrush *mypaint_brush = GIMP_MYPAINT_BRUSH (data);
+#if 0
+  if (mypaint_brush->mask_cache)
+    gimp_mypaint_brush_cache_clear (mypaint_brush->mask_cache);
+
+  if (mypaint_brush->pixmap_cache)
+    gimp_mypaint_brush_cache_clear (mypaint_brush->pixmap_cache);
+
+  if (mypaint_brush->boundary_cache)
+    gimp_mypaint_brush_cache_clear (mypaint_brush->boundary_cache);
+#endif
+  GIMP_DATA_CLASS (parent_class)->dirty (data);
+}
+
+static const gchar *
+gimp_mypaint_brush_get_extension (GimpData *data)
+{
+  return GIMP_MYPAINT_BRUSH_FILE_EXTENSION;
+}
+
+static void
+gimp_mypaint_brush_real_begin_use (GimpMypaintBrush *mypaint_brush)
+{
+}
+
+static void
+gimp_mypaint_brush_real_end_use (GimpMypaintBrush *mypaint_brush)
+{
+}
+
+static GimpMypaintBrush *
+gimp_mypaint_brush_real_select_mypaint_brush (GimpMypaintBrush        *mypaint_brush,
+                              const GimpCoords *last_coords,
+                              const GimpCoords *current_coords)
+{
+  return mypaint_brush;
+}
+
+static gboolean
+gimp_mypaint_brush_real_want_null_motion (GimpMypaintBrush        *mypaint_brush,
+                                  const GimpCoords *last_coords,
+                                  const GimpCoords *current_coords)
+{
+  return TRUE;
+}
+
+static gchar *
+gimp_mypaint_brush_get_checksum (GimpTagged *tagged)
+{
+  GimpMypaintBrush *mypaint_brush           = GIMP_MYPAINT_BRUSH (tagged);
+  gchar     *checksum_string = NULL;
+#if 0
+  if (mypaint_brush->mask)
+    {
+      GChecksum *checksum = g_checksum_new (G_CHECKSUM_MD5);
+
+      g_checksum_update (checksum, temp_buf_get_data (mypaint_brush->mask), temp_buf_get_data_size (mypaint_brush->mask));
+      if (mypaint_brush->pixmap)
+        g_checksum_update (checksum, temp_buf_get_data (mypaint_brush->pixmap), temp_buf_get_data_size (mypaint_brush->pixmap));
+      g_checksum_update (checksum, (const guchar *) &mypaint_brush->spacing, sizeof (mypaint_brush->spacing));
+      g_checksum_update (checksum, (const guchar *) &mypaint_brush->x_axis, sizeof (mypaint_brush->x_axis));
+      g_checksum_update (checksum, (const guchar *) &mypaint_brush->y_axis, sizeof (mypaint_brush->y_axis));
+
+      checksum_string = g_strdup (g_checksum_get_string (checksum));
+
+      g_checksum_free (checksum);
+    }
+#endif
+  return checksum_string;
+}
+
+/*  public functions  */
+
+GimpData *
+gimp_mypaint_brush_new (GimpContext *context,
+                        const gchar *name)
+{
+  g_return_val_if_fail (name != NULL, NULL);
+  g_return_val_if_fail (name[0] != '\0', NULL);
+
+  GimpMypaintBrush *brush;
+  brush = GIMP_MYPAINT_BRUSH (g_object_new (GIMP_TYPE_MYPAINT_BRUSH,
+                                            "name", name,
+                                            "mime-type", "application/x-mypaint-brush",
+                                            NULL));
+
+  return GIMP_DATA (brush);
+}
+
+GimpData * 
+gimp_mypaint_brush_duplicate (GimpMypaintBrush *mypaint_brush)
+{
+  g_return_val_if_fail (GIMP_IS_MYPAINT_BRUSH (mypaint_brush), NULL);
+  gchar* name;
+  g_object_get (G_OBJECT(mypaint_brush), "name", &name, NULL);
+
+  GimpMypaintBrush* result = GIMP_MYPAINT_BRUSH(gimp_mypaint_brush_new(NULL, name));
+  delete reinterpret_cast<GimpMypaintBrushPrivate*>(result->p);
+  result->p = reinterpret_cast<GimpMypaintBrushPrivate*>(mypaint_brush->p)->duplicate();
+  return GIMP_DATA(result);
+}
+
+
+GimpData *
+gimp_mypaint_brush_get_standard (GimpContext *context)
+{
+  static GimpData *standard_mypaint_brush = NULL;
+
+  if (! standard_mypaint_brush)
+    {
+      standard_mypaint_brush = gimp_mypaint_brush_new (context, "Standard");
+
+      gimp_data_clean (standard_mypaint_brush);
+      gimp_data_make_internal (standard_mypaint_brush, "gimp-mypaint_brush-standard");
+
+      g_object_add_weak_pointer (G_OBJECT (standard_mypaint_brush),
+                                 (gpointer *) &standard_mypaint_brush);
+    }
+
+  return standard_mypaint_brush;
+}
+
+void
+gimp_mypaint_brush_begin_use (GimpMypaintBrush *mypaint_brush)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_BRUSH (mypaint_brush));
+
+  mypaint_brush->use_count++;
+
+  if (mypaint_brush->use_count == 1)
+    GIMP_MYPAINT_BRUSH_GET_CLASS (mypaint_brush)->begin_use (mypaint_brush);
+}
+
+void
+gimp_mypaint_brush_end_use (GimpMypaintBrush *mypaint_brush)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_BRUSH (mypaint_brush));
+  g_return_if_fail (mypaint_brush->use_count > 0);
+
+  mypaint_brush->use_count--;
+
+  if (mypaint_brush->use_count == 0)
+    GIMP_MYPAINT_BRUSH_GET_CLASS (mypaint_brush)->end_use (mypaint_brush);
+}
+
+GimpMypaintBrush *
+gimp_mypaint_brush_select_mypaint_brush (GimpMypaintBrush        *mypaint_brush,
+                         const GimpCoords *last_coords,
+                         const GimpCoords *current_coords)
+{
+  g_return_val_if_fail (GIMP_IS_MYPAINT_BRUSH (mypaint_brush), NULL);
+  g_return_val_if_fail (last_coords != NULL, NULL);
+  g_return_val_if_fail (current_coords != NULL, NULL);
+
+  return GIMP_MYPAINT_BRUSH_GET_CLASS (mypaint_brush)->select_mypaint_brush (mypaint_brush,
+                                                     last_coords,
+                                                     current_coords);
+}
+
+gboolean
+gimp_mypaint_brush_want_null_motion (GimpMypaintBrush        *mypaint_brush,
+                             const GimpCoords *last_coords,
+                             const GimpCoords *current_coords)
+{
+  g_return_val_if_fail (GIMP_IS_MYPAINT_BRUSH (mypaint_brush), FALSE);
+  g_return_val_if_fail (last_coords != NULL, FALSE);
+  g_return_val_if_fail (current_coords != NULL, FALSE);
+
+  return GIMP_MYPAINT_BRUSH_GET_CLASS (mypaint_brush)->want_null_motion (mypaint_brush,
+                                                         last_coords,
+                                                         current_coords);
+}
+
+} /* extern C */
+
+
+
+GimpMypaintBrushPrivate::GimpMypaintBrushPrivate() {
+  parent_brush_name = g_strdup("");
+  group = g_strdup("");
+  icon_image = NULL;
+  for (int i = 0; i < BRUSH_MAPPING_COUNT; i ++) {
+    settings[i].base_value = 0;
+    settings[i].mapping    = NULL;
+  }
+  for (int i = 0; i < BRUSH_BOOL_COUNT; i ++) {
+    switches[i] = FALSE;
+  }
+  dirty = false;
+}
+
+GimpMypaintBrushPrivate::~GimpMypaintBrushPrivate() {
+  if (parent_brush_name) {
+    g_free (parent_brush_name);
+    parent_brush_name = NULL;
+  }
+  if (group) {
+    g_free (group);
+    group = NULL;
+  }
+  for (int i = 0; i < BRUSH_MAPPING_COUNT; i ++) {
+    deallocate_mapping(i);
+  }
+  if (icon_image) {
+    cairo_surface_destroy (icon_image);
+    icon_image = NULL;
+  }
+}
+
+void 
+GimpMypaintBrushPrivate::set_base_value (int index, float value) {
+  g_assert (index >= 0 && index < BRUSH_MAPPING_COUNT);
+  allocate_mapping(index);
+  settings[index].mapping->base_value = value;
+  /*
+  settings[index].base_value = value;
+  if (settings[index].mapping)
+    settings[index].mapping->base_value = value;
+  */
+  mark_as_dirty();
+}
+
+float
+GimpMypaintBrushPrivate::get_base_value (int index) {
+  g_assert (index >= 0 && index < BRUSH_MAPPING_COUNT);
+  if (settings[index].mapping) {
+    return settings[index].mapping->base_value;
+  }
+  return settings[index].base_value;
+}
+
+void 
+GimpMypaintBrushPrivate::allocate_mapping (int index) {
+  g_assert (index >= 0 && index < BRUSH_MAPPING_COUNT);
+  if (!settings[index].mapping) {
+    settings[index].mapping = new Mapping(INPUT_COUNT);
+    mark_as_dirty();
+  }
+}
+
+void
+GimpMypaintBrushPrivate::deallocate_mapping (int index) {
+  g_assert (index >= 0 && index < BRUSH_MAPPING_COUNT);
+  if (settings[index].mapping) {
+    delete settings[index].mapping;
+    mark_as_dirty();
+    settings[index].mapping = NULL;
+  }
+}
+
+char*
+GimpMypaintBrushPrivate::get_parent_brush_name() {
+  return parent_brush_name;
+}
+
+void
+GimpMypaintBrushPrivate::set_parent_brush_name(char *name) {
+  g_assert (name != NULL);
+  if (parent_brush_name)
+    g_free (parent_brush_name);
+  parent_brush_name = g_strdup(name);
+  mark_as_dirty();
+}
+
+char* 
+GimpMypaintBrushPrivate::get_group() {
+  return group;
+}
+
+void
+GimpMypaintBrushPrivate::set_group(char *name) {
+  g_assert (name != NULL);
+  if (group)
+    g_free (group);
+  group = g_strdup(name);
+  mark_as_dirty();
+}
+
+void 
+GimpMypaintBrushPrivate::set_bool_value (int index, bool value) {
+  index -= BRUSH_BOOL_BASE;
+  g_assert (index >= 0 && index < BRUSH_BOOL_COUNT);
+  switches[index] = value;
+  mark_as_dirty();
+}
+
+bool
+GimpMypaintBrushPrivate::get_bool_value (int index) {
+  index -= BRUSH_BOOL_BASE;
+  g_assert (index >= 0 && index < BRUSH_BOOL_COUNT);
+  return switches[index];
+}
+
+
+void 
+GimpMypaintBrushPrivate::get_new_preview(guchar* dest_buf, 
+                                         int width, 
+                                         int height, 
+                                         int bytes, 
+                                         int dest_stride) {
+  ScopeGuard<cairo_surface_t, void(cairo_surface_t*)> scaled_icon(cairo_image_surface_create (CAIRO_FORMAT_ARGB32, width, height), cairo_surface_destroy);
+  
+  gint           icon_width = cairo_image_surface_get_width (icon_image);
+  gint           icon_height = cairo_image_surface_get_height (icon_image);
+  gint           x, y;
+  gdouble        scale = 1.0;
+
+  ScopeGuard<cairo_t, void(cairo_t*)> cr(cairo_create(scaled_icon.ptr()), cairo_destroy);
+  if (icon_width > width || icon_height > height)
+    {
+      gdouble ratio_x = (gdouble) width  / (gdouble) icon_width;
+      gdouble ratio_y = (gdouble) height / (gdouble) icon_height;
+      scale   = MIN (ratio_x, ratio_y);
+      cairo_scale (cr.ptr(), scale, scale);
+    }
+  cairo_set_source_surface (cr.ptr(), icon_image, 0, 0);
+  cairo_paint (cr.ptr());
+  
+  unsigned char *source_buf = cairo_image_surface_get_data (scaled_icon.ptr());
+  gint src_stride       = cairo_image_surface_get_stride (scaled_icon.ptr());
+  
+  for (y = 0; y < height; y ++) 
+    {
+      for (x = 0; x < width; x ++)
+        {
+          // Following code may be dependent on the endian.
+          dest_buf[x * 4    ] = source_buf[x * 4 + 2];
+          dest_buf[x * 4 + 1] = source_buf[x * 4 + 1];
+          dest_buf[x * 4 + 2] = source_buf[x * 4 + 0];
+          dest_buf[x * 4 + 3] = source_buf[x * 4 + 3];
+        }
+      source_buf += src_stride;
+      dest_buf   += dest_stride;
+    }
+}
+
+void
+GimpMypaintBrushPrivate::set_icon_image(cairo_surface_t* image) {
+  if (icon_image) {
+    cairo_surface_destroy (icon_image);
+    icon_image = NULL;
+  }
+  if (image) {
+    cairo_format_t format = cairo_image_surface_get_format(image);
+    int            width  = cairo_image_surface_get_width(image);
+    int            height = cairo_image_surface_get_height(image);
+    int            stride = cairo_image_surface_get_stride(image);
+    guchar         *src_data = cairo_image_surface_get_data(image);
+    int            buf_size = cairo_format_stride_for_width (format, width) * height;
+    guchar         *data = g_new(guchar, buf_size);
+    memcpy(data, src_data, buf_size);
+    icon_image = cairo_image_surface_create_for_data(data, format, width, height,stride);
+    mark_as_dirty();
+  }
+}
+
+cairo_surface_t*
+GimpMypaintBrushPrivate::get_icon_image() {
+  return icon_image;
+}
+
+GimpMypaintBrushPrivate*
+GimpMypaintBrushPrivate::duplicate() {
+  GimpMypaintBrushPrivate* priv = new GimpMypaintBrushPrivate();
+  priv->set_parent_brush_name(parent_brush_name);
+  priv->set_group(group);
+  for (int i = 0; i < BRUSH_MAPPING_COUNT; i ++) {
+    priv->settings[i].base_value = settings[i].base_value;
+    if (settings[i].mapping) {
+      priv->allocate_mapping(i);
+      *(priv->settings[i].mapping) = *(settings[i].mapping);
+    }
+  }
+  for (int i = 0; i < BRUSH_BOOL_COUNT; i ++) {
+    priv->switches[i] = switches[i];
+  }
+  priv->set_icon_image(icon_image);
+  return priv;
+}
diff -Naur gimp-2.8.14/app/core/gimpmypaintbrush.h gimp-2.8.14-new/app/core/gimpmypaintbrush.h
--- gimp-2.8.14/app/core/gimpmypaintbrush.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/gimpmypaintbrush.h	2015-01-27 17:48:39.699752637 +0800
@@ -0,0 +1,75 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_BRUSH_H__
+#define __GIMP_MYPAINT_BRUSH_H__
+
+typedef struct _GimpMypaintBrushClass GimpMypaintBrushClass;
+
+#include "gimpdata.h"
+#include "mypaintbrush-enum-settings.h"
+
+
+#define GIMP_TYPE_MYPAINT_BRUSH            (gimp_mypaint_brush_get_type ())
+#define GIMP_MYPAINT_BRUSH(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MYPAINT_BRUSH, GimpMypaintBrush))
+#define GIMP_MYPAINT_BRUSH_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MYPAINT_BRUSH, GimpMypaintBrushClass))
+#define GIMP_IS_MYPAINT_BRUSH(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MYPAINT_BRUSH))
+#define GIMP_IS_MYPAINT_BRUSH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MYPAINT_BRUSH))
+#define GIMP_MYPAINT_BRUSH_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MYPAINT_BRUSH, GimpMypaintBrushClass))
+
+
+
+struct _GimpMypaintBrush
+{
+  GimpData        parent_instance;
+  gint            use_count;  /*  for keeping the caches alive   */
+  gpointer        p;
+};
+
+struct _GimpMypaintBrushClass
+{
+  GimpDataClass  parent_class;
+
+  /*  virtual functions  */
+  void              (* begin_use)          (GimpMypaintBrush        *mypaint_brush);
+  void              (* end_use)            (GimpMypaintBrush        *mypaint_brush);
+  GimpMypaintBrush* (* select_mypaint_brush)(GimpMypaintBrush        *mypaint_brush,
+                                             const GimpCoords *last_coords,
+                                             const GimpCoords *current_coords);
+  gboolean          (* want_null_motion)    (GimpMypaintBrush        *mypaint_brush,
+                                             const GimpCoords *last_coords,
+                                             const GimpCoords *current_coords);
+};
+
+
+GType                  gimp_mypaint_brush_get_type            (void) G_GNUC_CONST;
+
+GimpData             * gimp_mypaint_brush_new                 (GimpContext      *context,
+                                                               const gchar      *name);
+GimpData             * gimp_mypaint_brush_get_standard        (GimpContext      *context);
+
+void                   gimp_mypaint_brush_begin_use           (GimpMypaintBrush        *mypaint_brush);
+void                   gimp_mypaint_brush_end_use             (GimpMypaintBrush        *mypaint_brush);
+
+GimpMypaintBrush     * gimp_mypaint_brush_select_mypaint_brush(GimpMypaintBrush        *mypaint_brush,
+                                                               const GimpCoords *last_coords,
+                                                               const GimpCoords *current_coords);
+gboolean               gimp_mypaint_brush_want_null_motion    (GimpMypaintBrush        *mypaint_brush,
+                                                               const GimpCoords *last_coords,
+                                                               const GimpCoords *current_coords);
+GimpData              * gimp_mypaint_brush_duplicate         (GimpMypaintBrush *mypaint_brush);
+#endif /* __GIMP_MYPAINT_BRUSH_H__ */
diff -Naur gimp-2.8.14/app/core/gimpmypaintbrush-load.cpp gimp-2.8.14-new/app/core/gimpmypaintbrush-load.cpp
--- gimp-2.8.14/app/core/gimpmypaintbrush-load.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/gimpmypaintbrush-load.cpp	2015-01-27 17:48:39.696752638 +0800
@@ -0,0 +1,530 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimpbrush-load.c
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern "C" {
+
+#include "config.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#ifndef _O_BINARY
+#define _O_BINARY 0
+#endif
+
+#include <glib-object.h>
+#include <glib/gstdio.h>
+#include <cairo.h>
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpcolor/gimpcolor.h"
+
+#ifdef G_OS_WIN32
+#include "libgimpbase/gimpwin32-io.h"
+#endif
+
+#include <glib.h> /* GIOChannel */
+#include <glib/gprintf.h> /* strip / split */
+
+
+#include "core-types.h"
+
+#include "base/temp-buf.h"
+
+#include "gimpmypaintbrush.h"
+#include "gimpmypaintbrush-load.h"
+#include "mypaintbrush-brushsettings.h"
+
+#include "gimp-intl.h"
+
+}
+#include "gimpmypaintbrush-private.hpp"
+
+#define CURRENT_BRUSHFILE_VERSION 2
+
+/*  local function prototypes  */
+
+class MyPaintBrushReader {
+  private:
+  GimpMypaintBrush *result;
+  GHashTable       *raw_pair;
+  gint64            version;
+  
+  typedef gfloat (TransformY)(gfloat input);
+
+  GHashTable* read_file (const gchar *filename, GError **error);
+  void load_defaults   ();
+  void parse_raw       (gint64 version);
+  void parse_points_v1 (gchar *string, gint inputs_index, Mapping *mapping, TransformY trans = NULL);
+  void parse_points_v2 (gchar *string, gint inputs_index, Mapping *mapping, TransformY trans = NULL);
+  gchar *unquote        (const gchar *string);
+  void load_icon       (gchar *filename);
+  void dump();
+  
+  public:
+  MyPaintBrushReader();
+  ~MyPaintBrushReader();
+  GimpMypaintBrush *
+  load_brush (GimpContext  *context,
+              const gchar  *filename,
+              GError      **error);
+
+    
+};
+
+extern "C" {
+/*  public functions  */
+
+GList *
+gimp_mypaint_brush_load (GimpContext  *context,
+                 const gchar  *filename,
+                 GError      **error)
+{
+  GimpMypaintBrush *brush;
+
+  g_print ("Read mypaint brush %s\n", filename);
+
+  g_return_val_if_fail (filename != NULL, NULL);
+  g_return_val_if_fail (g_path_is_absolute (filename), NULL);
+  g_return_val_if_fail (error == NULL || *error == NULL, NULL);
+  
+
+  MyPaintBrushReader reader;
+  brush = reader.load_brush (context, filename, error);
+
+  if (! brush)
+    return NULL;
+
+  return g_list_prepend (NULL, brush);
+}
+
+}
+
+/*  private functions  */
+
+
+MyPaintBrushReader::MyPaintBrushReader() : result(NULL), raw_pair(NULL), version(0)
+{
+}
+
+MyPaintBrushReader::~MyPaintBrushReader()
+{
+  if (raw_pair)
+    g_hash_table_unref (raw_pair);
+  if (result)
+    g_object_unref (result);
+}
+
+GimpMypaintBrush*
+MyPaintBrushReader::load_brush (GimpContext  *context,
+                       const gchar  *filename,
+                       GError      **error)
+{
+//  ScopeGuard<gchar, void(gpointer)> unescaped_path(unquote (filename), g_free);
+  ScopeGuard<gchar, void(gpointer)> basename(g_path_get_basename (filename), g_free);
+  gchar *brushname = g_strndup(basename.ptr(), strlen(basename.ptr()) - strlen(GIMP_MYPAINT_BRUSH_FILE_EXTENSION));
+  version = 0;  
+
+  result = GIMP_MYPAINT_BRUSH (gimp_mypaint_brush_new (context, brushname));
+  load_defaults();
+  g_object_ref (result);
+  raw_pair = read_file (filename, error);
+  parse_raw (version);
+//  dump();
+  
+  ScopeGuard<gchar, void(gpointer)> filename_dup(g_strndup(filename, strlen(filename) - strlen(GIMP_MYPAINT_BRUSH_FILE_EXTENSION)), g_free);
+  ScopeGuard<gchar, void(gpointer)> icon_filename(g_strconcat (filename_dup.ptr(), GIMP_MYPAINT_BRUSH_ICON_FILE_EXTENSION, NULL), g_free);
+  g_print ("Read Icon: %s\n", icon_filename.ptr());
+  load_icon (icon_filename.ptr());
+  GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(result->p);
+  priv->clear_dirty_flag();
+  return result;
+}
+
+void
+MyPaintBrushReader::load_defaults ()
+{
+  ScopeGuard<GList, void(GList*)> settings(mypaint_brush_get_brush_settings (), g_list_free);
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(result->p);
+
+  for (GList* item = settings.ptr(); item; item = item->next) {
+    MyPaintBrushSettings* setting = reinterpret_cast<MyPaintBrushSettings*>(item->data);
+    priv->set_base_value(setting->index, setting->default_value);
+//    priv->deallocate_mapping(setting->index);
+    if (g_strcmp0(setting->internal_name, "opaque_multiply") == 0) {
+      priv->allocate_mapping(setting->index);
+      GimpMypaintBrushPrivate::Value* v = priv->get_setting(setting->index);
+      v->mapping->set_n(INPUT_PRESSURE, 2);
+      v->mapping->set_point(INPUT_PRESSURE, 0, 0.0, 0.0);
+      v->mapping->set_point(INPUT_PRESSURE, 1, 1.0, 1.0);      
+    }
+  }
+}
+
+void
+MyPaintBrushReader::dump ()
+{
+  ScopeGuard<GList, void(GList*)> settings(mypaint_brush_get_brush_settings (), g_list_free);
+  ScopeGuard<GList, void(GList*)> inputs(mypaint_brush_get_input_settings (), g_list_free);
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(result->p);
+
+  for (GList* item = settings.ptr(); item; item = item->next) {
+    MyPaintBrushSettings* setting = reinterpret_cast<MyPaintBrushSettings*>(item->data);
+    GimpMypaintBrushPrivate::Value* v = priv->get_setting(setting->index);
+    if (v->mapping) {
+      g_print("mapping: %s=%f\n", setting->internal_name, v->mapping->base_value);
+      for (GList* input_iter = inputs.ptr(); input_iter; input_iter = input_iter->next) {
+        MyPaintBrushInputSettings* input = reinterpret_cast<MyPaintBrushInputSettings*>(input_iter->data);
+        int n = v->mapping->get_n(input->index);
+        if (n == 0)
+          continue;
+        g_print ("  %s:", input->name);
+        for (int i = 0; i < n; i ++) {
+          float x, y;
+          v->mapping->get_point(input->index, i, &x, &y);
+          g_print ("(%f,%f) ", x, y);
+        }
+        g_print ("\n");
+      }
+    } else {
+      g_print("base only: %s=%f\n", setting->internal_name, v->base_value);
+    }
+  }
+}
+
+GHashTable*
+MyPaintBrushReader::read_file (const gchar *filename, GError **error)
+{
+  GIOChannel       *config_stream;
+  gchar            *line;
+  gsize             line_len;
+  gsize             line_term_pos;
+
+  g_return_val_if_fail ( GIMP_IS_MYPAINT_BRUSH (result), NULL);
+
+  config_stream = g_io_channel_new_file (filename, "r", error);
+  ScopeGuard<GIOChannel, void(GIOChannel*)> config_stream_holder(config_stream, g_io_channel_unref);
+    
+  if (! config_stream)
+    {
+      g_clear_error (error);
+      return NULL;
+    }
+    
+  raw_pair = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
+  
+  while (g_io_channel_read_line (config_stream, &line, &line_len, &line_term_pos, error) != G_IO_STATUS_EOF)
+    {
+      ScopeGuard<gchar, void(gpointer)> line_holder(line, g_free);
+      if (!line)
+        break;
+      
+      line = g_strstrip (line);
+      if (line[0] != '#')
+        {
+          gchar **tokens = g_strsplit (line, " ", 2);
+          ScopeGuard<gchar*, void(gchar**)> token_holder(tokens, g_strfreev);
+          if (g_strcmp0(tokens[0], "version") == 0) 
+            {
+              version = g_ascii_strtoll (tokens[1], NULL, 0);
+              if (version > CURRENT_BRUSHFILE_VERSION)
+                {
+                  // TBD: 
+                  break;
+                }
+            } 
+          else
+            {
+              g_hash_table_insert (raw_pair, g_strdup(tokens[0]), g_strdup(tokens[1])); // Note: ownership of tokens is moved to GHashTable object.
+            }
+        }
+    }
+  return raw_pair;
+}
+
+gchar* 
+MyPaintBrushReader::unquote (const gchar *string)
+{
+  return g_uri_unescape_string (string, NULL);
+}
+
+/// Parses the points list format from versions prior to version 2.
+void
+MyPaintBrushReader::parse_points_v1 (
+    gchar *string, 
+    gint inputs_index, 
+    Mapping *mapping, 
+    MyPaintBrushReader::TransformY* trans)
+{
+  gchar **iter;
+  gint num_seq = 0;
+  gfloat prev_x;
+  gint i;
+  
+  g_print ("Parse v1 params : %s\n", string);
+
+  ScopeGuard<gchar*, void(gchar**)> seq(g_strsplit (string, " ", 0), g_strfreev); 
+  
+  for (iter = seq.ptr(); *iter; iter++)
+    num_seq ++;
+
+  mapping->set_n(inputs_index, num_seq / 2);
+  g_print ("set_n: %d\n", num_seq / 2);
+
+  prev_x = 0;
+  i = 0;
+  for (iter = seq.ptr(); *iter; )
+    {
+      gdouble x_val, y_val;
+      
+      x_val = g_ascii_strtod (*(iter++), NULL);
+      if (!(x_val > prev_x));
+        {
+          g_print ("Invalid input points: x > previous x\n");
+          goto next;
+        }
+      prev_x = x_val;
+
+      y_val = g_ascii_strtod (*(iter++), NULL);
+      if (trans)
+        y_val = (*trans)((gfloat)y_val);
+      
+      g_print ("X=%lf,Y=%lf\n", x_val, y_val);
+      
+      mapping->set_point(inputs_index, i ++, (float)x_val, (float)y_val);
+    next:;;
+    }  
+}
+
+/// Parses the newer points list format of v2 and beyond.
+void
+MyPaintBrushReader::parse_points_v2 (
+    gchar *string, 
+    gint inputs_index, 
+    Mapping *mapping,
+    MyPaintBrushReader::TransformY* trans)
+
+{
+  gchar **seq;
+  gchar **iter;
+  gint num_seq = 0;
+  gint i;
+
+  seq = g_strsplit (string, ", ", 0);  
+  
+  for (iter = seq; *iter; iter++)
+    num_seq ++;
+
+  mapping->set_n(inputs_index, num_seq);
+
+  i = 0;
+  for (iter = seq; *iter; iter++)
+    {
+      gchar *str_pos = *iter;
+      gdouble x_val, y_val;
+      str_pos = g_strstrip (str_pos);
+      if (str_pos[0] != '(') 
+        {
+          // NG
+          g_print ("ERROR: must be start with '(', but %c appears.\n", str_pos[0]);
+        }
+      str_pos = g_strstrip (++str_pos);
+      x_val = g_ascii_strtod (str_pos, &str_pos);
+      
+      str_pos = g_strstrip (str_pos);
+      y_val = g_ascii_strtod (str_pos, &str_pos);
+      if (trans)
+        y_val = (*trans)((gfloat)y_val);
+
+      str_pos = g_strstrip (str_pos);
+      if (str_pos[0] != ')') 
+        {
+          // NG
+          g_print ("ERROR: must be end with ')', but %c appears.\n", str_pos[0]);
+        }
+      mapping->set_point(inputs_index, i ++, (float)x_val, (float)y_val);
+    }  
+}
+
+void
+MyPaintBrushReader::parse_raw (
+                  gint64            version)
+{
+  ScopeGuard<GHashTable, void(GHashTable*)> settings_dict(mypaint_brush_get_brush_settings_dict (), g_hash_table_unref);
+  ScopeGuard<GHashTable, void(GHashTable*)> inputs_dict(mypaint_brush_get_input_settings_dict (), g_hash_table_unref);
+  ScopeGuard<GHashTable, void(GHashTable*)> migrate_dict(mypaint_brush_get_setting_migrate_dict (), g_hash_table_unref);
+  GHashTableIter    raw_pair_iter;
+  gpointer          raw_key, raw_value;
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(result->p);
+
+  g_hash_table_iter_init (&raw_pair_iter, raw_pair);
+  
+  while (g_hash_table_iter_next (&raw_pair_iter, &raw_key, &raw_value))
+    {
+      gchar    *key          = (gchar*)raw_key;
+      gchar    *value        = (gchar*)raw_value;
+      
+      if (strcmp (key, "parent_brush_name") == 0)
+        {
+          gchar *uq_value = unquote (value);
+          priv->set_parent_brush_name(uq_value);
+          g_object_set (G_OBJECT (result), "name", uq_value, NULL);
+//          g_free (uq_value);
+          goto next_pair;
+        }
+      else if (strcmp (key, "group") == 0)
+        {
+          gchar *uq_value = unquote (value);
+          priv->set_group(value);
+          g_free (uq_value);
+          goto next_pair;
+        }
+      else if (version <= 1 && strcmp (key, "color") == 0) 
+        {
+          ScopeGuard<gchar*, void(gchar**)>  tokens(g_strsplit(value, " ", 0), g_strfreev);
+          MyPaintBrushSettings               *setting;
+          gint64 r, g, b;
+          r = g_ascii_strtoll(tokens.ptr()[0], NULL, 10);
+          g = g_ascii_strtoll(tokens.ptr()[1], NULL, 10);
+          b = g_ascii_strtoll(tokens.ptr()[2], NULL, 10);
+          GimpRGB rgb;
+          rgb.r = r / 255.0; 
+          rgb.g = g / 255.0; 
+          rgb.b = b / 255.0; 
+          rgb.a = 1.0;
+          GimpHSV hsv;
+          gimp_rgb_to_hsv (&rgb, &hsv);
+
+          setting = (MyPaintBrushSettings*)g_hash_table_lookup (settings_dict.ptr(), "color_h");
+          priv->set_base_value (setting->index, hsv.h);
+
+          setting = (MyPaintBrushSettings*)g_hash_table_lookup (settings_dict.ptr(), "color_s");
+          priv->set_base_value (setting->index, hsv.s);
+
+          setting = (MyPaintBrushSettings*)g_hash_table_lookup (settings_dict.ptr(), "color_v");
+          priv->set_base_value (setting->index, hsv.v);
+
+          goto next_pair;
+        }
+      else if (version <= 1 && strcmp (key, "change_radius") == 0)
+        {
+          if (strcmp (value, "0.0") == 0)
+            goto next_pair;
+          else
+            {
+              //FIXME! ERROR
+              //raise Obsolete, 'change_radius is not supported any more'
+            }
+        }
+      else if (version <= 2 && strcmp (key, "adapt_color_from_image") == 0)
+        {
+          if (strcmp (value, "0.0") == 0)
+            goto next_pair;
+          else
+            {
+              //FIXME! ERROR
+              //raise Obsolete, 'adapt_color_from_image is obsolete, ignored;' + \
+              //                ' use smudge and smudge_length instead'
+            }
+        }
+      else if (version <= 1 && strcmp (key, "painting_time") == 0)
+        {
+          goto next_pair;
+        }      
+      else if (version <= 1 && strcmp (key, "speed") == 0)
+        {
+          key = (gchar*)"speed1";
+        }
+      {
+      MyPaintBrushSettingMigrate *migrate = (MyPaintBrushSettingMigrate*)g_hash_table_lookup (migrate_dict.ptr(), key);
+      if (migrate)
+        {
+          if (migrate->new_name)
+            key = migrate->new_name;
+        }
+      
+      
+      MyPaintBrushSettings             *setting;
+      setting = (MyPaintBrushSettings*)g_hash_table_lookup (settings_dict.ptr(), key);
+      if (setting)
+        {
+          ScopeGuard<gchar*, void(gchar**)>   split_values(g_strsplit (value, "|", 0), g_strfreev);
+          gchar                          **values_pos;
+          values_pos = split_values.ptr();
+          
+          gdouble d_val = g_ascii_strtod (*values_pos, NULL);
+          if (migrate && migrate->transform)
+            d_val = (*migrate->transform)((gfloat)d_val);
+
+        
+          priv->set_base_value(setting->index, d_val);
+          values_pos ++;      
+          if (*values_pos)
+            {
+              priv->allocate_mapping(setting->index);
+            }
+          GimpMypaintBrushPrivate::Value* v = priv->get_setting(setting->index);
+          while (*values_pos)
+            {
+              //      inputname, rawpoints = part.strip().split(' ', 1)
+              gchar *str_pos = *values_pos;
+              str_pos = g_strstrip (str_pos);
+              ScopeGuard<gchar *, void(gchar**)> tokens(g_strsplit (str_pos, " ", 2), g_strfreev);
+              MyPaintBrushInputSettings *input_setting;
+              input_setting = (MyPaintBrushInputSettings*)g_hash_table_lookup (inputs_dict.ptr(), tokens.ptr()[0]);
+              if (tokens.ptr()[1] && input_setting)
+                {
+                  if (version <= 1)
+                    parse_points_v1 (tokens.ptr()[1], input_setting->index, v->mapping, migrate? migrate->transform: NULL);
+                  else
+                    parse_points_v2 (tokens.ptr()[1], input_setting->index, v->mapping, migrate? migrate->transform: NULL);
+                }
+              else
+                {
+                  g_print ("invalid parameter '%s'\n", *values_pos);
+                }
+              values_pos ++;
+            }
+        }
+      else
+        {
+          g_print ("invalid key '%s'\n", key);
+        }
+      }
+    next_pair:
+      ;;
+    }
+}
+
+void
+MyPaintBrushReader::load_icon (gchar *filename)
+{
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(result->p);
+	cairo_surface_t* icon_image = cairo_image_surface_create_from_png(filename);
+  priv->set_icon_image(icon_image);
+  cairo_surface_destroy (icon_image);
+}
diff -Naur gimp-2.8.14/app/core/gimpmypaintbrush-load.h gimp-2.8.14-new/app/core/gimpmypaintbrush-load.h
--- gimp-2.8.14/app/core/gimpmypaintbrush-load.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/gimpmypaintbrush-load.h	2015-01-27 17:48:39.696752638 +0800
@@ -0,0 +1,31 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_BRUSH_LOAD_H__
+#define __GIMP_MYPAINT_BRUSH_LOAD_H__
+
+
+#define GIMP_MYPAINT_BRUSH_FILE_EXTENSION        ".myb"
+#define GIMP_MYPAINT_BRUSH_ICON_FILE_EXTENSION "_prev.png"
+
+
+GList     * gimp_mypaint_brush_load        (GimpContext  *context,
+                                    const gchar  *filename,
+                                    GError      **error);
+
+
+#endif /* __GIMP_MYPAINT_BRUSH_LOAD_H__ */
diff -Naur gimp-2.8.14/app/core/gimpmypaintbrush-private.hpp gimp-2.8.14-new/app/core/gimpmypaintbrush-private.hpp
--- gimp-2.8.14/app/core/gimpmypaintbrush-private.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/gimpmypaintbrush-private.hpp	2015-01-27 17:48:39.696752638 +0800
@@ -0,0 +1,57 @@
+#ifndef __GIMP_MYPAINT_BRUSH_PRIVATE_H__
+#define __GIMP_MYPAINT_BRUSH_PRIVATE_H__
+
+extern "C" {
+#include <glib.h>
+#include <cairo.h>
+};
+#include "mypaintbrush-mapping.hpp"
+#include "mypaintbrush-enum-settings.h"
+
+extern "C++" {
+#include "base/scopeguard.hpp"
+class GimpMypaintBrushPrivate {
+  public:
+  struct Value {
+    float base_value;
+    Mapping *mapping;
+  };
+  private:
+  char *parent_brush_name;
+  char *group;
+  Value  settings[BRUSH_MAPPING_COUNT];
+  bool   switches[BRUSH_BOOL_COUNT];
+  gchar* text[BRUSH_TEXT_COUNT];
+  cairo_surface_t *icon_image;
+  bool dirty;
+
+  public:
+  GimpMypaintBrushPrivate();
+  ~GimpMypaintBrushPrivate();
+  Value* get_setting(int index) {
+    g_assert (0 <= index && index < BRUSH_MAPPING_COUNT);
+    return &settings[index];
+  }
+  void set_base_value (int index, float value);
+  void set_bool_value (int index, bool value);
+  bool get_bool_value (int index);
+  float get_base_value (int index);
+  void allocate_mapping (int index);
+  void deallocate_mapping (int index);
+  char* get_parent_brush_name();
+  void  set_parent_brush_name(char *name);
+  char* get_group();
+  void  set_group(char *name);
+  void get_new_preview(guchar* dest, int width, int height, int bytes, int stride);
+  void set_icon_image(cairo_surface_t* image);
+  cairo_surface_t* get_icon_image();
+  GimpMypaintBrushPrivate* duplicate();
+  void clear_dirty_flag() { dirty = false; };
+  void mark_as_dirty() { dirty = true; }
+  bool is_dirty() { return dirty; };
+};
+
+void destroy_gimp_mypaint_brush_private(gpointer data);
+
+}
+#endif
diff -Naur gimp-2.8.14/app/core/gimpmypaintbrush-save.cpp gimp-2.8.14-new/app/core/gimpmypaintbrush-save.cpp
--- gimp-2.8.14/app/core/gimpmypaintbrush-save.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/gimpmypaintbrush-save.cpp	2015-01-27 17:48:39.697752638 +0800
@@ -0,0 +1,221 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimpbrush-load.c
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern "C" {
+
+#include "config.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#ifndef _O_BINARY
+#define _O_BINARY 0
+#endif
+
+#include <glib-object.h>
+#include <glib/gstdio.h>
+#include <cairo.h>
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpcolor/gimpcolor.h"
+
+#ifdef G_OS_WIN32
+#include "libgimpbase/gimpwin32-io.h"
+#endif
+
+#include <glib.h> /* GIOChannel */
+#include <glib/gprintf.h> /* strip / split */
+
+
+#include "core-types.h"
+
+#include "base/temp-buf.h"
+
+#include "gimpmypaintbrush.h"
+#include "gimpmypaintbrush-load.h"
+#include "mypaintbrush-brushsettings.h"
+
+#include "gimp-intl.h"
+
+}
+
+#include "gimpmypaintbrush-private.hpp"
+#include "base/glib-cxx-utils.hpp"
+
+#define CURRENT_BRUSHFILE_VERSION 2
+
+/*  local function prototypes  */
+
+class MypaintBrushWriter {
+  private:
+  GimpMypaintBrush* source;
+  gint64            version;
+  
+  void write_file (GError **error);
+  bool is_default(gchar* name);
+  void save_to_string  ();
+  gchar *quote        (const gchar *string);
+  void save_icon       (gchar *filename);
+  void dump();
+  
+  public:
+  MypaintBrushWriter(GimpMypaintBrush* brush);
+  ~MypaintBrushWriter();
+  void save_brush (GError **error);
+};
+
+extern "C" {
+/*  public functions  */
+
+GList *
+gimp_mypaint_brush_save (GimpData* data,
+                         GError      **error)
+{
+  GimpMypaintBrush* brush = GIMP_MYPAINT_BRUSH(data);
+
+  g_return_val_if_fail (error == NULL || *error == NULL, NULL);
+  
+  MypaintBrushWriter writer(brush);
+  writer.save_brush (error);
+
+  if (! brush)
+    return NULL;
+
+  return g_list_prepend (NULL, brush);
+}
+
+}
+
+/*  private functions  */
+
+
+MypaintBrushWriter::MypaintBrushWriter(GimpMypaintBrush* brush)
+  : source(brush), version(CURRENT_BRUSHFILE_VERSION)
+{
+  g_object_ref(source);
+}
+
+MypaintBrushWriter::~MypaintBrushWriter()
+{
+  if (source)
+    g_object_unref (source);
+}
+
+void
+MypaintBrushWriter::save_brush (GError      **error)
+{
+//  StringHolder filename_dup(g_strndup(filepath, strlen(filepath) - strlen(GIMP_MYPAINT_BRUSH_FILE_EXTENSION)));
+//  StringHolder icon_filename(g_strconcat (filename_dup.ptr(), GIMP_MYPAINT_BRUSH_ICON_FILE_EXTENSION, NULL));
+  write_file(error);
+
+//  g_print ("Write Icon: %s\n", icon_filename.ptr());
+//  save_icon (icon_filename.ptr());
+}
+
+bool
+MypaintBrushWriter::is_default(gchar* name)
+{
+  GHashTableHolder<gchar*, MyPaintBrushSettings*> settings_dict(mypaint_brush_get_brush_settings_dict ());
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(source->p);
+
+  MyPaintBrushSettings* setting = settings_dict[name];
+
+  if (!setting)
+    return false;
+    
+  float base_value = priv->get_base_value(setting->index);
+  if (base_value != setting->default_value)
+    return false;
+  
+  return true;
+}
+
+void
+MypaintBrushWriter::write_file (GError** error)
+{
+  g_return_if_fail(source != NULL);
+  
+  const gchar* filename = gimp_data_get_filename (GIMP_DATA(source));
+  
+  GListHolder settings(mypaint_brush_get_brush_settings ());
+  GListHolder switches(mypaint_brush_get_brush_switch_settings ());
+  GListHolder texts(mypaint_brush_get_brush_text_settings ());
+  GListHolder inputs(mypaint_brush_get_input_settings ());
+  gchar* brush_name;
+  g_object_get(source, "name",&brush_name, NULL);
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(source->p);
+  ScopeGuard<FILE, int(FILE*)> file(g_fopen(filename,"w"), fclose);
+//  FILE* f = file.ptr();
+  FILE* f = stdout;
+
+  fprintf(f, "version %ld\n", version);
+
+  for (GList* item = settings.ptr(); item; item = item->next) {
+    MyPaintBrushSettings* setting = reinterpret_cast<MyPaintBrushSettings*>(item->data);
+    GimpMypaintBrushPrivate::Value* v = priv->get_setting(setting->index);
+    fprintf(f, "%s %f ", setting->internal_name, v->base_value);
+    if (v->mapping) {
+      for (GList* input_iter = inputs.ptr(); input_iter; input_iter = input_iter->next) {
+        fprintf(f, " |");
+        MyPaintBrushInputSettings* input = reinterpret_cast<MyPaintBrushInputSettings*>(input_iter->data);
+        int n = v->mapping->get_n(input->index);
+        if (n == 0)
+          continue;
+        fprintf(f, "%s", input->name);
+        float x, y;
+        v->mapping->get_point(input->index, 0, &x, &y);
+        fprintf(f, " (%f,%f)", x, y);
+        for (int i = 1; i < n; i ++) {
+          v->mapping->get_point(input->index, i, &x, &y);
+          fprintf(f, ", (%f,%f)", x, y);
+        }
+      }
+    }
+    fprintf(f, "\n");
+  }
+  for (GList* item = switches.ptr(); item; item = item->next) {
+    MyPaintBrushSwitchSettings* setting = reinterpret_cast<MyPaintBrushSwitchSettings*>(item->data);
+    bool value = priv->get_bool_value(setting->index);
+    fprintf(f, "%s %d", setting->internal_name, value? 1:0);
+    fprintf(f, "\n");
+  }
+}
+
+gchar* 
+MypaintBrushWriter::quote (const gchar *string)
+{
+  return g_uri_escape_string (string, NULL, TRUE);
+}
+
+void
+MypaintBrushWriter::save_icon (gchar *filename)
+{
+  GimpMypaintBrushPrivate *priv = reinterpret_cast<GimpMypaintBrushPrivate*>(source->p);
+	cairo_surface_t* icon_image = cairo_image_surface_create_from_png(filename);
+  priv->set_icon_image(icon_image);
+  cairo_surface_destroy (icon_image);
+}
diff -Naur gimp-2.8.14/app/core/gimpmypaintbrush-save.h gimp-2.8.14-new/app/core/gimpmypaintbrush-save.h
--- gimp-2.8.14/app/core/gimpmypaintbrush-save.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/gimpmypaintbrush-save.h	2015-01-27 17:48:39.697752638 +0800
@@ -0,0 +1,30 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_BRUSH_SAVE_H__
+#define __GIMP_MYPAINT_BRUSH_SAVE_H__
+
+#include "gimpmypaintbrush.h"
+
+#define GIMP_MYPAINT_BRUSH_FILE_EXTENSION        ".myb"
+#define GIMP_MYPAINT_BRUSH_ICON_FILE_EXTENSION "_prev.png"
+
+gboolean gimp_mypaint_brush_save       (GimpData  *brush,
+                                        GError      **error);
+
+
+#endif /* __GIMP_MYPAINT_BRUSH_SAVE_H__ */
\ No newline at end of file
diff -Naur gimp-2.8.14/app/core/gimptoolinfo.c gimp-2.8.14-new/app/core/gimptoolinfo.c
--- gimp-2.8.14/app/core/gimptoolinfo.c	2015-01-27 17:28:36.687833823 +0800
+++ gimp-2.8.14-new/app/core/gimptoolinfo.c	2015-01-27 17:48:55.318751583 +0800
@@ -102,6 +102,7 @@
   tool_info->visible           = TRUE;
   tool_info->tool_options      = NULL;
   tool_info->paint_info        = NULL;
+//  tool_info->mypaint_info        = NULL;
 }
 
 static void
@@ -239,6 +240,7 @@
                     const gchar         *stock_id)
 {
   GimpPaintInfo *paint_info;
+//  GimpMypaintInfo* mypaint_info = NULL;
   GimpToolInfo  *tool_info;
 
   g_return_val_if_fail (GIMP_IS_GIMP (gimp), NULL);
@@ -253,7 +255,8 @@
   paint_info = (GimpPaintInfo *)
     gimp_container_get_child_by_name (gimp->paint_info_list, paint_core_name);
 
-  g_return_val_if_fail (GIMP_IS_PAINT_INFO (paint_info), NULL);
+
+  g_return_val_if_fail (GIMP_IS_PAINT_INFO(paint_info), NULL);
 
   tool_info = g_object_new (GIMP_TYPE_TOOL_INFO,
                             "name",     identifier,
@@ -275,8 +278,9 @@
   tool_info->help_id           = g_strdup (help_id);
 
   tool_info->paint_info        = paint_info;
+//  tool_info->mypaint_info      = mypaint_info;
 
-  if (tool_info->tool_options_type == paint_info->paint_options_type)
+  if (paint_info && tool_info->tool_options_type == paint_info->paint_options_type)
     {
       tool_info->tool_options = g_object_ref (paint_info->paint_options);
     }
diff -Naur gimp-2.8.14/app/core/gimptoolinfo.h gimp-2.8.14-new/app/core/gimptoolinfo.h
--- gimp-2.8.14/app/core/gimptoolinfo.h	2015-01-27 17:28:36.625833827 +0800
+++ gimp-2.8.14-new/app/core/gimptoolinfo.h	2015-01-27 17:48:55.319751583 +0800
@@ -54,6 +54,7 @@
   gboolean             visible;
   GimpToolOptions     *tool_options;
   GimpPaintInfo       *paint_info;
+//  GimpMypaintInfo     *mypaint_info;
 
   GimpContainer       *presets;
 };
diff -Naur gimp-2.8.14/app/core/Makefile.am gimp-2.8.14-new/app/core/Makefile.am
--- gimp-2.8.14/app/core/Makefile.am	2015-01-27 17:28:36.702833822 +0800
+++ gimp-2.8.14-new/app/core/Makefile.am	2015-01-27 17:48:39.687752638 +0800
@@ -79,6 +79,14 @@
 	gimpbrushgenerated-load.h		\
 	gimpbrushgenerated-save.c		\
 	gimpbrushgenerated-save.h		\
+  gimpmypaintbrush.h                      \
+	gimpmypaintbrush.cpp			\
+  gimpmypaintbrush-load.h			\
+	gimpmypaintbrush-load.cpp			\
+	mypaintbrush-enum-settings.h \
+	mypaintbrush-brushsettings.h \
+	mypaintbrush-brushsettings.c \
+	mypaintbrush-mapping.hpp \
 	gimpbrushpipe.c				\
 	gimpbrushpipe.h				\
 	gimpbrushpipe-load.c			\
@@ -393,7 +401,10 @@
 	gimpundostack.c				\
 	gimpundostack.h				\
 	gimpviewable.c				\
-	gimpviewable.h
+	gimpviewable.h				\
+	gimpmypaintbrush-private.hpp		\
+	gimpmypaintbrush-save.cpp		\
+	gimpmypaintbrush-save.h	
 
 libappcore_a_built_sources = \
 	core-enums.c	\
diff -Naur gimp-2.8.14/app/core/mypaintbrush-brushsettings.c gimp-2.8.14-new/app/core/mypaintbrush-brushsettings.c
--- gimp-2.8.14/app/core/mypaintbrush-brushsettings.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/mypaintbrush-brushsettings.c	2015-01-27 17:48:55.320751583 +0800
@@ -0,0 +1,526 @@
+/*
+# brushlib - The MyPaint Brush Library
+# Copyright (C) 2007-2011 Martin Renold <martinxyz@gmx.ch>
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*/
+
+#include <glib-object.h>
+#include <cairo.h>
+#include "mypaintbrush-brushsettings.h"
+#include "mypaintbrush-enum-settings.h"
+
+#define None  0
+#define False FALSE
+#define True  TRUE
+#define _(x)  x
+
+static MyPaintBrushInputSettings inputs_list[] = {
+  /* # name, hard minimum, soft minimum, normal[1], soft maximum, hard maximum, displayed name, tooltip */
+  {"pressure", INPUT_PRESSURE, 0.0,  0.0,  0.4,  1.0, 1.0,  _("Pressure"), _("The pressure reported by the tablet, between 0.0 and 1.0. If you use the mouse, it will be 0.5 when a button is pressed and 0.0 otherwise.")},
+  {"speed1",  INPUT_SPEED1, None, 0.0,  0.5,  4.0, None, _("Fine speed"), _("How fast you currently move. This can change very quickly. Try \"print input values\" from the \"help\" menu to get a feeling for the range; negative values are rare but possible for very low speed.")},
+  {"speed2",  INPUT_SPEED2, None, 0.0,  0.5,  4.0, None, _("Gross speed"), _("Same as fine speed, but changes slower. Also look at the \"gross speed filter\" setting.")},
+  {"random",  INPUT_RANDOM, 0.0,  0.0,  0.5,  1.0, 1.0, _("Random"), _("Fast random noise, changing at each evaluation. Evenly distributed between 0 and 1.")},
+  {"stroke",  INPUT_STROKE,  0.0,  0.0,  0.5,  1.0, 1.0, _("Stroke"), _("This input slowly goes from zero to one while you draw a stroke. It can also be configured to jump back to zero periodically while you move. Look at the \"stroke duration\" and \"stroke hold time\" settings.")},
+  {"direction", INPUT_DIRECTION, 0.0,  0.0,  0.0,  360.0, 360.0, _("Direction"), _("The angle of the stroke, in degrees. The value will stay between 0.0 and 360.0, effectively ignoring turns of 180 degrees.")},
+  {"tilt_declination", INPUT_TILT_DECLINATION, 0.0,  0.0,  0.0,  90.0, 90.0,  _("Declination"), _("Declination of stylus tilt. 0 when stylus is parallel to tablet and 90.0 when it's perpendicular to tablet.")},
+  {"tilt_ascension", INPUT_TILT_ASCENSION, -180.0,  -180.0,  0.0,  180.0, 180.0, _("Ascension"),  _("Right ascension of stylus tilt. 0 when stylus working end points to you, +90 when rotated 90 degrees clockwise, -90 when rotated 90 degrees counterclockwise.")},
+  //{"motion_strength", INPUT_MOTION_STRENGTH, 0.0,0.0,  0.0,  1.0, 1.0,  "[EXPERIMENTAL} Same as angle, but wraps at 180 degrees. The dynamics are shared with BRUSH_OFFSET_BY_SPEED_FILTER (FIXME: which is a bad thing)."},
+  {"custom",    INPUT_CUSTOM, None,-2.0,  0.0, +2.0, None, _("Custom"), _("This is a user defined input. Look at the \"custom input\" setting for details.")},
+  {NULL}
+};
+    /*
+    # [1] If, for example, the user increases the "by pressure" slider
+    # in the "radius" control, then this should change the reaction to
+    # pressure and not the "normal" radius. To implement this, we need
+    # a guess what the user considers to be normal pressure.
+    */
+
+
+static MyPaintBrushSettings settings_list[] = {
+/*    # internal name, displayed name, constant, minimum, default, maximum, tooltip */
+  {"opaque", BRUSH_OPAQUE,  _("Opacity"), False, 0.0, 1.0, 2.0, _("0 means brush is transparent, 1 fully visible\n(also known as alpha or opacity)")},
+  {"opaque_multiply", BRUSH_OPAQUE_MULTIPLY, _("Opacity multiply"), False, 0.0, 0.0, 2.0, _("This gets multiplied with opaque. You should only change the pressure input of this setting. Use \"opaque\" instead to make opacity depend on speed.\nThis setting is responsible to stop painting when there is zero pressure. This is just a convention, the behaviour is identical to \"opaque\".")},
+  {"opaque_linearize", BRUSH_OPAQUE_LINEARIZE, _("Opacity linearize"), True, 0.0, 0.9, 2.0, _("Correct the nonlinearity introduced by blending multiple dabs on top of each other. This correction should get you a linear (\"natural\") pressure response when pressure is mapped to opaque_multiply, as it is usually done. 0.9 is good for standard strokes, set it smaller if your brush scatters a lot, or higher if you use dabs_per_second.\n0.0 the opaque value above is for the individual dabs\n1.0 the opaque value above is for the final brush stroke, assuming each pixel gets (dabs_per_radius*2) brushdabs on average during a stroke")},
+  {"radius_logarithmic", BRUSH_RADIUS_LOGARITHMIC, _("Radius"), False, -2.0, 2.0, 5.0, _("Basic brush radius (logarithmic)\n 0.7 means 2 pixels\n 3.0 means 20 pixels")},
+  {"hardness", BRUSH_HARDNESS, _("Hardness"), False, 0.0, 0.8, 1.0, _("Hard brush-circle borders (setting to zero will draw nothing). To reach the maximum hardness, you need to disable Anti-aliasing.")},
+  {"anti_aliasing", BRUSH_ANTI_ALIASING, _("Anti-aliasing"), False, 0.0, 1.0, 5.0, _("This setting decreases the hardness when necessary to prevent a pixel staircase effect.\n 0.0 disable (for very strong erasers and pixel brushes)\n 1.0 blur one pixel (good value)\n 5.0 notable blur, thin strokes will disappear")},
+  {"dabs_per_basic_radius", BRUSH_DABS_PER_BASIC_RADIUS, _("Dabs per basic radius"), True, 0.0, 0.0, 6.0, _("How many dabs to draw while the pointer moves a distance of one brush radius (more precise: the base value of the radius)")},
+  {"dabs_per_actual_radius", BRUSH_DABS_PER_ACTUAL_RADIUS, _("Dabs per actual radius"), True, 0.0, 2.0, 6.0, _("Same as above, but the radius actually drawn is used, which can change dynamically")},
+  {"dabs_per_second", BRUSH_DABS_PER_SECOND, _("Dabs per second"), True, 0.0, 0.0, 80.0, _("Dabs to draw each second, no matter how far the pointer moves")},
+  {"radius_by_random", BRUSH_RADIUS_BY_RANDOM, _("Radius by random"), False, 0.0, 0.0, 1.5, _("Alter the radius randomly each dab. You can also do this with the by_random input on the radius setting. If you do it here, there are two differences:\n1) the opaque value will be corrected such that a big-radius dabs is more transparent\n2) it will not change the actual radius seen by dabs_per_actual_radius")},
+  {"speed1_slowness", BRUSH_SPEED1_SLOWNESS, _("Fine speed filter"), False, 0.0, 0.04, 0.2, _("How slow the input fine speed is following the real speed\n0.0 change immediately as your speed changes (not recommended, but try it)")},
+  {"speed2_slowness", BRUSH_SPEED2_SLOWNESS, _("Gross speed filter"), False, 0.0, 0.8, 3.0, _("Same as \"fine speed filter\", but note that the range is different")},
+  {"speed1_gamma", BRUSH_SPEED1_GAMMA, _("Fine speed gamma"), True, -8.0, 4.0, 8.0, _("This changes the reaction of the \"fine speed\" input to extreme physical speed. You will see the difference best if \"fine speed\" is mapped to the radius.\n-8.0 very fast speed does not increase \"fine speed\" much more\n+8.0 very fast speed increases \"fine speed\" a lot\nFor very slow speed the opposite happens.")},
+  {"speed2_gamma", BRUSH_SPEED2_GAMMA, _("Gross speed gamma"), True, -8.0, 4.0, 8.0, _("Same as \"fine speed gamma\" for gross speed")},
+  {"offset_by_random", BRUSH_OFFSET_BY_RANDOM, _("Jitter"), False, 0.0, 0.0, 25.0, _("Add a random offset to the position where each dab is drawn\n 0.0 disabled\n 1.0 standard deviation is one basic radius away\n<0.0 negative values produce no jitter")},
+  {"offset_by_speed", BRUSH_OFFSET_BY_SPEED,  _("Offset by speed"), False, -3.0, 0.0, 3.0, _("Change position depending on pointer speed\n= 0 disable\n> 0 draw where the pointer moves to\n< 0 draw where the pointer comes from")},
+  {"offset_by_speed_slowness", BRUSH_OFFSET_BY_SPEED_SLOWNESS, _("Offset by speed filter"), False, 0.0, 1.0, 15.0, _("How slow the offset goes back to zero when the cursor stops moving")},
+  {"slow_tracking", BRUSH_SLOW_TRACKING, _("Slow position tracking"), True, 0.0, 0.0, 10.0, _("Slowdown pointer tracking speed. 0 disables it, higher values remove more jitter in cursor movements. Useful for drawing smooth, comic-like outlines.")},
+  {"slow_tracking_per_dab", BRUSH_SLOW_TRACKING_PER_DAB, _("Slow tracking per dab"), False, 0.0, 0.0, 10.0, _("Similar as above but at brushdab level (ignoring how much time has past, if brushdabs do not depend on time)")},
+  {"tracking_noise", BRUSH_TRACKING_NOISE, _("Tracking noise"), True, 0.0, 0.0, 12.0, _("Add randomness to the mouse pointer; this usually generates many small lines in random directions; maybe try this together with \"slow tracking\"")},
+
+  {"color_h", BRUSH_COLOR_H, _("Color hue"), True, 0.0, 0.0, 1.0, _("Color hue")},
+  {"color_s", BRUSH_COLOR_S, _("Color saturation"), True, -0.5, 0.0, 1.5, _("Color saturation")},
+  {"color_v", BRUSH_COLOR_V, _("Color value"), True, -0.5, 0.0, 1.5, _("Color value (brightness, intensity)")},
+  {"restore_color", BRUSH_RESTORE_COLOR, _("Save color"), True, 0.0, 0.0, 1.0, _("When selecting a brush, the color can be restored to the color that the brush was saved with.\n 0.0 do not modify the active color when selecting this brush\n 0.5 change active color towards brush color\n 1.0 set the active color to the brush color when selected")},
+  {"change_color_h", BRUSH_CHANGE_COLOR_H, _("Change color hue"), False, -2.0, 0.0, 2.0, _("Change color hue.\n-0.1 small clockwise color hue shift\n 0.0 disable\n 0.5 counterclockwise hue shift by 180 degrees")},
+  {"change_color_l", BRUSH_CHANGE_COLOR_L, _("Change color lightness (HSL)"), False, -2.0, 0.0, 2.0, _("Change the color lightness (luminance) using the HSL color model.\n-1.0 blacker\n 0.0 disable\n 1.0 whiter")},
+  {"change_color_hsl_s", BRUSH_CHANGE_COLOR_HSL_S, _("Change color satur. (HSL)"), False, -2.0, 0.0, 2.0, _("Change the color saturation using the HSL color model.\n-1.0 more grayish\n 0.0 disable\n 1.0 more saturated")},
+  {"change_color_v", BRUSH_CHANGE_COLOR_V, _("Change color value (HSV)"), False, -2.0, 0.0, 2.0, _("Change the color value (brightness, intensity) using the HSV color model. HSV changes are applied before HSL.\n-1.0 darker\n 0.0 disable\n 1.0 brigher")},
+  {"change_color_hsv_s", BRUSH_CHANGE_COLOR_HSV_S, _("Change color satur. (HSV)"), False, -2.0, 0.0, 2.0, _("Change the color saturation using the HSV color model. HSV changes are applied before HSL.\n-1.0 more grayish\n 0.0 disable\n 1.0 more saturated")},
+  {"smudge", BRUSH_SMUDGE, _("Smudge"), False, 0.0, 0.0, 1.0, _("Paint with the smudge color instead of the brush color. The smudge color is slowly changed to the color you are painting on.\n 0.0 do not use the smudge color\n 0.5 mix the smudge color with the brush color\n 1.0 use only the smudge color")},
+  {"smudge_length", BRUSH_SMUDGE_LENGTH, _("Smudge length"), False, 0.0, 0.5, 1.0, _("This controls how fast the smudge color becomes the color you are painting on.\n0.0 immediately update the smudge color (requires more CPU cycles because of the frequent color checks)\n0.5 change the smudge color steadily towards the canvas color\n1.0 never change the smudge color")},
+  {"smudge_radius_log", BRUSH_SMUDGE_RADIUS_LOG, _("Smudge radius"), False, -1.6, 0.0, 1.6, _("This modifies the radius of the circle where color is picked up for smudging.\n 0.0 use the brush radius\n-0.7 half the brush radius (fast, but not always intuitive)\n+0.7 twice the brush radius\n+1.6 five times the brush radius (slow performance)")},
+  {"eraser", BRUSH_ERASER, _("Eraser"), False, 0.0, 0.0, 1.0, _("how much this tool behaves like an eraser\n 0.0 normal painting\n 1.0 standard eraser\n 0.5 pixels go towards 50% transparency")},
+
+  {"stroke_threshold", BRUSH_STROKE_THRESHOLD, _("Stroke threshold"), True, 0.0, 0.0, 0.5, _("How much pressure is needed to start a stroke. This affects the stroke input only. Mypaint does not need a minimal pressure to start drawing.")},
+  {"stroke_duration_logarithmic", BRUSH_STROKE_DURATION_LOGARITHMIC, _("Stroke duration"), False, -1.0, 4.0, 7.0, _("How far you have to move until the stroke input reaches 1.0. This value is logarithmic (negative values will not inverse the process).")},
+  {"stroke_holdtime", BRUSH_STROKE_HOLDTIME, _("Stroke hold time"), False, 0.0, 0.0, 10.0, _("This defines how long the stroke input stays at 1.0. After that it will reset to 0.0 and start growing again, even if the stroke is not yet finished.\n2.0 means twice as long as it takes to go from 0.0 to 1.0\n9.9 and bigger stands for infinite")},
+  {"custom_input", BRUSH_CUSTOM_INPUT, _("Custom input"), False, -5.0, 0.0, 5.0, _("Set the custom input to this value. If it is slowed down, move it towards this value (see below). The idea is that you make this input depend on a mixture of pressure/speed/whatever, and then make other settings depend on this \"custom input\" instead of repeating this combination everywhere you need it.\nIf you make it change \"by random\" you can generate a slow (smooth) random input.")},
+  {"custom_input_slowness", BRUSH_CUSTOM_INPUT_SLOWNESS, _("Custom input filter"), False, 0.0, 0.0, 10.0, _("How slow the custom input actually follows the desired value (the one above). This happens at brushdab level (ignoring how much time has past, if brushdabs do not depend on time).\n0.0 no slowdown (changes apply instantly)")},
+
+  {"elliptical_dab_ratio", BRUSH_ELLIPTICAL_DAB_RATIO, _("Elliptical dab: ratio"), False, 1.0, 1.0, 10.0, _("Aspect ratio of the dabs; must be >= 1.0, where 1.0 means a perfectly round dab. TODO: linearize? start at 0.0 maybe, or log?")},
+  {"elliptical_dab_angle", BRUSH_ELLIPTICAL_DAB_ANGLE, _("Elliptical dab: angle"), False, 0.0, 90.0, 360.0, _("Angle by which elliptical dabs are tilted\n 0.0 horizontal dabs\n 45.0 45 degrees, turned clockwise\n 180.0 horizontal again")},
+  {"direction_filter", BRUSH_DIRECTION_FILTER, _("Direction filter"), False, 0.0, 2.0, 10.0, _("A low value will make the direction input adapt more quickly, a high value will make it smoother")},
+
+  {"lock_alpha", BRUSH_LOCK_ALPHA, _("Lock alpha"), False, 0.0, 0.0, 1.0, _("Do not modify the alpha channel of the layer (paint only where there is paint already)\n 0.0 normal painting\n 0.5 half of the paint gets applied normally\n 1.0 alpha channel fully locked")},
+  {"stroke_opacity", BRUSH_STROKE_OPACITY, _("Stroke opacity"), True, 0.0, 1.0, 1.0, _("Opacity applied for whole stroke. meaningful only when non-incremental mode is enabled.\n") },
+  {"texture_grain", BRUSH_TEXTURE_GRAIN, _("Texture grain level"), False, -1.0, 0.0, 1.0, _("Grain level applied for texture mapping.")},
+  {"texture_contrast", BRUSH_TEXTURE_CONTRAST, _("Texture contrast level"), False, 0.0, 1.0, 1.0, _("Contrast level applied for texture mapping.")},
+  {NULL}
+};
+
+static MyPaintBrushSwitchSettings switches_list[] = {
+  {"non_incremental", BRUSH_NON_INCREMENTAL, _("Non-incremental painting mode."), FALSE },
+  {"use_gimp_brushmark", BRUSH_USE_GIMP_BRUSHMARK, _("Use GIMP brush for brushmark."), TRUE },
+  {"use_gimp_texture", BRUSH_USE_GIMP_TEXTURE, _("Use GIMP pattern for texture."), FALSE },
+  {NULL}
+};
+
+static MyPaintBrushTextSettings text_list[] = {
+  {"brushmark", BRUSH_BRUSHMARK_NAME, _("Brushmark name"), NULL},
+  {NULL}
+};
+
+struct _MypaintBrushSettingGroupInternal {
+  gchar                          *name;
+  MypaintBrushSettingGroupID  index;
+  gchar                          *display_name;
+  gchar                         **setting_list;
+};
+typedef struct _MypaintBrushSettingGroupInternal MypaintBrushSettingGroupInternal;
+
+static gchar* basic_group_list[] = {
+    "radius_logarithmic", 
+    "radius_by_random", 
+    "hardness", 
+    "anti_aliasing", 
+    "eraser", 
+    "offset_by_random", 
+    "elliptical_dab_angle", 
+    "elliptical_dab_ratio", 
+    "direction_filter",
+    NULL};
+static gchar* opacity_group_list[] = { 
+    "opaque", 
+    "opaque_multiply", 
+    "opaque_linearize", 
+    "lock_alpha",
+    NULL};
+static gchar* dabs_group_list[] = {
+    "dabs_per_basic_radius",
+    "dabs_per_actual_radius",
+    "dabs_per_second",
+    "use_gimp_brushmark",
+    NULL};
+static gchar* smudge_group_list[] = {
+    "smudge", 
+    "smudge_length", 
+    "smudge_radius_log",
+    NULL};
+static gchar* speed_group_list[] = { 
+    "speed1_slowness", 
+    "speed2_slowness", 
+    "speed1_gamma", 
+    "speed2_gamma", 
+    "offset_by_speed", 
+    "offset_by_speed_slowness",
+    NULL};
+static gchar* tracking_group_list[] = {
+    "slow_tracking", 
+    "slow_tracking_per_dab",
+    "tracking_noise" };
+static gchar* stroke_group_list[] = {
+    "stroke_threshold", 
+    "stroke_duration_logarithmic", 
+    "stroke_holdtime", 
+    "non_incremental",
+    "stroke_opacity",
+    NULL};
+static gchar* texture_group_list[] = {
+    "use_gimp_texture", 
+    "texture_grain",
+    "texture_contrast",
+    NULL};
+static gchar* color_group_list[] = {
+    "change_color_h", 
+    "change_color_l",
+    "change_color_hsl_s",
+    "change_color_v",
+    "change_color_hsv_s",
+    "restore_color",
+    "colorize",
+    NULL};
+static gchar* custom_group_list[] = {
+    "custom_input",
+    "custom_input_slowness",
+    NULL};
+
+
+static MypaintBrushSettingGroupInternal group_list[] = {
+  {"basic", BRUSH_SETTING_GROUP_BASIC, _("Basic"), basic_group_list},
+  {"opacity", BRUSH_SETTING_GROUP_OPACITY, _("Opacity"), opacity_group_list},
+  {"dabs",  BRUSH_SETTING_GROUP_DABS, _("Dabs"), dabs_group_list},
+  {"smudge", BRUSH_SETTING_GROUP_SMUDGE, _("Smudge"), smudge_group_list},
+  {"speed", BRUSH_SETTING_GROUP_SPEED, _("Speed"), speed_group_list},
+  {"tracking", BRUSH_SETTING_GROUP_TRACKING, _("Tracking"), tracking_group_list},
+  {"stroke",  BRUSH_SETTING_GROUP_TRACKING, _("Stroke"), stroke_group_list},
+  {"color", BRUSH_SETTING_GROUP_COLOR, _("Color"), color_group_list},
+  {"texture", BRUSH_SETTING_GROUP_TEXTURE, _("Texture"), texture_group_list},
+  {"custom", BRUSH_SETTING_GROUP_CUSTOM, _("Custom"), custom_group_list},
+  {NULL}
+};
+
+static gfloat transform_change_color_h (gfloat y) { return y*64.0/360.0; }
+static gfloat transform_change_color_hsv_s (gfloat y) { return y*128.0/256.0; }
+static gfloat transform_change_color_v (gfloat y) { return y*128.0/256.0; }
+
+MyPaintBrushSettingMigrate migration[] = {
+  {"color_hue", "change_color_h", transform_change_color_h},
+  {"color_saturation", "change_color_hsv_s", transform_change_color_hsv_s},
+  {"color_value", "change_color_v", transform_change_color_v},
+  {"speed_slowness", "speed1_slowness", NULL},
+  {"change_color_s", "change_color_hsv_s", NULL},
+  {"stroke_treshold", "stroke_threshold", NULL},
+  {NULL}
+};
+
+#if 0
+settings_hidden = "color_h color_s color_v".split()
+
+// the states are not (yet?) exposed to the user
+// WARNING: only append to this list, for compatibility of replay files (brush.get_state() in stroke.py)
+gchar* states_list[] = {
+// lowlevel
+"x", "y",
+"pressure",
+"dist",              // "distance" moved since last dab, a new dab is drawn at 1.0
+"actual_radius",     // used by count_dabs_to, thus a state!
+
+"smudge_ra", "smudge_ga", "smudge_ba", "smudge_a",  // smudge color stored with premultiplied alpha (low-pass filtered)
+"last_getcolor_r", "last_getcolor_g", "last_getcolor_b", "last_getcolor_a", // cached result of last call to get_color()
+"last_getcolor_recentness",
+
+"actual_x", "actual_y",  // for slow position
+"norm_dx_slow", "norm_dy_slow", // note: now this is dx/dt * (1/radius)
+
+"norm_speed1_slow", "norm_speed2_slow",
+
+"stroke", "stroke_started", // stroke_started is used as boolean
+
+"custom_input",
+"rng_seed",
+
+"actual_elliptical_dab_ratio", "actual_elliptical_dab_angle", // used by count_dabs_to
+
+"direction_dx", "direction_dy",
+"declination", "ascension"
+};
+
+settings_visible = [s for s in settings if s.cname not in settings_hidden}
+
+states = []
+for line in states_list.split("\n"):
+    line = line.split("#")[0}
+    for cname in line.split(","):
+        cname = cname.strip()
+        if not cname: continue
+        st = BrushState()
+        st.cname = cname
+        st.index = len(states)
+        states.append(st)
+#endif
+
+
+static GList*      brush_input_settings_list    = NULL;
+static GHashTable* brush_input_settings_dict    = NULL;
+static GList*      brush_settings_list          = NULL;
+static GHashTable* brush_settings_dict          = NULL;
+static GList*      brush_setting_migrate_list   = NULL;
+static GHashTable* brush_setting_migrate_dict   = NULL;
+static GHashTable* brush_setting_group_dict     = NULL;
+static GList*      brush_setting_group_list     = NULL;
+static GList*      brush_switch_settings_list   = NULL;
+static GHashTable* brush_switch_settings_dict   = NULL;
+static GList*      brush_text_settings_list     = NULL;
+static GHashTable* brush_text_settings_dict     = NULL;
+
+static GHashTable* index_to_name_dict           = NULL;
+
+GList *
+mypaint_brush_get_input_settings (void)
+{
+  GList *result = NULL;
+  MyPaintBrushInputSettings *input = inputs_list;
+  for (; input->name; input ++)
+    {
+      result = g_list_append (result, input);
+    }
+  return result;
+}
+
+GHashTable *mypaint_brush_get_input_settings_dict (void)
+{
+  if (!brush_input_settings_dict) {
+    MyPaintBrushInputSettings *setting = inputs_list;
+    brush_input_settings_dict = g_hash_table_new (g_str_hash, g_str_equal);
+    for (; setting->name; setting ++)
+    {
+      g_hash_table_insert (brush_input_settings_dict, setting->name, setting);
+    }
+  }
+  g_hash_table_ref(brush_input_settings_dict);
+  return brush_input_settings_dict;
+}
+
+GList *
+mypaint_brush_get_brush_settings (void)
+{
+  GList *result = NULL;
+  MyPaintBrushSettings *setting = settings_list;
+  for (; setting->internal_name; setting ++)
+    {
+      result = g_list_append (result, setting);
+    }
+  return result;
+}
+
+GHashTable *mypaint_brush_get_brush_settings_dict (void)
+{
+  if (!brush_settings_dict) {
+    MyPaintBrushSettings *setting = settings_list;
+    brush_settings_dict = g_hash_table_new (g_str_hash, g_str_equal);
+    for (; setting->internal_name; setting ++)
+    {
+      g_hash_table_insert (brush_settings_dict, setting->internal_name, setting);
+    }
+    g_hash_table_ref (brush_settings_dict);
+  }
+  g_hash_table_ref (brush_settings_dict);
+  
+  return brush_settings_dict;
+}
+
+GList *
+mypaint_brush_get_brush_switch_settings (void)
+{
+  GList *result = NULL;
+  MyPaintBrushSwitchSettings *setting = switches_list;
+  for (; setting->internal_name; setting ++)
+    {
+      result = g_list_append (result, setting);
+    }
+  return result;
+}
+
+GHashTable *mypaint_brush_get_brush_switch_settings_dict (void)
+{
+  if (!brush_switch_settings_dict) {
+    MyPaintBrushSwitchSettings *setting = switches_list;
+    brush_switch_settings_dict = g_hash_table_new (g_str_hash, g_str_equal);
+    for (; setting->internal_name; setting ++)
+    {
+      g_hash_table_insert (brush_switch_settings_dict, setting->internal_name, setting);
+    }
+    g_hash_table_ref (brush_switch_settings_dict);
+  }
+  g_hash_table_ref (brush_switch_settings_dict);
+  
+  return brush_switch_settings_dict;
+}
+
+
+GList *
+mypaint_brush_get_brush_text_settings (void)
+{
+  GList *result = NULL;
+  MyPaintBrushTextSettings *setting = text_list;
+  for (; setting->internal_name; setting ++)
+    {
+      result = g_list_append (result, setting);
+    }
+  return result;
+}
+
+GHashTable *mypaint_brush_get_brush_text_settings_dict (void)
+{
+  if (!brush_text_settings_dict) {
+    MyPaintBrushTextSettings *setting = text_list;
+    brush_text_settings_dict = g_hash_table_new (g_str_hash, g_str_equal);
+    for (; setting->internal_name; setting ++)
+    {
+      g_hash_table_insert (brush_text_settings_dict, setting->internal_name, setting);
+    }
+    g_hash_table_ref (brush_text_settings_dict);
+  }
+  g_hash_table_ref (brush_text_settings_dict);
+  
+  return brush_text_settings_dict;
+}
+
+
+GHashTable *mypaint_brush_get_setting_migrate_dict (void)
+{
+  if (!brush_setting_migrate_dict) {
+    MyPaintBrushSettingMigrate *setting = migration;
+    brush_setting_migrate_dict = g_hash_table_new (g_str_hash, g_str_equal);
+    for (; setting->old_name; setting ++)
+    {
+      g_hash_table_insert (brush_setting_migrate_dict, setting->old_name, setting);
+    }
+    g_hash_table_ref (brush_setting_migrate_dict);
+  }
+  g_hash_table_ref (brush_setting_migrate_dict);
+  return brush_setting_migrate_dict;
+}
+
+GHashTable *mypaint_brush_get_setting_group_dict (void)
+{
+  gchar** name;
+  if (!brush_setting_group_dict) {
+    MypaintBrushSettingGroupInternal* group = group_list;
+    GHashTable* settings_dict = mypaint_brush_get_brush_settings_dict ();
+    GHashTable* switches_dict = mypaint_brush_get_brush_switch_settings_dict();
+    GHashTable* text_dict     = mypaint_brush_get_brush_text_settings_dict ();
+    brush_setting_group_dict = g_hash_table_new (g_str_hash, g_str_equal);
+    for (; group->name; group ++)
+    {
+      MypaintBrushSettingGroup* group_entry = g_new0(MypaintBrushSettingGroup, 1);
+      group_entry->name = group->name;
+      group_entry->index = group->index;
+      group_entry->display_name = group->display_name;
+      group_entry->setting_list = NULL;
+
+      for (name = group->setting_list; *name; name ++) {
+        MyPaintBrushSettingEntry* entry;
+        gpointer setting;
+        entry = g_new0(MyPaintBrushSettingEntry, 1);
+        setting = g_hash_table_lookup (settings_dict, *name);
+        if (!setting)
+          setting = g_hash_table_lookup (switches_dict, *name);
+        if (!setting)
+            setting = g_hash_table_lookup (text_dict, *name);
+        
+        if (setting) {
+          entry->ptr  = setting;
+          entry->type = mypaint_brush_get_prop_type(*name);
+          group_entry->setting_list = g_list_append (group_entry->setting_list, entry);
+        } else {
+          g_print("BrushSettingGroup::NOT_FOUND::%s\n", *name);
+          }
+        }
+
+      g_hash_table_insert (brush_setting_group_dict, group->name, group_entry);
+    }
+    g_hash_table_unref(settings_dict);
+    g_hash_table_unref(switches_dict);
+    g_hash_table_unref(text_dict);  
+
+    g_hash_table_ref (brush_setting_group_dict);
+  }
+
+  g_hash_table_ref (brush_setting_group_dict);
+
+  return brush_setting_group_dict;
+}
+
+GList *mypaint_brush_get_setting_group_list (void)
+{
+  MypaintBrushSettingGroupInternal* group = group_list;
+  GHashTable* brush_setting_group_dict = mypaint_brush_get_setting_group_dict();
+  GList* result = NULL;
+  for (; group->name; group ++)
+  {
+    MypaintBrushSettingGroup* setting_list = 
+      (MypaintBrushSettingGroup*)g_hash_table_lookup(brush_setting_group_dict, group->name);
+    result = g_list_append (result, setting_list);
+  }
+  g_hash_table_unref(brush_setting_group_dict);
+
+  return result;
+}
+
+gchar* mypaint_brush_internal_name_to_signal_name (const gchar* name)
+{
+  gchar* result = g_strdup(name);
+  g_strcanon(result,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-",'-');
+  return result;
+}
+
+gchar* mypaint_brush_signal_name_to_internal_name (const gchar* name)
+{
+  gchar* result = g_strdup(name);
+  g_strcanon(result,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_",'_');
+  return result;
+}
+
+GType mypaint_brush_get_prop_type (const gchar* name)
+{
+  GType       result      = G_TYPE_NONE;
+  GHashTable* switch_dict = mypaint_brush_get_brush_switch_settings_dict();
+  GHashTable* text_dict   = mypaint_brush_get_brush_text_settings_dict();
+  GHashTable* float_dict  = mypaint_brush_get_brush_settings_dict();
+
+  if (g_hash_table_lookup(switch_dict, name)) {
+    result = G_TYPE_BOOLEAN;
+  } else if (g_hash_table_lookup(text_dict, name)) {
+    result = G_TYPE_STRING;
+  } else if (g_hash_table_lookup(float_dict, name)) {
+    result = G_TYPE_DOUBLE;
+  }
+  g_hash_table_unref(switch_dict);
+  g_hash_table_unref(text_dict);
+  g_hash_table_unref(float_dict);
+  return result;
+}
+
+gchar* mypaint_brush_settings_index_to_internal_name(int index)
+{
+  if (!index_to_name_dict) {
+    MyPaintBrushSettings* s1;
+    MyPaintBrushSwitchSettings* s2;
+    MyPaintBrushTextSettings* s3;
+    index_to_name_dict = g_hash_table_new(g_direct_hash, g_direct_equal);
+    for (s1 = settings_list; s1->internal_name; s1 ++) {
+      g_hash_table_insert(index_to_name_dict, (gpointer)(s1->index), s1->internal_name);
+    }
+    for (s2 = switches_list; s2->internal_name; s2 ++) {
+      g_hash_table_insert(index_to_name_dict, (gpointer)(s2->index), s2->internal_name);
+    }
+    for (s3 = text_list; s3->internal_name; s3 ++) {
+      g_hash_table_insert(index_to_name_dict, (gpointer)(s3->index), s3->internal_name);
+    }
+  }
+  return (gchar*)g_hash_table_lookup(index_to_name_dict, (gpointer)index);
+}
diff -Naur gimp-2.8.14/app/core/mypaintbrush-brushsettings.h gimp-2.8.14-new/app/core/mypaintbrush-brushsettings.h
--- gimp-2.8.14/app/core/mypaintbrush-brushsettings.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/mypaintbrush-brushsettings.h	2015-01-27 17:48:55.321751583 +0800
@@ -0,0 +1,104 @@
+#ifndef __MYPAINTBRUSH_BRUSHSETTINGS_H__
+#define __MYPAINTBRUSH_BRUSHSETTINGS_H__
+
+#include <glib.h>
+
+struct _MyPaintBrushInputSettings {
+  gchar   *name;
+  gint    index;
+  gfloat  hard_minimum;
+  gfloat  soft_minimum;
+  gfloat  normal;
+  gfloat  soft_maximum;
+  gfloat  hard_maximum;
+  gchar  *displayed_name;
+  gchar  *tooltip;  
+};
+typedef struct _MyPaintBrushInputSettings MyPaintBrushInputSettings;
+
+enum _MypaintBrushSettingGroupID {
+  BRUSH_SETTING_GROUP_BASIC,
+  BRUSH_SETTING_GROUP_OPACITY,
+  BRUSH_SETTING_GROUP_DABS,
+  BRUSH_SETTING_GROUP_SMUDGE,
+  BRUSH_SETTING_GROUP_SPEED,
+  BRUSH_SETTING_GROUP_TRACKING,
+  BRUSH_SETTING_GROUP_STROKE,
+  BRUSH_SETTING_GROUP_COLOR,
+  BRUSH_SETTING_GROUP_TEXTURE,
+  BRUSH_SETTING_GROUP_CUSTOM
+};
+typedef enum _MypaintBrushSettingGroupID MypaintBrushSettingGroupID;
+
+struct _MypaintBrushSettingGroup {
+  gchar                          *name;
+  MypaintBrushSettingGroupID      index;
+  gchar                          *display_name;
+  GList                          *setting_list;
+};
+typedef struct _MypaintBrushSettingGroup MypaintBrushSettingGroup;
+
+struct _MyPaintBrushSettings {
+  gchar    *internal_name;
+  gint      index;
+  gchar    *displayed_name;
+  gboolean  constant;
+  gfloat    minimum;
+  gfloat    default_value;
+  gfloat    maximum;
+  gchar    *tooltip;
+};
+typedef struct _MyPaintBrushSettings MyPaintBrushSettings;
+
+struct _MyPaintBrushSwitchSettings {
+  gchar    *internal_name;
+  gint      index;
+  gchar    *displayed_name;
+  gboolean  default_value;
+};
+typedef struct _MyPaintBrushSwitchSettings MyPaintBrushSwitchSettings;
+
+struct _MyPaintBrushTextSettings {
+  gchar    *internal_name;
+  gint      index;
+  gchar    *displayed_name;
+  gchar    *default_value;
+};
+typedef struct _MyPaintBrushTextSettings MyPaintBrushTextSettings;
+
+struct _MyPaintBrushSettingMigrate {
+  gchar *old_name;
+  gchar *new_name;
+  gfloat (*transform)(gfloat y);
+};
+typedef struct _MyPaintBrushSettingMigrate MyPaintBrushSettingMigrate;
+
+struct _MyPaintBrushSettingEntry {
+  GType  type;
+  union {
+    MyPaintBrushSettings       *f;
+    MyPaintBrushSwitchSettings *b;
+    MyPaintBrushTextSettings   *t;
+    gpointer                    ptr;
+  };
+};
+typedef struct _MyPaintBrushSettingEntry MyPaintBrushSettingEntry;
+
+GList *mypaint_brush_get_brush_settings (void);
+GList *mypaint_brush_get_brush_switch_settings (void);
+GList *mypaint_brush_get_brush_text_settings (void);
+GList *mypaint_brush_get_input_settings (void);
+GHashTable *mypaint_brush_get_brush_settings_dict (void);
+GHashTable *mypaint_brush_get_brush_switch_settings_dict (void);
+GHashTable *mypaint_brush_get_brush_text_settings_dict (void);
+GHashTable *mypaint_brush_get_input_settings_dict (void);
+GHashTable *mypaint_brush_get_setting_migrate_dict (void);
+GHashTable *mypaint_brush_get_setting_group_dict (void);
+GList *mypaint_brush_get_setting_group_list (void);
+
+gchar* mypaint_brush_internal_name_to_signal_name (const gchar* name);
+gchar* mypaint_brush_signal_name_to_internal_name (const gchar* signal);
+
+GType mypaint_brush_get_prop_type (const gchar* name);
+gchar* mypaint_brush_settings_index_to_internal_name(int index);
+#endif
diff -Naur gimp-2.8.14/app/core/mypaintbrush-enum-settings.h gimp-2.8.14-new/app/core/mypaintbrush-enum-settings.h
--- gimp-2.8.14/app/core/mypaintbrush-enum-settings.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/mypaintbrush-enum-settings.h	2015-01-27 17:48:55.322751583 +0800
@@ -0,0 +1,112 @@
+// DO NOT EDIT - autogenerated by generate.py
+
+#ifndef __MYPAINTBRUSH_ENUM_SETTINGS_H__
+#define __MYPAINTBRUSH_ENUM_SETTINGS_H__
+
+#define INPUT_PRESSURE 0
+#define INPUT_SPEED1 1
+#define INPUT_SPEED2 2
+#define INPUT_RANDOM 3
+#define INPUT_STROKE 4
+#define INPUT_DIRECTION 5
+#define INPUT_TILT_DECLINATION 6
+#define INPUT_TILT_ASCENSION 7
+#define INPUT_CUSTOM 8
+#define INPUT_COUNT 9
+
+#define BRUSH_MAPPING_BASE 0
+#define BRUSH_OPAQUE 0
+#define BRUSH_OPAQUE_MULTIPLY 1
+#define BRUSH_OPAQUE_LINEARIZE 2
+#define BRUSH_RADIUS_LOGARITHMIC 3
+#define BRUSH_HARDNESS 4
+#define BRUSH_ANTI_ALIASING 5
+#define BRUSH_DABS_PER_BASIC_RADIUS 6
+#define BRUSH_DABS_PER_ACTUAL_RADIUS 7
+#define BRUSH_DABS_PER_SECOND 8
+#define BRUSH_RADIUS_BY_RANDOM 9
+#define BRUSH_SPEED1_SLOWNESS 10
+#define BRUSH_SPEED2_SLOWNESS 11
+#define BRUSH_SPEED1_GAMMA 12
+#define BRUSH_SPEED2_GAMMA 13
+#define BRUSH_OFFSET_BY_RANDOM 14
+#define BRUSH_OFFSET_BY_SPEED 15
+#define BRUSH_OFFSET_BY_SPEED_SLOWNESS 16
+#define BRUSH_SLOW_TRACKING 17
+#define BRUSH_SLOW_TRACKING_PER_DAB 18
+#define BRUSH_TRACKING_NOISE 19
+#define BRUSH_COLOR_H 20
+#define BRUSH_COLOR_S 21
+#define BRUSH_COLOR_V 22
+#define BRUSH_RESTORE_COLOR 23
+#define BRUSH_CHANGE_COLOR_H 24
+#define BRUSH_CHANGE_COLOR_L 25
+#define BRUSH_CHANGE_COLOR_HSL_S 26
+#define BRUSH_CHANGE_COLOR_V 27
+#define BRUSH_CHANGE_COLOR_HSV_S 28
+#define BRUSH_SMUDGE 29
+#define BRUSH_SMUDGE_LENGTH 30
+#define BRUSH_SMUDGE_RADIUS_LOG 31
+#define BRUSH_ERASER 32
+#define BRUSH_STROKE_THRESHOLD 33
+#define BRUSH_STROKE_DURATION_LOGARITHMIC 34
+#define BRUSH_STROKE_HOLDTIME 35
+#define BRUSH_CUSTOM_INPUT 36
+#define BRUSH_CUSTOM_INPUT_SLOWNESS 37
+#define BRUSH_ELLIPTICAL_DAB_RATIO 38
+#define BRUSH_ELLIPTICAL_DAB_ANGLE 39
+#define BRUSH_DIRECTION_FILTER 40
+#define BRUSH_LOCK_ALPHA 41
+#define BRUSH_STROKE_OPACITY 42
+#define BRUSH_TEXTURE_GRAIN 43
+#define BRUSH_TEXTURE_CONTRAST 44
+#define BRUSH_MAPPING_END         45
+#define BRUSH_MAPPING_COUNT       BRUSH_MAPPING_END
+
+#define BRUSH_BOOL_BASE           BRUSH_MAPPING_END
+#define BRUSH_NON_INCREMENTAL    (BRUSH_BOOL_BASE + 0)
+#define BRUSH_USE_GIMP_BRUSHMARK (BRUSH_BOOL_BASE + 1)
+#define BRUSH_USE_GIMP_TEXTURE   (BRUSH_BOOL_BASE + 2)
+#define BRUSH_BOOL_END           (BRUSH_BOOL_BASE + 3)
+#define BRUSH_BOOL_COUNT         (BRUSH_BOOL_END - BRUSH_BOOL_BASE)
+
+#define BRUSH_TEXT_BASE           BRUSH_BOOL_END
+#define BRUSH_BRUSHMARK_NAME     (BRUSH_TEXT_BASE + 0)
+#define BRUSH_TEXT_END           (BRUSH_TEXT_BASE + 1)
+#define BRUSH_TEXT_COUNT         (BRUSH_TEXT_END - BRUSH_TEXT_BASE)
+
+#define BRUSH_SETTINGS_COUNT BRUSH_TEXT_END
+
+#define STATE_X 0
+#define STATE_Y 1
+#define STATE_PRESSURE 2
+#define STATE_DIST 3
+#define STATE_ACTUAL_RADIUS 4
+#define STATE_SMUDGE_RA 5
+#define STATE_SMUDGE_GA 6
+#define STATE_SMUDGE_BA 7
+#define STATE_SMUDGE_A 8
+#define STATE_LAST_GETCOLOR_R 9
+#define STATE_LAST_GETCOLOR_G 10
+#define STATE_LAST_GETCOLOR_B 11
+#define STATE_LAST_GETCOLOR_A 12
+#define STATE_LAST_GETCOLOR_RECENTNESS 13
+#define STATE_ACTUAL_X 14
+#define STATE_ACTUAL_Y 15
+#define STATE_NORM_DX_SLOW 16
+#define STATE_NORM_DY_SLOW 17
+#define STATE_NORM_SPEED1_SLOW 18
+#define STATE_NORM_SPEED2_SLOW 19
+#define STATE_STROKE 20
+#define STATE_STROKE_STARTED 21
+#define STATE_CUSTOM_INPUT 22
+#define STATE_RNG_SEED 23
+#define STATE_ACTUAL_ELLIPTICAL_DAB_RATIO 24
+#define STATE_ACTUAL_ELLIPTICAL_DAB_ANGLE 25
+#define STATE_DIRECTION_DX 26
+#define STATE_DIRECTION_DY 27
+#define STATE_DECLINATION 28
+#define STATE_ASCENSION 29
+#define STATE_COUNT 30
+
+#endif
diff -Naur gimp-2.8.14/app/core/mypaintbrush-mapping.hpp gimp-2.8.14-new/app/core/mypaintbrush-mapping.hpp
--- gimp-2.8.14/app/core/mypaintbrush-mapping.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/core/mypaintbrush-mapping.hpp	2015-01-27 17:48:55.323751583 +0800
@@ -0,0 +1,176 @@
+/* brushlib - The MyPaint Brush Library
+ * Copyright (C) 2007-2008 Martin Renold <martinxyz@gmx.ch>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __MYPAINTBRUSH_MAPPING_H__
+#define __MYPAINTBRUSH_MAPPING_H__
+
+#define assert g_assert
+
+// user-defined mappings
+// (the curves you can edit in the brush settings)
+
+class Mapping {
+private:
+  typedef struct {
+    // a set of control points (stepwise linear)
+    float xvalues[8];
+    float yvalues[8];
+    int n;
+  } ControlPoints;
+
+  int inputs;
+  ControlPoints * pointsList; // one for each input
+  int inputs_used; // optimization
+public:
+  float base_value;
+
+  Mapping(int inputs_) {
+    inputs = inputs_;
+    pointsList = new ControlPoints[inputs];
+    for (int i=0; i<inputs; i++) pointsList[i].n = 0;
+    inputs_used = 0;
+    base_value = 0;
+  }
+  ~Mapping() {
+    delete pointsList;
+  }
+  Mapping& operator = (const Mapping& rhs) {
+    if (pointsList) {
+      delete pointsList;
+      pointsList = NULL;
+    }
+    inputs = rhs.inputs;
+    pointsList = new ControlPoints[inputs];
+    for (int i = 0; i < inputs; i ++) {
+      pointsList[i].n = rhs.pointsList[i].n;
+      for (int j = 0; j < pointsList[i].n; j++) {
+        pointsList[i].xvalues[j] = rhs.pointsList[i].xvalues[j];
+        pointsList[i].yvalues[j] = rhs.pointsList[i].yvalues[j];
+      }
+    }
+    base_value = rhs.base_value;
+    inputs_used = rhs.inputs_used;
+    return *this;
+  }
+
+  void set_n (int input, int n)
+  {
+    assert (input >= 0 && input < inputs);
+    assert (n >= 0 && n <= 8);
+    assert (n != 1); // cannot build a linear mapping with only one point
+    ControlPoints * p = pointsList + input;
+
+    if (n != 0 && p->n == 0) inputs_used++;
+    if (n == 0 && p->n != 0) inputs_used--;
+    assert(inputs_used >= 0);
+    assert(inputs_used <= inputs);
+
+    p->n = n;
+  }
+
+  int get_n (int input)
+  {
+    assert (input >= 0 && input < inputs);
+    ControlPoints * p = pointsList + input;
+    return p->n;
+  }
+
+  void set_point (int input, int index, float x, float y)
+  {
+    assert (input >= 0 && input < inputs);
+    assert (index >= 0 && index < 8);
+    ControlPoints * p = pointsList + input;
+    assert (index < p->n);
+
+    if (index > 0) {
+      assert (x >= p->xvalues[index-1]);
+    }
+
+    p->xvalues[index] = x;
+    p->yvalues[index] = y;
+  }
+
+  void get_point (int input, int index, float *x, float *y)
+  {
+    assert (input >= 0 && input < inputs);
+    assert (index >= 0 && index < 8);
+    ControlPoints * p = pointsList + input;
+    assert (index < p->n);
+    
+    *x = p->xvalues[index];
+    *y = p->yvalues[index];
+  }
+
+  bool is_constant()
+  {
+    return inputs_used == 0;
+  }
+
+  float calculate (float * data)
+  {
+    int j;
+    float result;
+    result = base_value;
+
+    // constant mapping (common case)
+    if (inputs_used == 0) return result;
+
+    for (j=0; j<inputs; j++) {
+      ControlPoints * p = pointsList + j;
+
+      if (p->n) {
+        float x, y;
+        x = data[j];
+
+        // find the segment with the slope that we need to use
+        float x0, y0, x1, y1;
+        x0 = p->xvalues[0];
+        y0 = p->yvalues[0];
+        x1 = p->xvalues[1];
+        y1 = p->yvalues[1];
+
+        int i;
+        for (i=2; i<p->n && x>x1; i++) {
+          x0 = x1;
+          y0 = y1;
+          x1 = p->xvalues[i];
+          y1 = p->yvalues[i];
+        }
+
+        if (x0 == x1) {
+          y = y0;
+        } else {
+          // linear interpolation
+          y = (y1*(x - x0) + y0*(x1 - x)) / (x1 - x0);
+        }
+
+        result += y;
+      }
+    }
+    return result;
+  }
+
+  // used in python for the global pressure mapping
+  float calculate_single_input (float input)
+  {
+    assert(inputs == 1);
+    return calculate(&input);
+  }
+};
+
+#undef assert
+
+#endif
diff -Naur gimp-2.8.14/app/dialogs/dialogs.c gimp-2.8.14-new/app/dialogs/dialogs.c
--- gimp-2.8.14/app/dialogs/dialogs.c	2015-01-27 17:28:36.773833817 +0800
+++ gimp-2.8.14-new/app/dialogs/dialogs.c	2015-01-27 17:48:55.326751583 +0800
@@ -330,6 +330,8 @@
             GIMP_HELP_DOCUMENT_DIALOG, GIMP_VIEW_SIZE_LARGE),
   LISTGRID (template, N_("Templates"), N_("Image Templates"), GIMP_STOCK_TEMPLATE,
             GIMP_HELP_TEMPLATE_DIALOG, GIMP_VIEW_SIZE_SMALL),
+  LISTGRID (mypaint_brush, N_("Mypaint Brushes"), NULL, GIMP_STOCK_BRUSH,
+            GIMP_HELP_MYPAINT_BRUSH_DIALOG, GIMP_VIEW_SIZE_MEDIUM),
 
   /* Some things do not have grids, so just list */
   LIST (dynamics, dynamics, N_("Paint Dynamics"), NULL, GIMP_STOCK_DYNAMICS,
@@ -404,6 +406,10 @@
             N_("Tool Preset Editor"), NULL, GIMP_STOCK_TOOL_PRESET,
             GIMP_HELP_TOOL_PRESET_EDITOR_DIALOG,
             dialogs_tool_preset_editor_get, 0, TRUE),
+  DOCKABLE ("gimp-mypaint-brush-editor",
+            N_("Mypaint Brush Editor"), NULL, GIMP_STOCK_MYPAINT_BRUSH,
+            GIMP_HELP_MYPAINT_BRUSH_EDITOR_DIALOG,
+            dialogs_mypaint_brush_editor_get, 0, TRUE),
 
   /*  image windows  */
   IMAGE_WINDOW ("gimp-empty-image-window",
diff -Naur gimp-2.8.14/app/dialogs/dialogs-constructors.c gimp-2.8.14-new/app/dialogs/dialogs-constructors.c
--- gimp-2.8.14/app/dialogs/dialogs-constructors.c	2015-01-27 17:28:36.758833818 +0800
+++ gimp-2.8.14-new/app/dialogs/dialogs-constructors.c	2015-01-27 17:48:55.324751583 +0800
@@ -31,6 +31,7 @@
 
 #include "widgets/gimpbrusheditor.h"
 #include "widgets/gimpbrushfactoryview.h"
+#include "widgets/gimpmypaintbrushfactoryview.h"
 #include "widgets/gimpbufferview.h"
 #include "widgets/gimpchanneltreeview.h"
 #include "widgets/gimpcoloreditor.h"
@@ -60,6 +61,7 @@
 #include "widgets/gimptoolpreseteditor.h"
 #include "widgets/gimpundoeditor.h"
 #include "widgets/gimpvectorstreeview.h"
+#include "widgets/gimpmypaintbrusheditor.h"
 
 #include "display/gimpcursorview.h"
 #include "display/gimpnavigationeditor.h"
@@ -419,6 +421,19 @@
 }
 
 GtkWidget *
+dialogs_mypaint_brush_list_view_new (GimpDialogFactory *factory,
+                             GimpContext       *context,
+                             GimpUIManager     *ui_manager,
+                             gint               view_size)
+{
+  return gimp_mypaint_brush_factory_view_new (GIMP_VIEW_TYPE_LIST,
+                                      context->gimp->mypaint_brush_factory,
+                                      context,
+                                      view_size, 1,
+                                      gimp_dialog_factory_get_menu_factory (factory));
+}
+
+GtkWidget *
 dialogs_buffer_list_view_new (GimpDialogFactory *factory,
                               GimpContext       *context,
                               GimpUIManager     *ui_manager,
@@ -559,6 +574,19 @@
 }
 
 GtkWidget *
+dialogs_mypaint_brush_grid_view_new (GimpDialogFactory *factory,
+                             GimpContext       *context,
+                             GimpUIManager     *ui_manager,
+                             gint               view_size)
+{
+  return gimp_mypaint_brush_factory_view_new (GIMP_VIEW_TYPE_GRID,
+                                      context->gimp->mypaint_brush_factory,
+                                      context,
+                                      view_size, 1,
+                                      gimp_dialog_factory_get_menu_factory (factory));
+}
+
+GtkWidget *
 dialogs_buffer_grid_view_new (GimpDialogFactory *factory,
                               GimpContext       *context,
                               GimpUIManager     *ui_manager,
@@ -775,3 +803,14 @@
   return gimp_tool_preset_editor_new (context,
                                       gimp_dialog_factory_get_menu_factory (factory));
 }
+
+GtkWidget *
+dialogs_mypaint_brush_editor_get (GimpDialogFactory *factory,
+                          GimpContext       *context,
+                          GimpUIManager     *ui_manager,
+                          gint               view_size)
+{
+  return gimp_mypaint_brush_editor_new (context,
+                                         gimp_dialog_factory_get_menu_factory (factory));
+}
+
diff -Naur gimp-2.8.14/app/dialogs/dialogs-constructors.h gimp-2.8.14-new/app/dialogs/dialogs-constructors.h
--- gimp-2.8.14/app/dialogs/dialogs-constructors.h	2015-01-27 17:28:36.760833818 +0800
+++ gimp-2.8.14-new/app/dialogs/dialogs-constructors.h	2015-01-27 17:48:55.325751583 +0800
@@ -151,6 +151,10 @@
                                             GimpContext       *context,
                                             GimpUIManager     *ui_manager,
                                             gint               view_size);
+GtkWidget * dialogs_mypaint_brush_list_view_new    (GimpDialogFactory *factory,
+                                            GimpContext       *context,
+                                            GimpUIManager     *ui_manager,
+                                            gint               view_size);
 GtkWidget * dialogs_buffer_list_view_new   (GimpDialogFactory *factory,
                                             GimpContext       *context,
                                             GimpUIManager     *ui_manager,
@@ -193,6 +197,10 @@
                                             GimpContext       *context,
                                             GimpUIManager     *ui_manager,
                                             gint               view_size);
+GtkWidget * dialogs_mypaint_brush_grid_view_new    (GimpDialogFactory *factory,
+                                            GimpContext       *context,
+                                            GimpUIManager     *ui_manager,
+                                            gint               view_size);
 GtkWidget * dialogs_buffer_grid_view_new   (GimpDialogFactory *factory,
                                             GimpContext       *context,
                                             GimpUIManager     *ui_manager,
@@ -273,5 +281,9 @@
                                             GimpContext       *context,
                                             GimpUIManager     *ui_manager,
                                             gint               view_size);
+GtkWidget * dialogs_mypaint_brush_editor_get (GimpDialogFactory *factory,
+                                            GimpContext       *context,
+                                            GimpUIManager     *ui_manager,
+                                            gint               view_size);
 
 #endif /* __DIALOGS_CONSTRUCTORS_H__ */
diff -Naur gimp-2.8.14/app/display/gimpcanvaspath.c gimp-2.8.14-new/app/display/gimpcanvaspath.c
--- gimp-2.8.14/app/display/gimpcanvaspath.c	2015-01-27 17:28:36.967833804 +0800
+++ gimp-2.8.14-new/app/display/gimpcanvaspath.c	2015-01-27 17:48:55.327751583 +0800
@@ -35,6 +35,7 @@
 #include "gimpdisplayshell.h"
 #include "gimpdisplayshell-style.h"
 #include "gimpdisplayshell-transform.h"
+#include "gimpdisplayshell-rotate.h"
 
 
 enum
@@ -232,6 +233,7 @@
   if (private->path)
     {
       cairo_save (cr);
+      gimp_display_shell_set_cairo_rotate(shell, cr);
       cairo_translate (cr, -shell->offset_x, -shell->offset_y);
       cairo_scale (cr, shell->scale_x, shell->scale_y);
       cairo_translate (cr, private->x, private->y);
@@ -261,6 +263,7 @@
       cr = gdk_cairo_create (gtk_widget_get_window (shell->canvas));
 
       cairo_save (cr);
+      gimp_display_shell_set_cairo_rotate(shell, cr);
       cairo_translate (cr, -shell->offset_x, -shell->offset_y);
       cairo_scale (cr, shell->scale_x, shell->scale_y);
       cairo_translate (cr, private->x, private->y);
diff -Naur gimp-2.8.14/app/display/gimpcanvasrectangle.c gimp-2.8.14-new/app/display/gimpcanvasrectangle.c
--- gimp-2.8.14/app/display/gimpcanvasrectangle.c	2015-01-27 17:28:36.972833803 +0800
+++ gimp-2.8.14-new/app/display/gimpcanvasrectangle.c	2015-01-27 17:48:55.328751583 +0800
@@ -31,6 +31,7 @@
 #include "gimpcanvasrectangle.h"
 #include "gimpdisplayshell.h"
 #include "gimpdisplayshell-transform.h"
+#include "gimpdisplayshell-rotate.h"
 
 
 enum
@@ -200,32 +201,47 @@
 static void
 gimp_canvas_rectangle_transform (GimpCanvasItem   *item,
                                  GimpDisplayShell *shell,
-                                 gdouble          *x,
-                                 gdouble          *y,
-                                 gdouble          *w,
-                                 gdouble          *h)
+                                 gdouble          *x1,
+                                 gdouble          *y1,
+                                 gdouble          *x2,
+                                 gdouble          *y2,
+                                 gdouble          *x3,
+                                 gdouble          *y3,
+                                 gdouble          *x4,
+                                 gdouble          *y4)
 {
   GimpCanvasRectanglePrivate *private = GET_PRIVATE (item);
-  gdouble                     x1, y1;
-  gdouble                     x2, y2;
 
   gimp_display_shell_transform_xy_f (shell,
                                      MIN (private->x,
                                           private->x + private->width),
                                      MIN (private->y,
                                           private->y + private->height),
-                                     &x1, &y1);
+                                     x1, y1);
+  gimp_display_shell_transform_xy_f (shell,
+                                     MAX (private->x,
+                                          private->x + private->width),
+                                     MIN (private->y,
+                                          private->y + private->height),
+                                     x2, y2);
+  gimp_display_shell_transform_xy_f (shell,
+                                     MIN (private->x,
+                                          private->x + private->width),
+                                     MAX (private->y,
+                                          private->y + private->height),
+                                     x3, y3);
   gimp_display_shell_transform_xy_f (shell,
                                      MAX (private->x,
                                           private->x + private->width),
                                      MAX (private->y,
                                           private->y + private->height),
-                                     &x2, &y2);
+                                     x4, y4);
 
-  x1 = floor (x1);
-  y1 = floor (y1);
-  x2 = ceil (x2);
-  y2 = ceil (y2);
+#if 0
+  *x1 = floor (*x1);
+  *y1 = floor (*y1);
+  *x2 = ceil (*x2);
+  *y2 = ceil (*y2);
 
   if (private->filled)
     {
@@ -244,6 +260,7 @@
       *w = MAX (0.0, *w);
       *h = MAX (0.0, *h);
     }
+#endif
 }
 
 static void
@@ -252,12 +269,19 @@
                             cairo_t          *cr)
 {
   GimpCanvasRectanglePrivate *private = GET_PRIVATE (item);
-  gdouble                     x, y;
-  gdouble                     w, h;
-
-  gimp_canvas_rectangle_transform (item, shell, &x, &y, &w, &h);
-
-  cairo_rectangle (cr, x, y, w, h);
+  gdouble x1, y1;
+  gdouble x2, y2;
+  gdouble x3, y3;
+  gdouble x4, y4;
+
+  gimp_canvas_rectangle_transform (item, shell, &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);
+
+//  cairo_rectangle (cr, x, y, w, h);
+  cairo_move_to(cr, x1, y1);
+  cairo_line_to(cr, x2, y2);
+  cairo_line_to(cr, x4, y4);
+  cairo_line_to(cr, x3, y3);
+  cairo_close_path(cr);
 
   if (private->filled)
     _gimp_canvas_item_fill (item, cr);
@@ -273,8 +297,12 @@
   cairo_rectangle_int_t       rectangle;
   gdouble                     x, y;
   gdouble                     w, h;
+  gdouble x1, y1, x2, y2, x3, y3, x4, y4;
 
-  gimp_canvas_rectangle_transform (item, shell, &x, &y, &w, &h);
+  gimp_canvas_rectangle_transform (item, shell, &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);
+  gimp_display_shell_get_extents(x1, y1, x2, y2, x3, y3, x4, y4, &x, &y, &w, &h);
+  w -= x;
+  h -= y;
 
   if (private->filled)
     {
diff -Naur gimp-2.8.14/app/display/gimpdisplay.c gimp-2.8.14-new/app/display/gimpdisplay.c
--- gimp-2.8.14/app/display/gimpdisplay.c	2015-01-27 17:28:36.967833804 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplay.c	2015-01-27 17:48:55.328751583 +0800
@@ -400,6 +400,7 @@
   GimpImageWindow    *window = NULL;
   GimpDisplayShell   *shell;
 
+  g_print("gimp_display_new:image=%lx\n", image);
   g_return_val_if_fail (GIMP_IS_GIMP (gimp), NULL);
   g_return_val_if_fail (image == NULL || GIMP_IS_IMAGE (image), NULL);
 
@@ -467,6 +468,8 @@
   /* add the display to the list */
   gimp_container_add (gimp->displays, GIMP_OBJECT (display));
 
+  g_print("gimp_display_new:return %lx\n", display);
+
   return display;
 }
 
@@ -549,15 +552,18 @@
 gimp_display_close (GimpDisplay *display)
 {
   g_return_if_fail (GIMP_IS_DISPLAY (display));
-
+#if 0
   if (gimp_container_get_n_children (display->gimp->displays) > 1)
     {
+#endif
       gimp_display_delete (display);
+#if 0
     }
   else
     {
       gimp_display_empty (display);
     }
+#endif
 }
 
 gint
@@ -880,14 +886,21 @@
   x2 = CLAMP (x + w, 0, image_width);
   y2 = CLAMP (y + h, 0, image_height);
 
+  x1_f = x1;
+  y1_f = y1;
+  x2_f = x2;
+  y2_f = y2;
+
+  /*  display the area  */
+  gimp_display_shell_transform_region (shell, &x1_f, &y1_f, &x2_f, &y2_f);
+
+#if 0
   x = x1;
   y = y1;
   w = (x2 - x1);
   h = (y2 - y1);
+#endif
 
-  /*  display the area  */
-  gimp_display_shell_transform_xy_f (shell, x,     y,     &x1_f, &y1_f);
-  gimp_display_shell_transform_xy_f (shell, x + w, y + h, &x2_f, &y2_f);
 
   /*  make sure to expose a superset of the transformed sub-pixel expose
    *  area, not a subset. bug #126942. --mitch
@@ -899,6 +912,7 @@
   y1 = floor (y1_f - 0.5);
   x2 = ceil (x2_f + 0.5);
   y2 = ceil (y2_f + 0.5);
+//  g_print("expose_area: %d,%d,%d,%d\n", x1, y1, x2, y2);
 
   gimp_display_shell_expose_area (shell, x1, y1, x2 - x1, y2 - y1);
 }
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell.c gimp-2.8.14-new/app/display/gimpdisplayshell.c
--- gimp-2.8.14/app/display/gimpdisplayshell.c	2015-01-27 17:28:36.962833804 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell.c	2015-01-27 17:48:55.337751582 +0800
@@ -98,6 +98,8 @@
   SCALED,
   SCROLLED,
   RECONNECT,
+  ROTATED,
+  MIRRORED,
   LAST_SIGNAL
 };
 
@@ -214,6 +216,24 @@
                   gimp_marshal_VOID__VOID,
                   G_TYPE_NONE, 0);
 
+  display_shell_signals[ROTATED] =
+    g_signal_new ("rotated",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GimpDisplayShellClass, rotated),
+                  NULL, NULL,
+                  gimp_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+
+  display_shell_signals[MIRRORED] =
+    g_signal_new ("mirrored",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GimpDisplayShellClass, mirrored),
+                  NULL, NULL,
+                  gimp_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+
   object_class->constructed        = gimp_display_shell_constructed;
   object_class->dispose            = gimp_display_shell_dispose;
   object_class->finalize           = gimp_display_shell_finalize;
@@ -227,6 +247,8 @@
   klass->scaled                    = gimp_display_shell_real_scaled;
   klass->scrolled                  = NULL;
   klass->reconnect                 = NULL;
+  klass->rotated                   = NULL;
+  klass->mirrored                  = NULL;
 
   g_object_class_install_property (object_class, PROP_POPUP_MANAGER,
                                    g_param_spec_object ("popup-manager",
@@ -290,6 +312,9 @@
   shell->y_dest_inc  = 1;
   shell->x_src_dec   = 1;
   shell->y_src_dec   = 1;
+  shell->rotate_angle = 0;
+
+  shell->mirrored    = FALSE;
 
   shell->render_surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
                                                       GIMP_DISPLAY_RENDER_BUF_WIDTH,
@@ -1482,6 +1507,48 @@
 }
 
 void
+gimp_display_shell_rotated (GimpDisplayShell *shell)
+{
+  GList *list;
+
+  g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
+
+  for (list = shell->children; list; list = g_list_next (list))
+    {
+      GtkWidget *child = list->data;
+      gdouble    x, y;
+
+      gimp_display_shell_transform_overlay (shell, child, &x, &y);
+
+      gimp_overlay_box_set_child_position (GIMP_OVERLAY_BOX (shell->canvas),
+                                           child, x, y);
+    }
+
+  g_signal_emit (shell, display_shell_signals[ROTATED], 0);
+}
+
+void
+gimp_display_shell_mirrored (GimpDisplayShell *shell)
+{
+  GList *list;
+
+  g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
+
+  for (list = shell->children; list; list = g_list_next (list))
+    {
+      GtkWidget *child = list->data;
+      gdouble    x, y;
+
+      gimp_display_shell_transform_overlay (shell, child, &x, &y);
+
+      gimp_overlay_box_set_child_position (GIMP_OVERLAY_BOX (shell->canvas),
+                                           child, x, y);
+    }
+
+  g_signal_emit (shell, display_shell_signals[MIRRORED], 0);
+}
+
+void
 gimp_display_shell_set_unit (GimpDisplayShell *shell,
                              GimpUnit          unit)
 {
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-callbacks.c gimp-2.8.14-new/app/display/gimpdisplayshell-callbacks.c
--- gimp-2.8.14/app/display/gimpdisplayshell-callbacks.c	2015-01-27 17:28:36.974833803 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-callbacks.c	2015-01-27 17:48:55.329751583 +0800
@@ -497,10 +497,11 @@
 
   image_region = gdk_region_copy (eevent->region);
 
-  gdk_region_subtract (image_region, clear_region);
-  gdk_region_destroy (clear_region);
+//  gdk_region_subtract (image_region, clear_region);
+//  gdk_region_destroy (clear_region);
 
-  if (! gdk_region_empty (image_region))
+//  g_print("hit test\n");
+//  if (! gdk_region_empty (image_region))
     {
       cairo_save (cr);
       gimp_display_shell_draw_checkerboard (shell, cr,
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-draw.c gimp-2.8.14-new/app/display/gimpdisplayshell-draw.c
--- gimp-2.8.14/app/display/gimpdisplayshell-draw.c	2015-01-27 17:28:36.962833804 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-draw.c	2015-01-27 17:48:55.330751583 +0800
@@ -41,6 +41,7 @@
 #include "gimpdisplayshell.h"
 #include "gimpdisplayshell-draw.h"
 #include "gimpdisplayshell-render.h"
+#include "gimpdisplayshell-rotate.h"
 #include "gimpdisplayshell-scale.h"
 #include "gimpdisplayshell-scroll.h"
 #include "gimpdisplayshell-style.h"
@@ -117,6 +118,7 @@
   g_return_if_fail (cr != NULL);
   g_return_if_fail (segs != NULL && n_segs > 0);
 
+  gimp_display_shell_set_cairo_rotate(shell, cr);
   gimp_display_shell_set_selection_out_style (shell, cr);
 
   gimp_cairo_add_segments (cr, segs, n_segs);
@@ -133,6 +135,7 @@
   g_return_if_fail (cr != NULL);
   g_return_if_fail (mask != NULL);
 
+  gimp_display_shell_set_cairo_rotate(shell, cr);
   gimp_display_shell_set_selection_in_style (shell, cr, index);
 
   cairo_mask (cr, mask);
@@ -146,15 +149,46 @@
                                gint              w,
                                gint              h)
 {
-  gint x2, y2;
+  gdouble x1, y1, x2, y2;
+  gdouble user_coord[4][2];
+  gint disp_xoffset, disp_yoffset;
   gint i, j;
 
   g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
   g_return_if_fail (gimp_display_get_image (shell->display));
   g_return_if_fail (cr != NULL);
 
-  x2 = x + w;
-  y2 = y + h;
+  gimp_display_shell_scroll_get_disp_offset (shell,
+                                             &disp_xoffset,
+                                             &disp_yoffset);
+
+  x1 = x - 1;
+  y1 = y - 1;
+  x2 = x + w + 1;
+  y2 = y + h + 1;
+
+  gimp_display_shell_get_image_bouding_box_for_device_coords(shell, cr, &x1, &y1, &x2, &y2);
+
+//  x  = CLAMP(x,  -shell->offset_x, shell->disp_width  + 1);
+//  y  = CLAMP(y,  -shell->offset_y, shell->disp_height + 1);
+//  x2 = CLAMP(x2, -shell->offset_x, shell->disp_width  + 1);
+//  y2 = CLAMP(y2, -shell->offset_y, shell->disp_height + 1);
+  x1 = MAX(x1, -shell->offset_x);
+  y1 = MAX(y1, -shell->offset_y);
+  x2 = MAX(x2, -shell->offset_x);
+  y2 = MAX(y2, -shell->offset_y);
+
+  x1 = floor(x1 - 0.5);
+  y1 = floor(y1 - 0.5);
+  x2 = ceil(x2 + 0.5);
+  y2 = ceil(y2 + 0.5);
+
+  w = x2 - x1;
+  h = y2 - y1;
+  x = x1;
+  y = y1;
+
+//  g_print("draw: %d,%d,%d,%d: ofs=%d,%d: bound=%d,%d\n", x, y, x + w, y + h, disp_xoffset, disp_yoffset, shell->disp_width, shell->disp_height);
 
   /*  display the image in RENDER_BUF_WIDTH x RENDER_BUF_HEIGHT
    *  sized chunks
@@ -163,16 +197,11 @@
     {
       for (j = x; j < x2; j += GIMP_DISPLAY_RENDER_BUF_WIDTH)
         {
-          gint disp_xoffset, disp_yoffset;
           gint dx, dy;
 
           dx = MIN (x2 - j, GIMP_DISPLAY_RENDER_BUF_WIDTH);
           dy = MIN (y2 - i, GIMP_DISPLAY_RENDER_BUF_HEIGHT);
 
-          gimp_display_shell_scroll_get_disp_offset (shell,
-                                                     &disp_xoffset,
-                                                     &disp_yoffset);
-
           gimp_display_shell_render (shell, cr,
                                      j - disp_xoffset,
                                      i - disp_yoffset,
@@ -213,16 +242,23 @@
                                       gint              w,
                                       gint              h)
 {
+  gint disp_xoffset, disp_yoffset;
+  
   g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
   g_return_if_fail (cr != NULL);
 
+  gimp_display_shell_scroll_get_disp_offset (shell,
+                                             &disp_xoffset, &disp_yoffset);
+
   if (G_UNLIKELY (! shell->checkerboard))
     shell->checkerboard = gimp_display_shell_create_checkerboard (shell, cr);
 
+  gimp_display_shell_set_cairo_rotate(shell, cr);
+
   cairo_rectangle (cr, x, y, w, h);
   cairo_clip (cr);
 
-  cairo_translate (cr, - shell->offset_x, - shell->offset_y);
+//  cairo_translate (cr, - shell->offset_x, - shell->offset_y);
   cairo_set_source (cr, shell->checkerboard);
   cairo_paint (cr);
 }
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-expose.c gimp-2.8.14-new/app/display/gimpdisplayshell-expose.c
--- gimp-2.8.14/app/display/gimpdisplayshell-expose.c	2015-01-27 17:28:36.965833804 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-expose.c	2015-01-27 17:48:55.330751583 +0800
@@ -74,4 +74,6 @@
   g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
 
   gtk_widget_queue_draw (shell->canvas);
+  shell->accum_error_x = 0;
+  shell->accum_error_y = 0;
 }
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-expose.h gimp-2.8.14-new/app/display/gimpdisplayshell-expose.h
--- gimp-2.8.14/app/display/gimpdisplayshell-expose.h	2015-01-27 17:28:36.967833804 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-expose.h	2015-01-27 17:48:55.331751582 +0800
@@ -24,6 +24,11 @@
                                          gint                y,
                                          gint                w,
                                          gint                h);
+void   gimp_display_shell_expose_area_transformed (GimpDisplayShell *shell,
+                                                   gint              x,
+                                                   gint              y,
+                                                   gint              w,
+                                                   gint              h);
 void   gimp_display_shell_expose_region (GimpDisplayShell   *shell,
                                          cairo_region_t     *region);
 void   gimp_display_shell_expose_full   (GimpDisplayShell   *shell);
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell.h gimp-2.8.14-new/app/display/gimpdisplayshell.h
--- gimp-2.8.14/app/display/gimpdisplayshell.h	2015-01-27 17:28:36.969833804 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell.h	2015-01-27 17:48:55.338751582 +0800
@@ -64,12 +64,14 @@
 
   GimpUnit           unit;
 
-  gint               offset_x;         /*  offset of display image            */
-  gint               offset_y;
+  gdouble            offset_x;         /*  offset of display image            */
+  gdouble            offset_y;
 
   gdouble            scale_x;          /*  horizontal scale factor            */
   gdouble            scale_y;          /*  vertical scale factor              */
 
+  gdouble            rotate_angle;
+
   gdouble            monitor_xres;
   gdouble            monitor_yres;
   gboolean           dot_for_dot;      /*  ignore monitor resolution          */
@@ -182,9 +184,19 @@
   const gchar       *space_shaded_tool;
 
   gboolean           scrolling;
-  gint               scroll_start_x;
-  gint               scroll_start_y;
+  gdouble            scroll_start_x;
+  gdouble            scroll_start_y;
   gpointer           scroll_info;
+  gdouble            accum_error_x;
+  gdouble            accum_error_y;
+
+  gboolean           rotating;
+  gdouble            rotate_start_angle;
+
+  gboolean           scaling;
+  gdouble            scaling_start_distance;
+
+  gboolean           mirrored;
 
   GimpDrawable      *mask;
   GimpRGB            mask_color;
@@ -201,6 +213,8 @@
   void (* scaled)    (GimpDisplayShell *shell);
   void (* scrolled)  (GimpDisplayShell *shell);
   void (* reconnect) (GimpDisplayShell *shell);
+  void (* rotated)   (GimpDisplayShell *shell);
+  void (* mirrored)  (GimpDisplayShell *shell);
 };
 
 
@@ -243,6 +257,8 @@
 
 void              gimp_display_shell_scaled        (GimpDisplayShell   *shell);
 void              gimp_display_shell_scrolled      (GimpDisplayShell   *shell);
+void              gimp_display_shell_rotated       (GimpDisplayShell   *shell);
+void              gimp_display_shell_mirrored      (GimpDisplayShell   *shell);
 
 void              gimp_display_shell_set_unit      (GimpDisplayShell   *shell,
                                                     GimpUnit            unit);
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-render.c gimp-2.8.14-new/app/display/gimpdisplayshell-render.c
--- gimp-2.8.14/app/display/gimpdisplayshell-render.c	2015-01-27 17:28:36.970833804 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-render.c	2015-01-27 17:48:55.332751582 +0800
@@ -20,6 +20,7 @@
 #include <gegl.h>
 #include <gtk/gtk.h>
 
+#include "libgimpmath/gimpmath.h"
 #include "libgimpcolor/gimpcolor.h"
 #include "libgimpwidgets/gimpwidgets.h"
 
@@ -39,6 +40,7 @@
 #include "gimpdisplayshell.h"
 #include "gimpdisplayshell-filter.h"
 #include "gimpdisplayshell-render.h"
+#include "gimpdisplayshell-rotate.h"
 #include "gimpdisplayshell-scroll.h"
 
 
@@ -137,10 +139,14 @@
   GimpImageType   type;
   gint            level;
   gboolean        premult;
+  gint            image_w, image_h;
+  gint            render_start_x, render_start_y;
 
   g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
   g_return_if_fail (cr != NULL);
-  g_return_if_fail (w > 0 && h > 0);
+
+  if (w <= 0 || h <= 0)
+    return;
 
   image = gimp_display_get_image (shell->display);
   projection = gimp_image_get_projection (image);
@@ -151,6 +157,24 @@
 
   tiles = gimp_projection_get_tiles_at_level (projection, level, &premult);
 
+  gimp_display_shell_scroll_get_render_start_offset (shell, 
+                                                     &render_start_x,
+                                                     &render_start_y);
+  
+  image_w = SCALEX(shell, gimp_image_get_width(image)) - render_start_x;
+  image_h = SCALEY(shell, gimp_image_get_height(image)) - render_start_y;
+
+  if (x > image_w || y > image_h)
+    return;
+
+  w = CLAMP(w, 0, image_w - x + 1);
+  h = CLAMP(h, 0, image_h - y + 1);
+
+  if (w == 0 || h == 0)
+    return;
+
+//  w += 1;
+//  h += 1;
   gimp_display_shell_render_info_init (&info,
                                        shell, x, y, w, h,
                                        shell->render_surface,
@@ -217,17 +241,18 @@
   /*  put it to the screen  */
   {
     gint disp_xoffset, disp_yoffset;
+    gimp_display_shell_scroll_get_disp_offset (shell,
+                                               &disp_xoffset, &disp_yoffset);
 
     cairo_save (cr);
 
-    gimp_display_shell_scroll_get_disp_offset (shell,
-                                               &disp_xoffset, &disp_yoffset);
+    gimp_display_shell_set_cairo_rotate (shell, cr);
 
     cairo_rectangle (cr, x + disp_xoffset, y + disp_yoffset, w, h);
     cairo_clip (cr);
-
     cairo_set_source_surface (cr, shell->render_surface,
                               x + disp_xoffset, y + disp_yoffset);
+
     cairo_paint (cr);
 
     if (shell->mask)
@@ -371,7 +396,8 @@
   gint offset_y;
 
   gimp_display_shell_scroll_get_render_start_offset (shell,
-						     &offset_x, &offset_y);
+                                                     &offset_x, 
+                                                     &offset_y);
 
   info->x = x + offset_x;
   info->y = y + offset_y;
@@ -642,6 +668,8 @@
   guint         source_width;
   guint         source_height;
 
+//  g_print("render_image_tile_fault@ %d, %d\n", info->src_x, info->src_y);
+
   source_width  = tile_manager_width (info->src_tiles);
   source_height = tile_manager_height (info->src_tiles);
 
@@ -724,7 +752,8 @@
                                    info->src_x - 1, info->src_y - 1,
                                    TRUE, FALSE);
 
-  g_return_val_if_fail (tile[4] != NULL, tile_buf);
+  if (tile[4] == NULL)
+    goto done;
 
   src[4] = tile_data_pointer (tile[4], info->src_x, info->src_y);
 
@@ -1126,7 +1155,8 @@
   tile[2] = tile_manager_get_tile (info->src_tiles,
                                    info->src_x - 1, info->src_y, TRUE, FALSE);
 
-  g_return_val_if_fail (tile[0] != NULL, tile_buf);
+  if (tile[0] == NULL)
+    goto done;
 
   src[4] = tile_data_pointer (tile[0], info->src_x, info->src_y);
   src[7] = tile_data_pointer (tile[0], info->src_x, info->src_y + 1);
@@ -1377,7 +1407,8 @@
   tile = tile_manager_get_tile (info->src_tiles,
                                 info->src_x, info->src_y, TRUE, FALSE);
 
-  g_return_val_if_fail (tile != NULL, tile_buf);
+  if (tile == NULL)
+    goto done;
 
   src = tile_data_pointer (tile, info->src_x, info->src_y);
 
@@ -1469,8 +1500,9 @@
         }
     }
   while (--width);
-
-  tile_release (tile, FALSE);
+  done:
+  if (tile)
+    tile_release (tile, FALSE);
 
   return tile_buf;
 }
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-rotate.c gimp-2.8.14-new/app/display/gimpdisplayshell-rotate.c
--- gimp-2.8.14/app/display/gimpdisplayshell-rotate.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-rotate.c	2015-01-27 17:48:55.333751582 +0800
@@ -0,0 +1,232 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <gegl.h>
+#include <gtk/gtk.h>
+#include <math.h>
+
+#include "libgimpcolor/gimpcolor.h"
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "display-types.h"
+
+#include "base/tile-manager.h"
+#include "base/tile.h"
+
+#include "config/gimpdisplayconfig.h"
+
+#include "core/gimpdrawable.h"
+#include "core/gimpimage.h"
+#include "core/gimppickable.h"
+#include "core/gimpprojection.h"
+
+#include "gimpdisplay.h"
+#include "gimpdisplayshell.h"
+#include "gimpdisplayshell-rotate.h"
+#include "gimpdisplayshell-transform.h"
+
+void
+gimp_display_shell_set_cairo_rotate (const GimpDisplayShell *shell,
+                                     cairo_t          *cr)
+{
+  gdouble cx, cy;
+
+  g_return_if_fail (shell != NULL);
+  g_return_if_fail (cr != NULL);
+  
+  cx = shell->disp_width / 2;
+  cy = shell->disp_height / 2;
+
+  cairo_translate (cr, cx, cy);
+  if (shell->mirrored)
+    cairo_scale(cr, -1, 1);
+  cairo_rotate (cr, shell->rotate_angle / 180.0 * M_PI);
+  cairo_translate (cr, -cx, -cy);
+}
+
+void
+gimp_display_shell_get_device_bouding_box_for_image_coords
+                                     (const GimpDisplayShell *shell,
+                                      cairo_t                 *cr,
+                                      gdouble                 *x1,
+                                      gdouble                 *y1,
+                                      gdouble                 *x2,
+                                      gdouble                 *y2)
+{
+  gdouble user_coord[4][2];
+
+  g_return_if_fail (shell != NULL);
+  g_return_if_fail (cr != NULL);
+  
+  if (shell->rotate_angle == 0.0 && !shell->mirrored)
+    return;
+
+  cairo_save(cr);
+  gimp_display_shell_set_cairo_rotate(shell, cr);
+
+  user_coord[0][0] = *x1;
+  user_coord[0][1] = *y1;
+
+  user_coord[1][0] = *x2;
+  user_coord[1][1] = *y1;
+
+  user_coord[2][0] = *x1;
+  user_coord[2][1] = *y2;
+
+  user_coord[3][0] = *x2;
+  user_coord[3][1] = *y2;
+
+  cairo_user_to_device(cr, user_coord[0], user_coord[0] + 1);
+  cairo_user_to_device(cr, user_coord[1], user_coord[1] + 1);
+  cairo_user_to_device(cr, user_coord[2], user_coord[2] + 1);
+  cairo_user_to_device(cr, user_coord[3], user_coord[3] + 1);
+
+  gimp_display_shell_get_extents(user_coord[0][0], user_coord[0][1],
+                                 user_coord[1][0], user_coord[1][1],
+                                 user_coord[2][0], user_coord[2][1],
+                                 user_coord[3][0], user_coord[3][1],
+                                 x1, y1, x2, y2);
+
+  cairo_restore(cr);
+}
+
+void
+gimp_display_shell_get_image_bouding_box_for_device_coords
+                                     (const GimpDisplayShell *shell,
+                                      cairo_t                 *cr,
+                                      gdouble                 *x1,
+                                      gdouble                 *y1,
+                                      gdouble                 *x2,
+                                      gdouble                 *y2)
+{
+  gdouble user_coord[4][2];
+
+  g_return_if_fail (shell != NULL);
+  g_return_if_fail (cr != NULL);
+  
+  if (shell->rotate_angle == 0.0 && !shell->mirrored)
+    return;
+
+  cairo_save(cr);
+  gimp_display_shell_set_cairo_rotate(shell, cr);
+
+  user_coord[0][0] = *x1;
+  user_coord[0][1] = *y1;
+
+  user_coord[1][0] = *x2;
+  user_coord[1][1] = *y1;
+
+  user_coord[2][0] = *x1;
+  user_coord[2][1] = *y2;
+
+  user_coord[3][0] = *x2;
+  user_coord[3][1] = *y2;
+
+  cairo_device_to_user(cr, user_coord[0], user_coord[0] + 1);
+  cairo_device_to_user(cr, user_coord[1], user_coord[1] + 1);
+  cairo_device_to_user(cr, user_coord[2], user_coord[2] + 1);
+  cairo_device_to_user(cr, user_coord[3], user_coord[3] + 1);
+
+  gimp_display_shell_get_extents(user_coord[0][0], user_coord[0][1],
+                                 user_coord[1][0], user_coord[1][1],
+                                 user_coord[2][0], user_coord[2][1],
+                                 user_coord[3][0], user_coord[3][1],
+                                 x1, y1, x2, y2);
+
+  cairo_restore(cr);
+}
+
+void
+gimp_display_shell_transform_region (const GimpDisplayShell *shell,
+                                     gdouble                 *x1,
+                                     gdouble                 *y1,
+                                     gdouble                 *x2,
+                                     gdouble                 *y2)
+{
+  gdouble user_coord[4][2];
+  gint i;
+  
+  user_coord[0][0] = *x1;
+  user_coord[0][1] = *y1;
+
+  user_coord[1][0] = *x2;
+  user_coord[1][1] = *y1;
+
+  user_coord[2][0] = *x1;
+  user_coord[2][1] = *y2;
+
+  user_coord[3][0] = *x2;
+  user_coord[3][1] = *y2;
+
+  for (i = 0; i < 4; i ++)
+    gimp_display_shell_transform_xy_f(shell, 
+                                      user_coord[i][0],
+                                      user_coord[i][1],
+                                      &user_coord[i][0],
+                                      &user_coord[i][1]);
+
+  gimp_display_shell_get_extents(user_coord[0][0], user_coord[0][1],
+                                 user_coord[1][0], user_coord[1][1],
+                                 user_coord[2][0], user_coord[2][1],
+                                 user_coord[3][0], user_coord[3][1],
+                                 x1, y1, x2, y2);
+}
+
+void gimp_display_shell_get_extents (gdouble x1,    gdouble y1,
+                                     gdouble x2,    gdouble y2,
+                                     gdouble x3,    gdouble y3,
+                                     gdouble x4,    gdouble y4,
+                                     gdouble *minx, gdouble *miny,
+                                     gdouble *maxx, gdouble *maxy)
+{
+  *minx = floor(MIN(MIN(MIN(x1, x2), x3),x4));
+  *miny = floor(MIN(MIN(MIN(y1, y2), y3),y4));
+  *maxx = ceil(MAX(MAX(MAX(x1, x2), x3),x4));
+  *maxy = ceil(MAX(MAX(MAX(y1, y2), y3),y4));
+}
+
+void
+gimp_display_shell_image_to_device_coords (const GimpDisplayShell *shell,
+                                           gdouble          *x,
+                                           gdouble          *y)
+{
+  if (shell->rotate_angle != 0.0 || shell->mirrored) {
+    cairo_t* cr = gdk_cairo_create(gtk_widget_get_window (shell->canvas));
+    g_return_if_fail (cr != NULL);
+    gimp_display_shell_set_cairo_rotate (shell, cr);
+    cairo_user_to_device(cr, x, y);
+    cairo_destroy(cr);
+  }
+  
+}
+
+void
+gimp_display_shell_device_to_image_coords (const GimpDisplayShell *shell,
+                                           gdouble          *x,
+                                           gdouble          *y)
+{
+  if (shell->rotate_angle != 0.0 || shell->mirrored) {
+    cairo_t* cr = gdk_cairo_create(gtk_widget_get_window (shell->canvas));
+    g_return_if_fail (cr != NULL);
+    gimp_display_shell_set_cairo_rotate (shell, cr);
+    cairo_device_to_user(cr, x, y);
+    cairo_destroy(cr);
+  }
+  
+}
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-rotate.h gimp-2.8.14-new/app/display/gimpdisplayshell-rotate.h
--- gimp-2.8.14/app/display/gimpdisplayshell-rotate.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-rotate.h	2015-01-27 17:48:55.333751582 +0800
@@ -0,0 +1,69 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_DISPLAY_SHELL_ROTATE_H__
+#define __GIMP_DISPLAY_SHELL_ROTATE_H__
+
+
+void  gimp_display_shell_set_cairo_rotate (const GimpDisplayShell *shell,
+                                           cairo_t          *cr);
+
+void gimp_display_shell_get_device_bouding_box_for_image_coords
+                                           (const GimpDisplayShell *shell,
+                                           cairo_t                 *cr,
+                                           gdouble                 *x1,
+                                           gdouble                 *y1,
+                                           gdouble                 *x2,
+                                           gdouble                 *y2);
+
+void gimp_display_shell_get_image_bouding_box_for_device_coords
+                                           (const GimpDisplayShell *shell,
+                                           cairo_t                 *cr,
+                                           gdouble                 *x1,
+                                           gdouble                 *y1,
+                                           gdouble                 *x2,
+                                           gdouble                 *y2);
+
+void gimp_display_shell_transform_region
+                                           (const GimpDisplayShell *shell,
+                                            gdouble                *x1,
+                                            gdouble                *y1,
+                                            gdouble                *x2,
+                                            gdouble                *y2);
+
+void gimp_display_shell_device_to_image_coords (const GimpDisplayShell *shell,
+                                                gdouble                 *x,
+                                                gdouble                 *y);
+
+void gimp_display_shell_image_to_device_coords (const GimpDisplayShell *shell,
+                                                gdouble                 *x,
+                                                gdouble                 *y);
+
+void gimp_display_shell_get_extents (gdouble x1, 
+                                     gdouble y1,
+                                     gdouble x2,
+                                     gdouble y2,
+                                     gdouble x3,
+                                     gdouble y3,
+                                     gdouble x4,
+                                     gdouble y4,
+                                     gdouble *minx,
+                                     gdouble *miny,
+                                     gdouble *maxx,
+                                     gdouble *maxy);
+
+#endif  /*  __GIMP_DISPLAY_SHELL_ROTATE_H__  */
\ No newline at end of file
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-scroll.c gimp-2.8.14-new/app/display/gimpdisplayshell-scroll.c
--- gimp-2.8.14/app/display/gimpdisplayshell-scroll.c	2015-01-27 17:28:36.973833803 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-scroll.c	2015-01-27 17:48:55.334751582 +0800
@@ -40,6 +40,7 @@
 #include "gimpdisplayshell-draw.h"
 #include "gimpdisplayshell-expose.h"
 #include "gimpdisplayshell-scale.h"
+#include "gimpdisplayshell-rotate.h"
 #include "gimpdisplayshell-scroll.h"
 
 
@@ -87,11 +88,11 @@
 
 void
 gimp_display_shell_scroll (GimpDisplayShell *shell,
-                           gint              x_offset,
-                           gint              y_offset)
+                           gdouble           x_offset,
+                           gdouble           y_offset)
 {
-  gint old_x;
-  gint old_y;
+  gdouble old_x;
+  gdouble old_y;
 
   g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
 
@@ -112,18 +113,35 @@
 
   if (x_offset || y_offset)
     {
+      gdouble rx_offset, ry_offset;
       /*  reset the old values so that the tool can accurately redraw  */
       shell->offset_x = old_x;
       shell->offset_y = old_y;
 
+      gimp_display_shell_image_to_device_coords (shell, &old_x, &old_y);
+
       gimp_display_shell_pause (shell);
 
       /*  set the offsets back to the new values  */
       shell->offset_x += x_offset;
       shell->offset_y += y_offset;
 
+      rx_offset = shell->offset_x;
+      ry_offset = shell->offset_y;
+
+      gimp_display_shell_image_to_device_coords (shell, &rx_offset, &ry_offset);
+
+      rx_offset -= old_x;
+      ry_offset -= old_y;
+
+      rx_offset += shell->accum_error_x;
+      ry_offset += shell->accum_error_y;
+
       gimp_overlay_box_scroll (GIMP_OVERLAY_BOX (shell->canvas),
-                               -x_offset, -y_offset);
+                               -ROUND(rx_offset), -ROUND(ry_offset));
+
+      shell->accum_error_x = rx_offset - ROUND(rx_offset);
+      shell->accum_error_y = ry_offset - ROUND(ry_offset);
 
       /*  Update scrollbars and rulers  */
       gimp_display_shell_update_scrollbars_and_rulers (shell);
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-scroll.h gimp-2.8.14-new/app/display/gimpdisplayshell-scroll.h
--- gimp-2.8.14/app/display/gimpdisplayshell-scroll.h	2015-01-27 17:28:36.972833803 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-scroll.h	2015-01-27 17:48:55.334751582 +0800
@@ -23,8 +23,8 @@
                                                              gdouble                 image_x,
                                                              gdouble                 image_y);
 void   gimp_display_shell_scroll                            (GimpDisplayShell       *shell,
-                                                             gint                    x_offset,
-                                                             gint                    y_offset);
+                                                             gdouble                 x_offset,
+                                                             gdouble                 y_offset);
 void   gimp_display_shell_scroll_set_offset                 (GimpDisplayShell       *shell,
                                                              gint                    offset_x,
                                                              gint                    offset_y);
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-tool-events.c gimp-2.8.14-new/app/display/gimpdisplayshell-tool-events.c
--- gimp-2.8.14/app/display/gimpdisplayshell-tool-events.c	2015-01-27 17:28:36.973833803 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-tool-events.c	2015-01-27 17:48:55.336751582 +0800
@@ -21,6 +21,8 @@
 #include <gtk/gtk.h>
 #include <gdk/gdkkeysyms.h>
 
+#include "libgimpmath/gimpmath.h"
+
 #include "libgimpwidgets/gimpwidgets.h"
 
 #include "display-types.h"
@@ -53,8 +55,10 @@
 #include "gimpdisplayshell.h"
 #include "gimpdisplayshell-autoscroll.h"
 #include "gimpdisplayshell-cursor.h"
+#include "gimpdisplayshell-expose.h"
 #include "gimpdisplayshell-grab.h"
 #include "gimpdisplayshell-layer-select.h"
+#include "gimpdisplayshell-rotate.h"
 #include "gimpdisplayshell-scale.h"
 #include "gimpdisplayshell-scroll.h"
 #include "gimpdisplayshell-tool-events.h"
@@ -64,6 +68,8 @@
 
 #include "gimp-log.h"
 
+/*  local constant values  */
+#define ZOOM_UNIT_DISTANCE 300.0
 
 /*  local function prototypes  */
 
@@ -84,6 +90,26 @@
 static void       gimp_display_shell_stop_scrolling           (GimpDisplayShell  *shell,
                                                                const GdkEvent    *event);
 
+static void       gimp_display_shell_start_rotating          (GimpDisplayShell  *shell,
+                                                               const GdkEvent    *event,
+                                                               gint               x,
+                                                               gint               y);
+static void       gimp_display_shell_rotate                  (GimpDisplayShell *shell,
+                                                               gint              x,
+                                                               gint              y);
+static void       gimp_display_shell_stop_rotating           (GimpDisplayShell  *shell,
+                                                               const GdkEvent    *event);
+
+static void       gimp_display_shell_start_scaling           (GimpDisplayShell  *shell,
+                                                               const GdkEvent    *event,
+                                                               gint               x,
+                                                               gint               y);
+static void       gimp_display_shell_do_scaling              (GimpDisplayShell *shell,
+                                                               gint              x,
+                                                               gint              y);
+static void       gimp_display_shell_stop_scaling            (GimpDisplayShell  *shell,
+                                                               const GdkEvent    *event);
+
 static void       gimp_display_shell_space_pressed            (GimpDisplayShell  *shell,
                                                                const GdkEvent    *event);
 static void       gimp_display_shell_space_released           (GimpDisplayShell  *shell,
@@ -459,7 +485,7 @@
         GdkModifierType  button_state;
 
         /*  ignore new mouse events  */
-        if (gimp->busy || shell->scrolling || shell->pointer_grabbed)
+        if (gimp->busy || shell->scrolling || shell->rotating || shell->pointer_grabbed)
           return TRUE;
 
         button_state = gimp_display_shell_button_to_state (bevent->button);
@@ -563,8 +589,18 @@
           }
         else if (bevent->button == 2)
           {
-            gimp_display_shell_start_scrolling (shell, NULL,
-                                                bevent->x, bevent->y);
+            if (bevent->state & GDK_SHIFT_MASK) {
+              gimp_display_shell_start_rotating (shell, NULL, bevent->x, bevent->y);
+            } else if (bevent->state & GDK_CONTROL_MASK) {
+              gimp_display_shell_start_scaling (shell, NULL, bevent->x, bevent->y);
+            } else {
+              gdouble start_x = bevent->x;
+              gdouble start_y = bevent->y;
+              gimp_display_shell_device_to_image_coords (shell, &start_x, &start_y);
+
+              gimp_display_shell_start_scrolling (shell, NULL,
+                                                  start_x, start_y);
+            }
           }
 
         return_val = TRUE;
@@ -681,6 +717,10 @@
           {
             if (shell->scrolling)
               gimp_display_shell_stop_scrolling (shell, NULL);
+            else if (shell->scaling)
+              gimp_display_shell_stop_scaling (shell, NULL);
+            else if (shell->rotating)
+              gimp_display_shell_stop_rotating (shell, NULL);
           }
         else if (bevent->button == 3)
           {
@@ -836,23 +876,51 @@
 
         if (shell->scrolling)
           {
-            const gint x = (compressed_motion
+            gdouble x  = (compressed_motion
                             ? ((GdkEventMotion *) compressed_motion)->x
                             : mevent->x);
-            const gint y = (compressed_motion
+            gdouble y  = (compressed_motion
                             ? ((GdkEventMotion *) compressed_motion)->y
                             : mevent->y);
+            gdouble offset_x = shell->offset_x;
+            gdouble offset_y = shell->offset_y;
+            gdouble start_x  = shell->scroll_start_x;
+            gdouble start_y  = shell->scroll_start_y;
+
+            gimp_display_shell_device_to_image_coords(shell, &x, &y);
 
             gimp_display_shell_scroll (shell,
-                                       (shell->scroll_start_x - x -
-                                        shell->offset_x),
-                                       (shell->scroll_start_y - y -
-                                        shell->offset_y));
+                                       start_x - x - offset_x,
+                                       start_y - y - offset_y);
+          }
+        else if (shell->rotating)
+          {
+            gdouble x  = (compressed_motion
+                            ? ((GdkEventMotion *) compressed_motion)->x
+                            : mevent->x);
+            gdouble y  = (compressed_motion
+                            ? ((GdkEventMotion *) compressed_motion)->y
+                            : mevent->y);
+
+            gimp_display_shell_rotate (shell, x, y);
           }
-        else if (state & GDK_BUTTON1_MASK)
+        else if (shell->scaling)
+          {
+            gdouble x  = (compressed_motion
+                            ? ((GdkEventMotion *) compressed_motion)->x
+                            : mevent->x);
+            gdouble y  = (compressed_motion
+                            ? ((GdkEventMotion *) compressed_motion)->y
+                            : mevent->y);
+
+            gimp_display_shell_do_scaling (shell, x, y);
+          }
+        else if (state & GDK_BUTTON1_MASK || 
+                 (active_tool && active_tool->want_full_motion_tracking))
           {
             if (active_tool                                        &&
-                gimp_tool_control_is_active (active_tool->control) &&
+                (gimp_tool_control_is_active (active_tool->control) ||
+                 active_tool->want_full_motion_tracking) &&
                 (! gimp_image_is_empty (image) ||
                  gimp_tool_control_get_handle_empty_image (active_tool->control)))
               {
@@ -1206,7 +1274,8 @@
   active_tool = tool_manager_get_active (gimp);
 
   if (active_tool &&
-      gimp_tool_control_is_active (active_tool->control))
+      (gimp_tool_control_is_active (active_tool->control)||
+       active_tool->want_full_motion_tracking))
     {
       tool_manager_motion_active (gimp,
                                   coords, time, state,
@@ -1415,8 +1484,11 @@
   gimp_display_shell_pointer_grab (shell, event, GDK_POINTER_MOTION_MASK);
 
   shell->scrolling      = TRUE;
-  shell->scroll_start_x = x + shell->offset_x;
-  shell->scroll_start_y = y + shell->offset_y;
+  shell->scroll_start_x = x;
+  shell->scroll_start_y = y;
+
+  shell->scroll_start_x += shell->offset_x;
+  shell->scroll_start_y += shell->offset_y;
 
   gimp_display_shell_set_override_cursor (shell, GDK_FLEUR);
 }
@@ -1434,6 +1506,141 @@
   shell->scroll_start_y = 0;
 
   gimp_display_shell_pointer_ungrab (shell, event);
+  gimp_display_shell_expose_full (shell);
+}
+
+static void
+gimp_display_shell_start_rotating (GimpDisplayShell *shell,
+                                    const GdkEvent   *event,
+                                    gint              x,
+                                    gint              y)
+{
+  gdouble cx, cy;
+  gdouble rx, ry;
+  g_return_if_fail (! shell->rotating);
+
+  gimp_display_shell_pointer_grab (shell, event, GDK_POINTER_MOTION_MASK);
+
+  shell->rotating      = TRUE;
+
+  cx = shell->disp_width  / 2;
+  cy = shell->disp_height / 2;
+  rx = x - cx;
+  ry = y - cy;
+
+  if (shell->mirrored)
+    rx = -rx;
+
+  shell->rotate_start_angle = shell->rotate_angle + 
+    fmod(atan2(rx, ry) / M_PI * 180.0 + 360.0, 360.0); 
+
+  gimp_display_shell_set_override_cursor (shell, GDK_EXCHANGE);
+}
+
+
+static void
+gimp_display_shell_rotate        (GimpDisplayShell *shell,
+                                  gint              x,
+                                  gint              y)
+{
+  gdouble cx, cy;
+  gdouble rx, ry;
+  gdouble angle;
+  g_return_if_fail (shell->rotating);
+
+  cx = shell->disp_width  / 2;
+  cy = shell->disp_height / 2;
+  rx = x - cx;
+  ry = y - cy;
+
+  if (shell->mirrored)
+    rx = -rx;
+
+  angle               = shell->rotate_start_angle - 
+                        fmod(atan2(rx, ry) / M_PI * 180.0 + 360.0, 360.0);
+  shell->rotate_angle = fmod(angle + 360.0, 360.0);
+  gimp_display_shell_expose_full(shell);
+}
+
+static void
+gimp_display_shell_stop_rotating (GimpDisplayShell *shell,
+                                   const GdkEvent   *event)
+{
+  g_return_if_fail (shell->rotating);
+
+  gimp_display_shell_unset_override_cursor (shell);
+
+  shell->rotating           = FALSE;
+  shell->rotate_start_angle = 0;
+
+  gimp_display_shell_pointer_ungrab (shell, event);
+}
+
+static void
+gimp_display_shell_start_scaling   (GimpDisplayShell *shell,
+                                    const GdkEvent   *event,
+                                    gint              x,
+                                    gint              y)
+{
+  gdouble cx, cy;
+  gdouble rx, ry;
+  g_return_if_fail (! shell->scaling);
+
+  gimp_display_shell_pointer_grab (shell, event, GDK_POINTER_MOTION_MASK);
+
+  shell->scaling      = TRUE;
+
+  cx = shell->disp_width  / 2;
+  cy = shell->disp_height / 2;
+  rx = x - cx;
+  ry = y - cy;
+
+  if (shell->mirrored)
+    rx = -rx;
+
+  shell->scaling_start_distance = MAX(shell->scale_x, shell->scale_y) * ZOOM_UNIT_DISTANCE - 
+                                  sqrt(rx * rx + ry * ry); 
+
+  gimp_display_shell_set_override_cursor (shell, GDK_SIZING);
+}
+
+
+static void
+gimp_display_shell_do_scaling    (GimpDisplayShell *shell,
+                                  gint              x,
+                                  gint              y)
+{
+  gdouble cx, cy;
+  gdouble rx, ry;
+  gdouble distance;
+  gdouble distance_diff;
+  g_return_if_fail (shell->scaling);
+
+  cx = shell->disp_width  / 2;
+  cy = shell->disp_height / 2;
+  rx = x - cx;
+  ry = y - cy;
+
+  distance      = sqrt(rx * rx + ry * ry);
+  distance_diff = distance + shell->scaling_start_distance;
+
+  gimp_display_shell_scale(shell, GIMP_ZOOM_TO, distance_diff / ZOOM_UNIT_DISTANCE, 
+                           GIMP_ZOOM_FOCUS_RETAIN_CENTERING_ELSE_BEST_GUESS);
+  gimp_display_shell_expose_full(shell);
+}
+
+static void
+gimp_display_shell_stop_scaling   (GimpDisplayShell *shell,
+                                   const GdkEvent   *event)
+{
+  g_return_if_fail (shell->scaling);
+
+  gimp_display_shell_unset_override_cursor (shell);
+
+  shell->scaling                = FALSE;
+  shell->scaling_start_distance = 0;
+
+  gimp_display_shell_pointer_ungrab (shell, event);
 }
 
 static void
@@ -1458,6 +1665,8 @@
         GimpDeviceManager *manager;
         GimpDeviceInfo    *current_device;
         GimpCoords         coords;
+        gdouble start_x;
+        gdouble start_y;
 
         manager = gimp_devices_get_manager (gimp);
         current_device = gimp_device_manager_get_current_device (manager);
@@ -1465,9 +1674,12 @@
         gimp_device_info_get_device_coords (current_device,
                                             gtk_widget_get_window (shell->canvas),
                                             &coords);
-
+        start_x = coords.x;
+        start_y = coords.y;
+        gimp_display_shell_device_to_image_coords (shell, &start_x, &start_y);
+        
         gimp_display_shell_start_scrolling (shell, event,
-                                            coords.x, coords.y);
+                                            start_x, start_y);
       }
       break;
 
@@ -1595,6 +1807,19 @@
   return FALSE;
 }
 
+static GimpImageWindow *
+gimp_display_shell_get_toolbar_window (Gimp *gimp)
+{
+  GList* iter = gimp_get_image_windows (gimp);
+
+  for (; iter; iter = g_list_next (iter)) {
+    GimpImageWindow *image_window = GIMP_IMAGE_WINDOW (iter->data);
+    if (image_window && gimp_image_window_is_toolbar_window (image_window) )
+      return image_window;
+  }
+  return NULL;
+}
+
 static void
 gimp_display_shell_update_focus (GimpDisplayShell *shell,
                                  gboolean          focus_in,
@@ -1605,6 +1830,12 @@
 
   if (focus_in)
     {
+      GimpImageWindow *toolbar_window;
+      g_print("update focus\n");
+      toolbar_window = GIMP_IMAGE_WINDOW (gimp_display_shell_get_toolbar_window (gimp) );
+      if (toolbar_window) {
+        gimp_image_window_link_foreign_active_shell (toolbar_window, shell);
+      }
       tool_manager_focus_display_active (gimp, shell->display);
       tool_manager_modifier_state_active (gimp, state, shell->display);
     }
diff -Naur gimp-2.8.14/app/display/gimpdisplayshell-transform.c gimp-2.8.14-new/app/display/gimpdisplayshell-transform.c
--- gimp-2.8.14/app/display/gimpdisplayshell-transform.c	2015-01-27 17:28:36.973833803 +0800
+++ gimp-2.8.14-new/app/display/gimpdisplayshell-transform.c	2015-01-27 17:48:55.337751582 +0800
@@ -32,6 +32,7 @@
 #include "gimpdisplay.h"
 #include "gimpdisplayshell.h"
 #include "gimpdisplayshell-scroll.h"
+#include "gimpdisplayshell-rotate.h"
 #include "gimpdisplayshell-transform.h"
 
 
@@ -60,6 +61,16 @@
 
   display_coords->x -= shell->offset_x;
   display_coords->y -= shell->offset_y;
+
+  if (shell->rotate_angle != 0.0 || shell->mirrored) {
+    cairo_t* cr = gdk_cairo_create(gtk_widget_get_window (shell->canvas));
+    g_return_if_fail (cr != NULL);
+//    g_print("Transform:%4.1f,%4.1f->", display_coords->x, display_coords->y);
+    gimp_display_shell_set_cairo_rotate (shell, cr);
+    cairo_user_to_device(cr, &display_coords->x, &display_coords->y);
+    cairo_destroy(cr);
+//    g_print("%4.1f,%4.1f\n", display_coords->x, display_coords->y);
+  }
 }
 
 /**
@@ -82,11 +93,20 @@
 
   *image_coords = *display_coords;
 
-  image_coords->x = display_coords->x + shell->offset_x;
-  image_coords->y = display_coords->y + shell->offset_y;
+  if (shell->rotate_angle != 0.0 || shell->mirrored) {
+    cairo_t* cr = gdk_cairo_create(gtk_widget_get_window (shell->canvas));
+    g_return_if_fail (cr != NULL);
+    gimp_display_shell_set_cairo_rotate (shell, cr);
+    cairo_device_to_user(cr, &image_coords->x, &image_coords->y);
+    cairo_destroy(cr);
+  }
+
+  image_coords->x = image_coords->x + shell->offset_x;
+  image_coords->y = image_coords->y + shell->offset_y;
 
   image_coords->x /= shell->scale_x;
   image_coords->y /= shell->scale_y;
+
 }
 
 /**
@@ -106,23 +126,32 @@
                                  gint                   *nx,
                                  gint                   *ny)
 {
-  gint64 tx;
-  gint64 ty;
+  gdouble r_tx, r_ty;
 
   g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
   g_return_if_fail (nx != NULL);
   g_return_if_fail (ny != NULL);
 
-  tx = ((gint64) x * shell->x_src_dec) / shell->x_dest_inc;
-  ty = ((gint64) y * shell->y_src_dec) / shell->y_dest_inc;
+  r_tx = (x * shell->x_src_dec) / shell->x_dest_inc;
+  r_ty = (y * shell->y_src_dec) / shell->y_dest_inc;
 
-  tx -= shell->offset_x;
-  ty -= shell->offset_y;
+  r_tx -= shell->offset_x;
+  r_ty -= shell->offset_y;
 
+  if (shell->rotate_angle != 0.0 || shell->mirrored) {
+    cairo_t* cr = gdk_cairo_create(gtk_widget_get_window (shell->canvas));
+    g_return_if_fail (cr != NULL);
+//    g_print("Transform xy:%4.1f,%4.1f->", r_tx, r_ty);
+    gimp_display_shell_set_cairo_rotate (shell, cr);
+    cairo_user_to_device(cr, &r_tx, &r_ty);
+    cairo_destroy(cr);
+//    g_print("%4.1f,%4.1f\n", r_tx, r_ty);
+  }
+  
   /* The projected coordinates might overflow a gint in the case of big
      images at high zoom levels, so we clamp them here to avoid problems.  */
-  *nx = CLAMP (tx, G_MININT, G_MAXINT);
-  *ny = CLAMP (ty, G_MININT, G_MAXINT);
+  *nx = CLAMP (r_tx, G_MININT, G_MAXINT);
+  *ny = CLAMP (r_ty, G_MININT, G_MAXINT);
 }
 
 /**
@@ -154,6 +183,19 @@
   g_return_if_fail (nx != NULL);
   g_return_if_fail (ny != NULL);
 
+  if (shell->rotate_angle != 0.0 || shell->mirrored) {
+    gdouble xx, yy;
+    cairo_t* cr = gdk_cairo_create(gtk_widget_get_window (shell->canvas));
+    g_return_if_fail (cr != NULL);
+    xx = x;
+    yy = y;
+    gimp_display_shell_set_cairo_rotate (shell, cr);
+    cairo_device_to_user(cr, &xx, &yy);
+    cairo_destroy(cr);
+    x = (gint)xx;
+    y = (gint)yy;
+  }
+
   tx = (gint64) x + shell->offset_x;
   ty = (gint64) y + shell->offset_y;
 
@@ -194,6 +236,17 @@
 
   *nx = SCALEX (shell, x) - shell->offset_x;
   *ny = SCALEY (shell, y) - shell->offset_y;
+
+  if (shell->rotate_angle != 0.0 || shell->mirrored) {
+    cairo_t* cr = gdk_cairo_create(gtk_widget_get_window (shell->canvas));
+    g_return_if_fail (cr != NULL);
+//    g_print("Transform xy_f:%4.1f,%4.1f->", *nx, *ny);
+    gimp_display_shell_set_cairo_rotate (shell, cr);
+    cairo_user_to_device(cr, nx, ny);
+    cairo_destroy(cr);
+//    g_print("%4.1f,%4.1f\n", *nx, *ny);
+  }
+  
 }
 
 /**
@@ -219,6 +272,13 @@
   g_return_if_fail (nx != NULL);
   g_return_if_fail (ny != NULL);
 
+  if (shell->rotate_angle != 0.0 || shell->mirrored) {
+    cairo_t* cr = gdk_cairo_create(gtk_widget_get_window (shell->canvas));
+    gimp_display_shell_set_cairo_rotate (shell, cr);
+    cairo_device_to_user(cr, &x, &y);
+    cairo_destroy(cr);
+  }
+
   *nx = (x + shell->offset_x) / shell->scale_x;
   *ny = (y + shell->offset_y) / shell->scale_y;
 }
diff -Naur gimp-2.8.14/app/display/gimpimagewindow.c gimp-2.8.14-new/app/display/gimpimagewindow.c
--- gimp-2.8.14/app/display/gimpimagewindow.c	2015-01-27 17:28:36.962833804 +0800
+++ gimp-2.8.14-new/app/display/gimpimagewindow.c	2015-01-27 17:48:55.340751582 +0800
@@ -31,6 +31,7 @@
 #include "core/gimpcontext.h"
 #include "core/gimpimage.h"
 #include "core/gimpprogress.h"
+#include "core/gimpcontainer.h"
 
 #include "widgets/gimpactiongroup.h"
 #include "widgets/gimpdialogfactory.h"
@@ -47,6 +48,8 @@
 #include "widgets/gimptoolbox.h"
 #include "widgets/gimpuimanager.h"
 #include "widgets/gimpview.h"
+#include "widgets/gimptooloptionstoolbar.h"
+#include "widgets/gimppopupbutton.h"
 
 #include "gimpdisplay.h"
 #include "gimpdisplay-foreach.h"
@@ -54,6 +57,7 @@
 #include "gimpdisplayshell-appearance.h"
 #include "gimpdisplayshell-close.h"
 #include "gimpdisplayshell-scroll.h"
+#include "gimpdisplayshell-scale.h"
 #include "gimpdisplayshell-tool-events.h"
 #include "gimpdisplayshell-transform.h"
 #include "gimpimagewindow.h"
@@ -76,6 +80,7 @@
 /* Whether the window's maximized or not */
 #define GIMP_IMAGE_WINDOW_MAXIMIZED        "maximized"
 
+#define ROTATE_UNIT_ANGLE 30
 
 enum
 {
@@ -83,6 +88,7 @@
   PROP_GIMP,
   PROP_MENU_FACTORY,
   PROP_DIALOG_FACTORY,
+  PROP_TOOLBAR_WINDOW,
 };
 
 
@@ -93,6 +99,7 @@
   Gimp              *gimp;
   GimpUIManager     *menubar_manager;
   GimpDialogFactory *dialog_factory;
+  gboolean			 toolbar_window;
 
   GList             *shells;
   GimpDisplayShell  *active_shell;
@@ -105,6 +112,7 @@
   GtkWidget         *right_hpane;
   GtkWidget         *notebook;
   GtkWidget         *right_docks;
+  GtkWidget         *toolbar; /* gimp-painter-2.7 */
 
   GdkWindowState     window_state;
 
@@ -199,6 +207,10 @@
                                                         GtkWidget           *widget,
                                                         gint                 page_num,
                                                         GimpImageWindow     *window);
+static void      gimp_image_window_disconnect_from_shell
+                                                       (GimpImageWindow     *window,
+						        GimpDisplayShell    *shell);
+
 static void      gimp_image_window_disconnect_from_active_shell
                                                        (GimpImageWindow *window);
 
@@ -216,7 +228,19 @@
 static GtkWidget *
                  gimp_image_window_create_tab_label    (GimpImageWindow     *window,
                                                         GimpDisplayShell    *shell);
+static void      gimp_image_window_shell_destroy       (GimpDisplayShell    *shell,
+                                                        GimpImageWindow     *window);
 
+static void    gimp_image_window_rotate_left_clicked (GtkWidget* widget, GimpImageWindow *window);
+static void    gimp_image_window_rotate_right_clicked (GtkWidget* widget, GimpImageWindow *window);
+static void    gimp_image_window_flip_side_clicked (GtkWidget* widget, GimpImageWindow *window);
+static void    gimp_image_window_reset_view_clicked (GtkWidget* widget, GimpImageWindow *window);
+
+static void    gimp_image_window_configure_window_mode(GimpImageWindow* window);
+static void    gimp_image_window_configure_for_toolbar_window_mode(GimpImageWindow* window);
+static void    gimp_image_window_configure_for_non_toolbar_window_mode(GimpImageWindow* window);
+static void    gimp_image_window_switch_active_shell (GimpImageWindow* window,
+                                                      GimpDisplayShell* shell);
 
 G_DEFINE_TYPE_WITH_CODE (GimpImageWindow, gimp_image_window, GIMP_TYPE_WINDOW,
                          G_IMPLEMENT_INTERFACE (GIMP_TYPE_DOCK_CONTAINER,
@@ -272,6 +296,12 @@
                                                         GIMP_PARAM_READWRITE |
                                                         G_PARAM_CONSTRUCT_ONLY));
 
+  g_object_class_install_property (object_class, PROP_TOOLBAR_WINDOW,
+                                   g_param_spec_boolean ("toolbar-window",
+                                                        NULL, NULL,
+                                                        FALSE,
+                                                        GIMP_PARAM_READWRITE));
+
   g_type_class_add_private (klass, sizeof (GimpImageWindowPrivate));
 
   gtk_rc_parse_string (image_window_rc_style);
@@ -306,6 +336,8 @@
   GimpImageWindow        *window  = GIMP_IMAGE_WINDOW (object);
   GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
   GimpGuiConfig          *config;
+  GtkWidget              *hbox; /* placeholder for disposable widget */
+  GtkWidget              *widget; /* placeholder for disposable widget */
 
   g_assert (GIMP_IS_UI_MANAGER (private->menubar_manager));
 
@@ -335,9 +367,11 @@
 
   /* Create the menubar */
 #ifndef GDK_WINDOWING_QUARTZ
-  private->menubar =
-    gtk_ui_manager_get_widget (GTK_UI_MANAGER (private->menubar_manager),
+    {
+      private->menubar =
+        gtk_ui_manager_get_widget (GTK_UI_MANAGER (private->menubar_manager),
                                "/image-menubar");
+	}
 #endif /* !GDK_WINDOWING_QUARTZ */
   if (private->menubar)
     {
@@ -363,6 +397,47 @@
                         window);
     }
 
+  /* Create toolbar */
+  hbox           = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+  gtk_box_pack_start (GTK_BOX (private->main_vbox), hbox,
+                      FALSE, TRUE, 0);
+  gtk_widget_show (hbox);
+
+    {
+	  private->toolbar = gimp_tool_options_toolbar_new (private->gimp,
+													   gimp_dialog_factory_get_menu_factory (private->dialog_factory));
+	  gtk_box_pack_start (GTK_BOX (hbox), private->toolbar,
+						  TRUE, TRUE, 0);
+	  gtk_widget_show (private->toolbar);
+
+	  /* Temporary: right side left buttons */
+	  widget = gtk_button_new_with_label ("<->");
+	  gtk_widget_show (widget);
+	  g_signal_connect(widget, "clicked", G_CALLBACK(gimp_image_window_flip_side_clicked), window);
+	  gtk_box_pack_end (GTK_BOX (hbox), widget,
+						  FALSE, TRUE, 0);
+
+	  /* Temporary: rotate buttons */
+	  widget = gtk_button_new_with_label(">");
+	  gtk_widget_show (widget);
+	  g_signal_connect(widget, "clicked", G_CALLBACK(gimp_image_window_rotate_right_clicked), window);
+	  gtk_box_pack_end (GTK_BOX (hbox), widget,
+						  FALSE, TRUE, 0);
+
+	  widget = gtk_button_new_from_stock(GTK_STOCK_ZOOM_100);
+	  gtk_widget_show (widget);
+	  gtk_button_set_relief (GTK_BUTTON (widget), GTK_RELIEF_NONE);
+	  g_signal_connect(widget, "clicked", G_CALLBACK(gimp_image_window_reset_view_clicked), window);
+	  gtk_box_pack_end (GTK_BOX (hbox), widget,
+						  FALSE, TRUE, 0);
+
+	  widget = gtk_button_new_with_label("<");
+	  gtk_widget_show (widget);
+	  g_signal_connect(widget, "clicked", G_CALLBACK(gimp_image_window_rotate_left_clicked), window);
+	  gtk_box_pack_end (GTK_BOX (hbox), widget,
+						  FALSE, TRUE, 0);
+	}
+
   /* Create the hbox that contains docks and images */
   private->hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
   gtk_box_pack_start (GTK_BOX (private->main_vbox), private->hbox,
@@ -395,15 +470,15 @@
   gtk_notebook_set_scrollable (GTK_NOTEBOOK (private->notebook), TRUE);
   gtk_notebook_set_show_border (GTK_NOTEBOOK (private->notebook), FALSE);
   gtk_notebook_set_show_tabs (GTK_NOTEBOOK (private->notebook), FALSE);
+  gtk_notebook_set_tab_pos (GTK_NOTEBOOK (private->notebook), GTK_POS_LEFT);
   gtk_paned_pack1 (GTK_PANED (private->right_hpane), private->notebook,
-                   TRUE, TRUE);
+                   TRUE, FALSE);
   g_signal_connect (private->notebook, "switch-page",
                     G_CALLBACK (gimp_image_window_switch_page),
                     window);
   g_signal_connect (private->notebook, "page-removed",
                     G_CALLBACK (gimp_image_window_page_removed),
                     window);
-  gtk_widget_show (private->notebook);
 
   /* Create the right dock columns widget */
   private->right_docks =
@@ -424,9 +499,105 @@
   gimp_image_window_session_update (window,
                                     NULL /*new_display*/,
                                     gimp_image_window_config_to_entry_id (config));
+  gimp_image_window_configure_window_mode(window);
+}
+
+static void
+gimp_image_window_configure_window_mode(GimpImageWindow* window)
+{
+  GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+  private->toolbar_window?
+	gimp_image_window_configure_for_toolbar_window_mode(window) :
+	gimp_image_window_configure_for_non_toolbar_window_mode(window);
 }
 
 static void
+gimp_image_window_configure_for_toolbar_window_mode(GimpImageWindow* window)
+{
+  GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+  GimpGuiConfig          *config;
+
+  config          = GIMP_GUI_CONFIG (gimp_dialog_factory_get_context (private->dialog_factory)->gimp->config);
+
+  gtk_widget_set_visible (private->notebook, FALSE);
+  gtk_widget_set_visible (private->toolbar, TRUE);
+  gtk_widget_set_visible (private->menubar, TRUE);
+
+  gtk_widget_show (GTK_WIDGET(window));
+#if 0
+  {
+    GdkWindow              *gdk_window;
+    GdkScreen              *gdk_screen;
+    unsigned long           params[12] = {0};
+	gint                    monitor = 0;
+	GdkRectangle            boundary;
+	gint                    x, y, width, height;
+
+	gtk_window_set_type_hint (GTK_WINDOW(window), GDK_WINDOW_TYPE_HINT_DOCK);
+
+	gdk_window = gtk_widget_get_window (GTK_WIDGET(window));
+    gdk_screen = gdk_screen_get_default ();
+	monitor    = gdk_screen_get_monitor_at_window (gdk_screen, gdk_window);
+	gdk_screen_get_monitor_geometry (gdk_screen, monitor, &boundary);
+
+	gtk_window_move (GTK_WINDOW(window), boundary.x, boundary.y);
+	gtk_window_set_keep_above (GTK_WINDOW(window), TRUE);
+
+	gtk_window_get_size (GTK_WINDOW(window), &width, &height);
+	gtk_window_get_position (GTK_WINDOW(window), &x, &y);
+//	gtk_window_set_decorated (GTK_WINDOW(window), FALSE);
+//	gtk_window_resize (GTK_WINDOW(window), boundary.width, height);
+
+
+	params[2] = y + height;
+    params[8] = x;                      /* top_start_x */
+    params[9] = x + width - 1; /* top_end_x */
+
+	g_print("_NET_WM_STRUT_PARTIAL, %ld, Monitor(%d)=%d,%d,%d,%d, (%ld-%ld)\n", params[2], monitor,
+									  boundary.x, boundary.y,
+									  boundary.x + boundary.width,
+									  boundary.y + boundary.height, params[8], params[9]);
+
+	gdk_property_change (gdk_window,
+                         gdk_atom_intern("_NET_WM_STRUT_PARTIAL", TRUE),
+                         gdk_atom_intern("CARDINAL", TRUE),
+                         32, GDK_PROP_MODE_REPLACE, (guchar*)params, 12);
+
+
+  }
+#endif
+}
+
+static void
+gimp_image_window_configure_for_non_toolbar_window_mode(GimpImageWindow* window)
+{
+  GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+  GimpGuiConfig          *config;
+  gboolean                show_docks;
+
+  config     = GIMP_GUI_CONFIG (gimp_dialog_factory_get_context (private->dialog_factory)->gimp->config);
+  show_docks = config->single_window_mode && !config->hide_docks;
+
+  g_print("Config: for non-toolbar mode: show_docks=%d\n", show_docks);
+  gtk_widget_set_visible (private->notebook, TRUE);
+  gtk_widget_set_visible (private->toolbar, show_docks);
+  gtk_widget_set_visible (private->menubar, config->single_window_mode);
+
+#if 0
+  {
+    GdkWindow              *gdk_window;
+
+	gtk_window_set_decorated (GTK_WINDOW(window), TRUE);
+    gdk_window = gtk_widget_get_window (GTK_WIDGET(window));
+
+    gdk_property_delete (gdk_window,
+                         gdk_atom_intern("_NET_WM_STRUT_PARTIAL", TRUE));
+  }
+#endif
+}
+
+
+static void
 gimp_image_window_dispose (GObject *object)
 {
   GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (object);
@@ -490,6 +661,11 @@
       private->dialog_factory = g_value_get_object (value);
       break;
 
+	case PROP_TOOLBAR_WINDOW:
+	  private->toolbar_window = g_value_get_boolean(value);
+	  gimp_image_window_configure_window_mode(window);
+	  break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -514,6 +690,10 @@
       g_value_set_object (value, private->dialog_factory);
       break;
 
+	case PROP_TOOLBAR_WINDOW:
+	  g_value_set_boolean (value, private->toolbar_window);
+	  break;
+
     case PROP_MENU_FACTORY:
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
@@ -532,9 +712,12 @@
 
   config = GIMP_GUI_CONFIG (gimp_dialog_factory_get_context (private->dialog_factory)->gimp->config);
 
-  if (config->single_window_mode)
+  g_print ("gimp_image_window_delete_event\n");
+  if (config->single_window_mode || private->toolbar_window) {
     gimp_ui_manager_activate_action (gimp_image_window_get_ui_manager (window),
                                      "file", "file-quit");
+  }
+
   else if (shell)
     gimp_display_shell_close (shell, FALSE);
 
@@ -982,10 +1165,17 @@
 gimp_image_window_destroy (GimpImageWindow *window)
 {
   GimpImageWindowPrivate *private;
+  GimpGuiConfig          *config;
 
   g_return_if_fail (GIMP_IS_IMAGE_WINDOW (window));
 
   private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+  config  = GIMP_GUI_CONFIG (gimp_dialog_factory_get_context (private->dialog_factory)->gimp->config);
+
+  /* Disconnect handlers if the window is toolbar window. */
+  if (private->toolbar_window && private->active_shell) {
+    gimp_image_window_disconnect_from_shell (window, private->active_shell);
+  }
 
   private->gimp->image_windows = g_list_remove (private->gimp->image_windows,
                                                 window);
@@ -1123,10 +1313,12 @@
 
   g_return_if_fail (g_list_find (private->shells, shell));
 
-  page_num = gtk_notebook_page_num (GTK_NOTEBOOK (private->notebook),
-                                    GTK_WIDGET (shell));
+  if (!private->toolbar_window) {
+    page_num = gtk_notebook_page_num (GTK_NOTEBOOK (private->notebook),
+                                      GTK_WIDGET (shell));
 
-  gtk_notebook_set_current_page (GTK_NOTEBOOK (private->notebook), page_num);
+    gtk_notebook_set_current_page (GTK_NOTEBOOK (private->notebook), page_num);
+  }
 }
 
 GimpDisplayShell *
@@ -1173,13 +1365,15 @@
                                     gboolean         show)
 {
   GimpImageWindowPrivate *private;
+  GimpGuiConfig          *config;
 
   g_return_if_fail (GIMP_IS_IMAGE_WINDOW (window));
 
   private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+  config  = GIMP_GUI_CONFIG (gimp_dialog_factory_get_context (private->dialog_factory)->gimp->config);
 
   if (private->menubar)
-    gtk_widget_set_visible (private->menubar, show);
+    gtk_widget_set_visible (private->menubar, show && (config->single_window_mode || gimp_image_window_is_toolbar_window(window)));
 }
 
 gboolean
@@ -1407,7 +1601,7 @@
 gimp_image_window_get_first_dockbook (GimpDockColumns *columns)
 {
   GList *dock_iter;
-  
+
   for (dock_iter = gimp_dock_columns_get_docks (columns);
        dock_iter;
        dock_iter = g_list_next (dock_iter))
@@ -1455,6 +1649,18 @@
   return dockbook;
 }
 
+gboolean
+gimp_image_window_is_toolbar_window (GimpImageWindow *window)
+{
+  GimpImageWindowPrivate *private;
+
+  g_return_val_if_fail (GIMP_IS_IMAGE_WINDOW (window), FALSE);
+
+  private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+
+  return private->toolbar_window;
+}
+
 /**
  * gimp_image_window_keep_canvas_pos:
  * @window:
@@ -1548,6 +1754,7 @@
                                         NULL /*new_display*/,
                                         gimp_image_window_config_to_entry_id (config));
     }
+  gimp_image_window_configure_window_mode(window);
 }
 
 static void
@@ -1570,8 +1777,9 @@
 {
   GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
 
-  gimp_ui_manager_update (private->menubar_manager,
-                          private->active_shell->display);
+  if (private->menubar_manager && private->active_shell)
+    gimp_ui_manager_update (private->menubar_manager,
+                            private->active_shell->display);
 }
 
 static void
@@ -1617,26 +1825,23 @@
 }
 
 static void
-gimp_image_window_switch_page (GtkNotebook     *notebook,
-                               gpointer         page,
-                               gint             page_num,
-                               GimpImageWindow *window)
+gimp_image_window_switch_active_shell (GimpImageWindow* window,
+                                       GimpDisplayShell* shell)
 {
   GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
-  GimpDisplayShell       *shell;
   GimpDisplay            *active_display;
 
-  shell = GIMP_DISPLAY_SHELL (gtk_notebook_get_nth_page (notebook, page_num));
-
   if (shell == private->active_shell)
     return;
 
   gimp_image_window_disconnect_from_active_shell (window);
 
+  g_print ("gimp_image_window_switch_active_shell\n");
   GIMP_LOG (WM, "GimpImageWindow %p, private->active_shell = %p; \n",
             window, shell);
   private->active_shell = shell;
 
+  if (shell) {
   gimp_window_set_primary_focus_widget (GIMP_WINDOW (window),
                                         shell->canvas);
 
@@ -1655,6 +1860,31 @@
   g_signal_connect (private->active_shell, "notify::icon",
                     G_CALLBACK (gimp_image_window_shell_icon_notify),
                     window);
+  if (private->toolbar_window)
+    g_signal_connect (private->active_shell, "destroy",
+                      G_CALLBACK (gimp_image_window_shell_destroy),
+                      window);
+  }
+}
+
+static void
+gimp_image_window_switch_page (GtkNotebook     *notebook,
+                               gpointer         page,
+                               gint             page_num,
+                               GimpImageWindow *window)
+{
+  GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+  GimpDisplayShell       *shell;
+  GimpDisplay            *active_display;
+
+  shell = GIMP_DISPLAY_SHELL (gtk_notebook_get_nth_page (notebook, page_num));
+
+  if (shell == private->active_shell)
+    return;
+
+  g_print ("gimp_image_window_switch_page:toolbar_window=%d\n", private->toolbar_window);
+  gimp_image_window_switch_active_shell (window, shell);
+  active_display = private->active_shell->display;
 
   gtk_window_set_title (GTK_WINDOW (window), shell->title);
   gtk_window_set_icon (GTK_WINDOW (window), shell->icon);
@@ -1689,30 +1919,43 @@
 }
 
 static void
-gimp_image_window_disconnect_from_active_shell (GimpImageWindow *window)
+gimp_image_window_disconnect_from_shell (GimpImageWindow *window, GimpDisplayShell* shell)
 {
-  GimpImageWindowPrivate *private        = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
   GimpDisplay            *active_display = NULL;
 
-  if (! private->active_shell)
+  if (! GIMP_IS_DISPLAY_SHELL (shell) )
     return;
 
-  active_display = private->active_shell->display;
+  active_display = shell->display;
 
   if (active_display)
     g_signal_handlers_disconnect_by_func (active_display,
                                           gimp_image_window_image_notify,
                                           window);
 
-  g_signal_handlers_disconnect_by_func (private->active_shell,
+  g_signal_handlers_disconnect_by_func (shell,
                                         gimp_image_window_shell_scaled,
                                         window);
-  g_signal_handlers_disconnect_by_func (private->active_shell,
+  g_signal_handlers_disconnect_by_func (shell,
                                         gimp_image_window_shell_title_notify,
                                         window);
-  g_signal_handlers_disconnect_by_func (private->active_shell,
+  g_signal_handlers_disconnect_by_func (shell,
                                         gimp_image_window_shell_icon_notify,
                                         window);
+  g_signal_handlers_disconnect_by_func (shell,
+                                        gimp_image_window_shell_destroy,
+                                        window);
+}
+
+static void
+gimp_image_window_disconnect_from_active_shell (GimpImageWindow *window)
+{
+  GimpImageWindowPrivate *private        = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+
+  if (! private->active_shell)
+    return;
+
+  gimp_image_window_disconnect_from_shell (window, private->active_shell);
 
   if (private->menubar_manager)
     gimp_image_window_hide_tooltip (private->menubar_manager, window);
@@ -1728,18 +1971,22 @@
   GList                  *children;
   GtkWidget              *view;
 
+  g_print("gimp_image_window_image_notify:toolbar_window=%d\n", private->toolbar_window);
   gimp_image_window_session_update (window,
                                     display,
                                     NULL /*new_entry_id*/);
 
   tab_label = gtk_notebook_get_tab_label (GTK_NOTEBOOK (private->notebook),
                                           GTK_WIDGET (gimp_display_get_shell (display)));
-  children  = gtk_container_get_children (GTK_CONTAINER (tab_label));
-  view      = GTK_WIDGET (children->data);
-  g_list_free (children);
 
-  gimp_view_set_viewable (GIMP_VIEW (view),
-                          GIMP_VIEWABLE (gimp_display_get_image (display)));
+  if (tab_label) {
+    children  = gtk_container_get_children (GTK_CONTAINER (tab_label));
+    view      = GTK_WIDGET (children->data);
+    g_list_free (children);
+
+    gimp_view_set_viewable (GIMP_VIEW (view),
+                            GIMP_VIEWABLE (gimp_display_get_image (display)));
+  }
 
   gimp_ui_manager_update (private->menubar_manager, display);
 }
@@ -1815,6 +2062,8 @@
            */
           if (strcmp (new_entry_id, GIMP_SINGLE_IMAGE_WINDOW_ENTRY_ID) == 0)
             {
+			  private->toolbar_window = FALSE;
+			  gtk_widget_set_visible (private->notebook, TRUE);
               gimp_image_window_session_apply (window, new_entry_id);
             }
         }
@@ -1835,6 +2084,9 @@
                   ! gimp_display_get_image (private->active_shell->display) &&
                   g_list_length (private->shells) <= 1)
                 {
+				  // FIXME
+				  private->toolbar_window = TRUE;
+				  gtk_widget_set_visible (private->notebook, FALSE);
                   gimp_image_window_session_apply (window, new_entry_id);
                 }
             }
@@ -1844,6 +2096,7 @@
                * shall session manage ourself until single-window mode
                * is exited
                */
+			  private->toolbar_window = FALSE;
               gimp_image_window_session_apply (window, new_entry_id);
             }
         }
@@ -1912,6 +2165,39 @@
 }
 
 static void
+gimp_image_window_shell_destroy (GimpDisplayShell *shell,
+                                GimpImageWindow  *window)
+{
+  GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+  GimpDisplay            *active_display;
+  GimpDisplayShell       *default_shell;
+
+  if (shell != private->active_shell)
+	return;
+  g_print ("gimp_image_window_shell_destroy:toolbar_window=%d\n", private->toolbar_window);
+
+
+  default_shell = gimp_image_window_get_shell (window, 0);
+  gimp_image_window_switch_active_shell (window, default_shell);
+
+  active_display = private->active_shell->display;
+
+  gtk_window_set_title (GTK_WINDOW (window), private->active_shell->title);
+  gtk_window_set_icon (GTK_WINDOW (window), private->active_shell->icon);
+
+  gimp_display_shell_appearance_update (private->active_shell);
+
+  gimp_image_window_session_update (window,
+                                    active_display,
+                                    NULL /*new_entry_id*/);
+
+  gimp_context_set_display (gimp_get_user_context (private->gimp),
+                            active_display);
+
+  gimp_ui_manager_update (private->menubar_manager, active_display);
+}
+
+static void
 gimp_image_window_shell_close_button_callback (GimpDisplayShell *shell)
 {
   if (shell)
@@ -1959,3 +2245,73 @@
 
   return hbox;
 }
+static void
+gimp_image_window_rotate_left_clicked (GtkWidget* widget,
+                                       GimpImageWindow *window)
+{
+  GimpDisplayShell *shell  = gimp_image_window_get_active_shell (window);
+  gdouble direction = shell->mirrored ? -1: 1;
+  shell->rotate_angle = fmod(round((shell->rotate_angle- direction * ROTATE_UNIT_ANGLE) /
+                                   ROTATE_UNIT_ANGLE) * ROTATE_UNIT_ANGLE, 360);
+  gtk_widget_queue_draw(GTK_WIDGET(shell));
+}
+
+static void
+gimp_image_window_rotate_right_clicked (GtkWidget* widget,
+                                        GimpImageWindow *window)
+{
+  GimpDisplayShell *shell  = gimp_image_window_get_active_shell (window);
+  gdouble direction = shell->mirrored ? -1: 1;
+  shell->rotate_angle = fmod(round((shell->rotate_angle + direction * ROTATE_UNIT_ANGLE) /
+                                   ROTATE_UNIT_ANGLE) * ROTATE_UNIT_ANGLE, 360);
+  gtk_widget_queue_draw(GTK_WIDGET(shell));
+}
+
+static void
+gimp_image_window_flip_side_clicked (GtkWidget* widget,
+                                     GimpImageWindow *window)
+{
+  GimpDisplayShell *shell  = gimp_image_window_get_active_shell (window);
+  shell->mirrored = !shell->mirrored;
+  gtk_widget_queue_draw(GTK_WIDGET(shell));
+}
+
+static void
+gimp_image_window_reset_view_clicked (GtkWidget* widget,
+                                     GimpImageWindow *window)
+{
+  GimpDisplayShell *shell  = gimp_image_window_get_active_shell (window);
+  shell->mirrored = FALSE;
+  shell->rotate_angle = 0;
+  gimp_display_shell_scale(shell, GIMP_ZOOM_TO, 1.0, GIMP_ZOOM_FOCUS_BEST_GUESS);
+  gtk_widget_queue_draw(GTK_WIDGET(shell));
+}
+
+void
+gimp_image_window_link_foreign_active_shell (GimpImageWindow* window,
+                                             GimpDisplayShell* shell)
+{
+  GimpImageWindowPrivate *private = GIMP_IMAGE_WINDOW_GET_PRIVATE (window);
+  GimpDisplay *active_display;
+
+  g_return_if_fail (GIMP_IS_IMAGE_WINDOW (window));
+  g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell));
+
+  g_print("link foreign active shell:%d.\n", gimp_image_window_is_toolbar_window(window));
+  gimp_image_window_switch_active_shell(window, shell);
+
+  active_display = private->active_shell->display;
+
+  gtk_window_set_title (GTK_WINDOW (window), shell->title);
+  gtk_window_set_icon (GTK_WINDOW (window), shell->icon);
+
+  gimp_display_shell_appearance_update (private->active_shell);
+
+  gimp_image_window_session_update (window,
+                                    active_display,
+                                    NULL /*new_entry_id*/);
+
+  gimp_context_set_display (gimp_get_user_context (private->gimp),
+                            active_display);
+  gimp_ui_manager_update (private->menubar_manager, active_display);
+}
diff -Naur gimp-2.8.14/app/display/gimpimagewindow.h gimp-2.8.14-new/app/display/gimpimagewindow.h
--- gimp-2.8.14/app/display/gimpimagewindow.h	2015-01-27 17:28:36.970833804 +0800
+++ gimp-2.8.14-new/app/display/gimpimagewindow.h	2015-01-27 17:48:55.340751582 +0800
@@ -92,4 +92,9 @@
 
 void               gimp_image_window_keep_canvas_pos      (GimpImageWindow  *window);
 
+gboolean           gimp_image_window_is_toolbar_window    (GimpImageWindow  *window);
+
+void               gimp_image_window_link_foreign_active_shell (GimpImageWindow *window, 
+                                                                GimpDisplayShell *shell);
+
 #endif /* __GIMP_IMAGE_WINDOW_H__ */
diff -Naur gimp-2.8.14/app/display/gimpmotionbuffer.c gimp-2.8.14-new/app/display/gimpmotionbuffer.c
--- gimp-2.8.14/app/display/gimpmotionbuffer.c	2015-01-27 17:28:36.969833804 +0800
+++ gimp-2.8.14-new/app/display/gimpmotionbuffer.c	2015-01-27 17:48:55.341751582 +0800
@@ -264,6 +264,9 @@
   gdouble  delta_time  = 0.001;
   gdouble  delta_x     = 0.0;
   gdouble  delta_y     = 0.0;
+  gdouble  delta_pressure = 0.0;
+  gdouble  dir_delta_x = 0.0;
+  gdouble  dir_delta_y = 0.0;
   gdouble  distance    = 1.0;
 
   g_return_val_if_fail (GIMP_IS_MOTION_BUFFER (buffer), FALSE);
@@ -295,6 +298,7 @@
 
       delta_x = last_dir_event.x - coords->x;
       delta_y = last_dir_event.y - coords->y;
+      delta_pressure = last_dir_event.pressure - coords->pressure;
 
       /*  Events with distances less than the screen resolution are
        *  not worth handling.
@@ -302,7 +306,8 @@
       filter = MIN (1.0 / scale_x, 1.0 / scale_y) / 2.0;
 
       if (fabs (delta_x) < filter &&
-          fabs (delta_y) < filter)
+          fabs (delta_y) < filter &&
+          delta_pressure == 0.0)
         {
           return FALSE;
         }
diff -Naur gimp-2.8.14/app/display/Makefile.am gimp-2.8.14-new/app/display/Makefile.am
--- gimp-2.8.14/app/display/Makefile.am	2015-01-27 17:28:36.975833803 +0800
+++ gimp-2.8.14-new/app/display/Makefile.am	2015-01-27 17:48:55.326751583 +0800
@@ -142,7 +142,9 @@
 	gimpstatusbar.c				\
 	gimpstatusbar.h				\
 	gimptooldialog.c			\
-	gimptooldialog.h
+	gimptooldialog.h			\
+	gimpdisplayshell-rotate.c			\
+	gimpdisplayshell-rotate.h
 
 libappdisplay_a_built_sources = display-enums.c
 
diff -Naur gimp-2.8.14/app/gui/gimpuiconfigurer.c gimp-2.8.14-new/app/gui/gimpuiconfigurer.c
--- gimp-2.8.14/app/gui/gimpuiconfigurer.c	2015-01-27 17:28:36.959833804 +0800
+++ gimp-2.8.14-new/app/gui/gimpuiconfigurer.c	2015-01-27 17:48:55.342751582 +0800
@@ -418,42 +418,50 @@
   GimpImageWindow  *active_window = NULL;
 
   /* The last display shell remains in its window */
-  while (gimp_image_window_get_n_shells (source_image_window) > 1)
+  while (gimp_image_window_get_n_shells (source_image_window) >= 1)
     {
       GimpImageWindow  *new_image_window;
       GimpDisplayShell *shell;
 
-      /* Create a new image window */
-      new_image_window = gimp_image_window_new (ui_configurer->p->gimp,
-                                                NULL,
-                                                global_menu_factory,
-                                                gimp_dialog_factory_get_singleton ());
       /* Move the shell there */
-      shell = gimp_image_window_get_shell (source_image_window, 1);
+      shell = gimp_image_window_get_shell (source_image_window, 0);
 
-      if (shell == active_shell)
-        active_window = new_image_window;
-
-      g_object_ref (shell);
-      gimp_image_window_remove_shell (source_image_window, shell);
-      gimp_image_window_add_shell (new_image_window, shell);
-      g_object_unref (shell);
-
-      /* FIXME: If we don't set a size request here the window will be
-       * too small. Get rid of this hack and fix it the proper way
-       */
-      gtk_widget_set_size_request (GTK_WIDGET (new_image_window), 640, 480);
-
-      /* Show after we have added the shell */
-      gtk_widget_show (GTK_WIDGET (new_image_window));
+	  if (shell && shell->display && gimp_display_get_image(shell->display)) {
+		g_print("Separate\n");
+        /* Create a new image window */
+        new_image_window = gimp_image_window_new (ui_configurer->p->gimp,
+                                                  NULL,
+                                                  global_menu_factory,
+                                                  gimp_dialog_factory_get_singleton ());
+        g_object_ref (shell);
+        gimp_image_window_remove_shell (source_image_window, shell);
+        gimp_image_window_add_shell (new_image_window, shell);
+	    g_object_set(G_OBJECT(new_image_window), "toolbar-window", FALSE, NULL);
+        g_object_unref (shell);
+
+        /* FIXME: If we don't set a size request here the window will be
+         * too small. Get rid of this hack and fix it the proper way
+         */
+        gtk_widget_set_size_request (GTK_WIDGET (new_image_window), 640, 480);
+
+        /* Show after we have added the shell */
+        gtk_widget_show (GTK_WIDGET (new_image_window));
+      } else {
+        g_print("Close empty display\n");
+        gimp_display_close (shell->display);
+        g_print("/Close empty display\n");
+      }
     }
-
+  g_print("Separate done\n");
+#if 0
+  // FIXME: We should call gtk_window_present for active_window.
   /* If none of the shells were active, I assume the first one is. */
   if (active_window == NULL)
     active_window = source_image_window;
 
   /* The active tab must stay at the top of the windows stack. */
   gtk_window_present (GTK_WINDOW (active_window));
+#endif
 }
 
 /**
@@ -465,16 +473,21 @@
 static void
 gimp_ui_configurer_configure_for_single_window (GimpUIConfigurer *ui_configurer)
 {
-  Gimp             *gimp              = ui_configurer->p->gimp;
-  GList            *windows           = gimp_get_image_windows (gimp);
-  GList            *iter              = NULL;
-  GimpImageWindow  *uber_image_window = NULL;
+  Gimp            *gimp               = ui_configurer->p->gimp;
+  GList           *windows            = gimp_get_image_windows (gimp);
+  GList           *iter               = NULL;
+  GimpImageWindow *uber_image_window  = NULL;
   GimpDisplay      *active_display    = gimp_context_get_display (gimp_get_user_context (gimp));
   GimpDisplayShell *active_shell      = gimp_display_get_shell (active_display);
+  int              i;
 
   /* Get and setup the window to put everything in */
   uber_image_window = gimp_ui_configurer_get_uber_window (ui_configurer);
+  g_print("uber_image_window = %lx\n", uber_image_window);
+  g_print("Set 'toolbar-window' flags off.\n");
+  g_object_set (G_OBJECT(uber_image_window), "toolbar-window", FALSE, NULL);
 
+  g_print("Move columns.\n");
   /* Mve docks to the left and right side of the image window */
   gimp_ui_configurer_move_docks_to_columns (ui_configurer,
                                             uber_image_window);
@@ -488,6 +501,7 @@
       if (image_window == uber_image_window)
         continue;
 
+      g_print("Move shells.\n");
       /* Put the displays in the rest of the image windows into
        * the uber image window
        */
@@ -498,8 +512,21 @@
       gimp_image_window_destroy (image_window);
     }
 
+  if (gimp_image_window_get_n_shells (uber_image_window) > 1) {
+    for (i = 0; i < gimp_image_window_get_n_shells (uber_image_window); i ++ ) {
+	  GimpDisplayShell *shell = gimp_image_window_get_shell (uber_image_window, i);
+      GimpImage        *image = gimp_display_get_image (shell->display);
+	  if (!image) {
+        gimp_display_close (shell->display);
+	    i --;
+	  }
+    }
+  }
+#if 0
+  // FIXME: Handling active window differs from original source code.
   /* Ensure the context shell remains active after mode switch. */
   gimp_image_window_set_active_shell (uber_image_window, active_shell);
+#endif
 
   g_list_free (windows);
 }
@@ -517,6 +544,7 @@
   GList *windows = gimp_get_image_windows (gimp);
   GList *iter    = NULL;
 
+  g_print ("Dump window list\n");
   for (iter = windows; iter; iter = g_list_next (iter))
     {
       GimpImageWindow *image_window = GIMP_IMAGE_WINDOW (iter->data);
@@ -524,9 +552,37 @@
       gimp_ui_configurer_separate_docks (ui_configurer, image_window);
 
       gimp_ui_configurer_separate_shells (ui_configurer, image_window);
-    }
 
+	  /* Destroy the window */
+      gimp_image_window_destroy (image_window);
+    }
+  {
+	GimpDisplay      *new_display;
+	GimpImageWindow  *new_image_window;
+
+	g_print("New Toolbar Window\n");
+	/* Create a new image window */
+	new_display      = GIMP_DISPLAY(gimp_create_display (gimp, NULL, GIMP_UNIT_PIXEL, 1.0));
+	g_return_if_fail (GIMP_IS_DISPLAY (new_display));
+
+	g_print("Set up 'toolbar-window' flags.\n");
+	new_image_window = gimp_display_shell_get_window (gimp_display_get_shell (new_display));
+	g_object_set (G_OBJECT(new_image_window), "toolbar-window", TRUE, NULL);
+
+	g_print("Show Toolbar Window.\n");
+    /* Show after we have added the shell */
+	gtk_widget_show (GTK_WIDGET (new_image_window));
+  }
   g_list_free (windows);
+  {
+  GList            *iter         = gimp_get_display_iter (gimp);
+  for (; iter; iter = g_list_next(iter)) {
+	GimpDisplay      *display      = iter->data;
+    GimpDisplayShell *shell        = gimp_display_get_shell (display);
+    GimpImageWindow  *image_window = gimp_display_shell_get_window (shell);
+	g_print("display=%lx, shell=%lx, image=%lx, image_window=%lx\n", display, shell, gimp_display_get_image(display),image_window);
+  }
+  }
 }
 
 /**
@@ -540,11 +596,22 @@
 gimp_ui_configurer_get_uber_window (GimpUIConfigurer *ui_configurer)
 {
   Gimp             *gimp         = ui_configurer->p->gimp;
-  GimpDisplay      *display      = gimp_get_display_iter (gimp)->data;
-  GimpDisplayShell *shell        = gimp_display_get_shell (display);
-  GimpImageWindow  *image_window = gimp_display_shell_get_window (shell);
-
-  return image_window;
+  GList            *iter         = gimp_get_display_iter (gimp);
+  GimpImageWindow  *image_window = NULL;
+  GimpImageWindow  *last_valid_window = NULL;
+
+  for (; iter; iter = g_list_next(iter)) {
+	GimpDisplay      *display      = iter->data;
+    GimpDisplayShell *shell        = gimp_display_get_shell (display);
+    image_window = gimp_display_shell_get_window (shell);
+	g_print("display=%lx, shell=%lx, image=%lx, image_window=%lx\n", display, shell, gimp_display_get_image(display),image_window);
+
+	if (image_window && gimp_image_window_is_toolbar_window(image_window))
+	  return image_window;
+	if (image_window)
+	  last_valid_window = image_window;
+  }
+  return last_valid_window;
 }
 
 /**
diff -Naur gimp-2.8.14/app/gui/gui.c gimp-2.8.14-new/app/gui/gui.c
--- gimp-2.8.14/app/gui/gui.c	2015-01-27 17:28:36.958833804 +0800
+++ gimp-2.8.14-new/app/gui/gui.c	2015-01-27 17:48:55.343751582 +0800
@@ -568,6 +568,11 @@
 
       shell = gimp_display_get_shell (display);
 
+      if (!gui_config->single_window_mode) {
+        GObject* w = G_OBJECT(gimp_display_shell_get_window (shell));
+	g_object_set (w, "toolbar-window", TRUE, NULL);
+      }
+
       if (gui_config->restore_session)
         session_restore (gimp);
 
diff -Naur gimp-2.8.14/app/gui/gui-vtable.c gimp-2.8.14-new/app/gui/gui-vtable.c
--- gimp-2.8.14/app/gui/gui-vtable.c	2015-01-27 17:28:36.957833804 +0800
+++ gimp-2.8.14-new/app/gui/gui-vtable.c	2015-01-27 17:48:55.343751582 +0800
@@ -35,6 +35,7 @@
 #include "core/gimp.h"
 #include "core/gimp-utils.h"
 #include "core/gimpbrush.h"
+#include "core/gimpmypaintbrush.h"
 #include "core/gimpcontainer.h"
 #include "core/gimpcontext.h"
 #include "core/gimpgradient.h"
@@ -49,6 +50,7 @@
 
 #include "widgets/gimpactiongroup.h"
 #include "widgets/gimpbrushselect.h"
+#include "widgets/gimpmypaintbrushselect.h"
 #include "widgets/gimpdialogfactory.h"
 #include "widgets/gimpdocked.h"
 #include "widgets/gimpfontselect.h"
@@ -65,6 +67,7 @@
 #include "display/gimpdisplay.h"
 #include "display/gimpdisplay-foreach.h"
 #include "display/gimpdisplayshell.h"
+#include "display/gimpimagewindow.h" /* gimp-painter-2.7 */
 #include "display/gimpsinglewindowstrategy.h"
 #include "display/gimpmultiwindowstrategy.h"
 
@@ -305,6 +308,12 @@
           /* The display was not empty */
           display = NULL;
         }
+      {
+	    GimpDisplayShell *shell = gimp_display_get_shell (GIMP_DISPLAY(display));
+	    GimpImageWindow  *window = gimp_display_shell_get_window (shell);
+            if (window && gimp_image_window_is_toolbar_window(window))
+              display = NULL;
+      }
     }
 
   return display;
@@ -349,7 +358,7 @@
   GimpContext *context = gimp_get_user_context (gimp);
   GimpDisplay *display = GIMP_DISPLAY (gui_get_empty_display (gimp));
 
-  if (display)
+  if (display && image)
     {
       gimp_display_fill (display, image, unit, scale);
     }
@@ -466,6 +475,12 @@
       dialog_role = "gimp-pattern-selection";
       help_id     = GIMP_HELP_PATTERN_DIALOG;
     }
+  else if (gimp_container_get_children_type (container) == GIMP_TYPE_MYPAINT_BRUSH)
+    {
+      dialog_type = GIMP_TYPE_MYPAINT_BRUSH_SELECT;
+      dialog_role = "gimp-mypaint-brush-selection";
+      help_id     = GIMP_HELP_MYPAINT_BRUSH_DIALOG;
+    }
 
   if (dialog_type != G_TYPE_NONE)
     {
@@ -559,6 +574,9 @@
     klass = g_type_class_peek (GIMP_TYPE_PALETTE_SELECT);
   else if (gimp_container_get_children_type (container) == GIMP_TYPE_PATTERN)
     klass = g_type_class_peek (GIMP_TYPE_PATTERN_SELECT);
+  else if (gimp_container_get_children_type (container) == GIMP_TYPE_MYPAINT_BRUSH)
+    klass = g_type_class_peek (GIMP_TYPE_MYPAINT_BRUSH_SELECT);
+
 
   if (klass)
     {
diff -Naur gimp-2.8.14/app/Makefile.am gimp-2.8.14-new/app/Makefile.am
--- gimp-2.8.14/app/Makefile.am	2015-01-27 17:28:36.750833818 +0800
+++ gimp-2.8.14-new/app/Makefile.am	2015-01-27 17:48:39.668752639 +0800
@@ -86,7 +86,7 @@
 
 libapp_a_SOURCES = $(libapp_sources) $(libapp_generated_sources)
 
-gimp_2_8_SOURCES = $(libapp_sources) main.c
+gimp_2_8_SOURCES = $(libapp_sources) main.c dummy.cpp
 
 
 if PLATFORM_OSX
@@ -206,7 +206,7 @@
 
 if ENABLE_GIMP_CONSOLE
 
-gimp_console_2_8_SOURCES = $(libapp_sources) main.c
+gimp_console_2_8_SOURCES = $(libapp_sources) main.c dummy.cpp
 
 gimp_console_2_8_CPPFLAGS = \
 	$(AM_CPPFLAGS)			\
diff -Naur gimp-2.8.14/app/menus/menus.c gimp-2.8.14-new/app/menus/menus.c
--- gimp-2.8.14/app/menus/menus.c	2015-01-27 17:28:36.837833813 +0800
+++ gimp-2.8.14-new/app/menus/menus.c	2015-01-27 17:48:55.344751582 +0800
@@ -209,6 +209,14 @@
                                       "brushes-menu.xml", plug_in_menus_setup,
                                       NULL);
 
+  gimp_menu_factory_manager_register (global_menu_factory, "<MypaintBrushes>",
+                                      "mypaint-brushes",
+                                      "plug-in",
+                                      NULL,
+                                      "/mypaint-brushes-popup",
+                                      "mypaint-brushes-menu.xml", plug_in_menus_setup,
+                                      NULL);
+
   gimp_menu_factory_manager_register (global_menu_factory, "<Dynamics>",
                                       "dynamics",
                                       "plug-in",
diff -Naur gimp-2.8.14/app/paint/gimpbrushcore.c gimp-2.8.14-new/app/paint/gimpbrushcore.c
--- gimp-2.8.14/app/paint/gimpbrushcore.c	2015-01-27 17:28:36.786833816 +0800
+++ gimp-2.8.14-new/app/paint/gimpbrushcore.c	2015-01-27 17:48:55.349751581 +0800
@@ -37,7 +37,8 @@
 #include "core/gimperror.h"
 #include "core/gimpimage.h"
 #include "core/gimpmarshal.h"
-
+#include "core/gimpbrush-transform.h" /* gimp-painter-2.7 */
+#include "core/gimppattern.h" /* gimp-painter-2.7 */
 #include "gimpbrushcore.h"
 #include "gimpbrushcore-kernels.h"
 
@@ -52,6 +53,7 @@
 {
   SET_BRUSH,
   SET_DYNAMICS,
+  SET_TEXTURE,
   LAST_SIGNAL
 };
 
@@ -65,6 +67,12 @@
                                                      GimpPaintOptions *paint_options,
                                                      const GimpCoords *coords,
                                                      GError          **error);
+#if 0
+/* old parameters */
+                                                    GimpPaintOptions *paint_options,
+                                                    guint32           time);
+#endif
+
 static gboolean  gimp_brush_core_pre_paint          (GimpPaintCore    *core,
                                                      GimpDrawable     *drawable,
                                                      GimpPaintOptions *paint_options,
@@ -84,12 +92,13 @@
                                                      GimpDrawable     *drawable,
                                                      GimpPaintOptions *paint_options,
                                                      const GimpCoords *coords);
-
 static void      gimp_brush_core_real_set_brush     (GimpBrushCore    *core,
                                                      GimpBrush        *brush);
 static void      gimp_brush_core_real_set_dynamics  (GimpBrushCore    *core,
                                                      GimpDynamics     *dynamics);
-
+/* gimp-painter-2.7 */
+static void      gimp_brush_core_real_set_texture   (GimpBrushCore    *core,
+                                                     GimpPattern       *texture);
 static const TempBuf * gimp_brush_core_subsample_mask   (GimpBrushCore    *core,
                                                          const TempBuf    *mask,
                                                          gdouble           x,
@@ -99,6 +108,11 @@
                                                          gdouble           x,
                                                          gdouble           y,
                                                          gdouble           pressure);
+/* gimp-painter-2.7 */
+const static TempBuf * gimp_brush_core_texturize_mask   (GimpBrushCore *core,
+                                                         const TempBuf       *brush_mask,
+                                                         gdouble        x,
+                                                         gdouble        y);
 static const TempBuf * gimp_brush_core_solidify_mask    (GimpBrushCore    *core,
                                                          const TempBuf    *brush_mask,
                                                          gdouble           x,
@@ -110,6 +124,12 @@
 
 static void      gimp_brush_core_invalidate_cache       (GimpBrush        *brush,
                                                          GimpBrushCore    *core);
+#if 0
+static inline void rotate_pointers                 (gulong          **p,
+                                                    guint32           n);
+static gdouble   gimp_brush_core_clamp_brush_scale (GimpBrushCore    *core,
+                                                    gdouble           scale);
+#endif
 
 /*  brush pipe utility functions  */
 static void      gimp_brush_core_paint_line_pixmap_mask (GimpImage        *dest,
@@ -157,6 +177,16 @@
                   G_TYPE_NONE, 1,
                   GIMP_TYPE_DYNAMICS);
 
+  core_signals[SET_TEXTURE] =
+    g_signal_new ("set-texture",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (GimpBrushCoreClass, set_texture),
+                  NULL, NULL,
+                  gimp_marshal_VOID__OBJECT,
+                  G_TYPE_NONE, 1,
+                  GIMP_TYPE_PATTERN);
+
   object_class->finalize                    = gimp_brush_core_finalize;
 
   paint_core_class->start                   = gimp_brush_core_start;
@@ -171,6 +201,7 @@
 
   klass->set_brush                          = gimp_brush_core_real_set_brush;
   klass->set_dynamics                       = gimp_brush_core_real_set_dynamics;
+  klass->set_texture                        = gimp_brush_core_real_set_texture;
 }
 
 static void
@@ -181,6 +212,7 @@
   core->main_brush                   = NULL;
   core->brush                        = NULL;
   core->dynamics                     = NULL;
+  core->texture                      = NULL;
   core->spacing                      = 1.0;
   core->scale                        = 1.0;
   core->angle                        = 1.0;
@@ -197,8 +229,12 @@
 
   core->last_subsample_brush_mask    = NULL;
   core->subsample_cache_invalid      = FALSE;
+  /* gimp-painter-2.7 */
+  core->texturized_brush             = NULL;
 
   core->rand                         = g_rand_new ();
+  
+  core->ignore_scale                 = FALSE;
 
   for (i = 0; i < BRUSH_CORE_SOLID_SUBSAMPLE; i++)
     {
@@ -248,6 +284,25 @@
           core->solid_brushes[i][j] = NULL;
         }
 
+#if 0
+  if (core->transform_brush)
+    {
+      temp_buf_free (core->transform_brush);
+      core->transform_brush = NULL;
+    }
+
+  if (core->transform_pixmap)
+    {
+      temp_buf_free (core->transform_pixmap);
+      core->transform_pixmap = NULL;
+    }
+#endif    
+  if (core->texturized_brush)
+    {
+      temp_buf_free (core->texturized_brush);
+      core->texturized_brush = NULL;
+    }
+
   if (core->rand)
     {
       g_rand_free (core->rand);
@@ -277,6 +332,12 @@
       g_object_unref (core->dynamics);
       core->dynamics = NULL;
     }
+    
+  if (core->texture)
+    {
+      g_object_unref (core->texture);
+      core->texture = NULL;
+    }
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -360,7 +421,7 @@
                             guint32           time)
 {
   GimpBrushCore *core = GIMP_BRUSH_CORE (paint_core);
-
+  
   if (paint_state == GIMP_PAINT_STATE_MOTION)
     {
       core->brush = core->main_brush;
@@ -376,11 +437,27 @@
 {
   GimpBrushCore *core    = GIMP_BRUSH_CORE (paint_core);
   GimpContext   *context = GIMP_CONTEXT (paint_options);
+#if 0
+  GimpBrush     *brush;
+  GimpDynamics  *dynamics;
+#endif
+  GimpPattern   *texture;
 
   gimp_brush_core_set_brush (core, gimp_context_get_brush (context));
 
   gimp_brush_core_set_dynamics (core, gimp_context_get_dynamics (context));
 
+
+  if (paint_options->texture_options->use_texture)
+    {
+      texture = gimp_context_get_pattern (GIMP_CONTEXT (paint_options));
+
+      if (core->texture != texture)
+        gimp_brush_core_set_texture (core, texture);
+    }
+  else
+        gimp_brush_core_set_texture (core, NULL);
+
   if (! core->main_brush)
     {
       g_set_error_literal (error, GIMP_ERROR, GIMP_FAILED,
@@ -476,7 +553,19 @@
 
   gimp_paint_core_get_last_coords (paint_core, &last_coords);
   gimp_paint_core_get_current_coords (paint_core, &current_coords);
+#if 0  
+  if (paint_core->stroke_buffer)
+    {
+      current_coords = gimp_paint_core_get_smoothed_coords (paint_core,
+                                                            paint_options, &current_coords);
+      gimp_paint_core_set_current_coords (paint_core, &current_coords);
+    }
 
+#endif
+#if 1
+  /*Zero sized brushes are unfit for interpolate,
+   * so we just let paint core fail onits own
+   **/
   gimp_avoid_exact_integer (&last_coords.x);
   gimp_avoid_exact_integer (&last_coords.y);
   gimp_avoid_exact_integer (&current_coords.x);
@@ -504,6 +593,7 @@
   pixel_dist    = gimp_vector2_length (&delta_vec);
   pixel_initial = paint_core->pixel_dist;
 
+#endif
   /*  Zero sized brushes are unfit for interpolate, so we just let
    *  paint core fail on its own
    */
@@ -884,6 +974,19 @@
     g_object_ref (core->dynamics);
 }
 
+static void
+gimp_brush_core_real_set_texture (GimpBrushCore *core,
+                                  GimpPattern   *texture)
+{
+  if (core->texture)
+    g_object_unref (core->texture);
+
+  core->texture = texture;
+
+  if (core->texture)
+    g_object_ref (core->texture);
+}
+
 void
 gimp_brush_core_set_brush (GimpBrushCore *core,
                            GimpBrush     *brush)
@@ -906,6 +1009,165 @@
     g_signal_emit (core, core_signals[SET_DYNAMICS], 0, dynamics);
 }
 
+/* gimp-painter-2.7 */
+void
+gimp_brush_core_set_texture (GimpBrushCore *core,
+                             GimpPattern   *texture)
+{
+  g_return_if_fail (GIMP_IS_BRUSH_CORE (core));
+  g_return_if_fail (texture == NULL || GIMP_IS_PATTERN (texture));
+
+  g_signal_emit (core, core_signals[SET_TEXTURE], 0, texture);
+}
+
+#if 0
+void
+gimp_brush_core_create_boundary (GimpBrushCore    *core,
+                                 GimpPaintOptions *paint_options)
+{
+  TempBuf *mask = NULL;
+  gdouble  scale;
+
+  g_return_if_fail (GIMP_IS_BRUSH_CORE (core));
+  g_return_if_fail (core->main_brush != NULL);
+  g_return_if_fail (core->brush_bound_segs == NULL);
+
+  scale = paint_options->brush_size /
+          MAX (core->main_brush->mask->width,
+               core->main_brush->mask->height);
+
+  if (scale > 0.0)
+    {
+      scale = gimp_brush_core_clamp_brush_scale (core, scale);
+
+      /* Generated brushes are a bit special */
+      if (GIMP_IS_BRUSH_GENERATED (core->main_brush))
+        {
+          GimpBrushGenerated *generated_brush;
+          gdouble             ratio;
+
+          generated_brush = GIMP_BRUSH_GENERATED (core->main_brush);
+
+          ratio = gimp_brush_generated_get_aspect_ratio (generated_brush);
+
+          g_signal_handlers_block_by_func (generated_brush,
+                                           gimp_brush_core_invalidate_cache,
+                                           core);
+
+          gimp_brush_generated_set_aspect_ratio (generated_brush, 1.0);
+
+          mask = gimp_brush_transform_mask (core->main_brush,
+                                            1.0, 1.0, 0.0, 1.0);
+
+          gimp_brush_generated_set_aspect_ratio (generated_brush, ratio);
+
+          g_signal_handlers_unblock_by_func (generated_brush,
+                                             gimp_brush_core_invalidate_cache,
+                                             core);
+        }
+      else
+        {
+          mask = gimp_brush_transform_mask (core->main_brush,
+                                            1.0, 1.0, 0.0, 1.0);
+        }
+    }
+
+  if (mask)
+    {
+      PixelRegion PR = { 0, };
+
+      pixel_region_init_temp_buf (&PR, mask,
+                                  0, 0, mask->width, mask->height);
+
+      /* Large, complex brush outlines are a performance problem.
+       * Smooth the mask in order to obtain a simpler boundary.
+       */
+      if (mask->width > 32 && mask->height > 32)
+        smooth_region (&PR);
+
+      core->brush_bound_segs = boundary_find (&PR, BOUNDARY_WITHIN_BOUNDS,
+                                              0, 0, PR.w, PR.h,
+                                              0,
+                                              &core->n_brush_bound_segs);
+
+      core->brush_bound_width  = mask->width;
+      core->brush_bound_height = mask->height;
+
+      temp_buf_free (mask);
+    }
+}
+
+gboolean
+gimp_brush_core_get_transform (GimpBrushCore *core,
+                               GimpMatrix3   *matrix)
+{
+  gdouble scale;
+  gdouble angle;
+  gdouble aspect_ratio;
+  gdouble height;
+  gdouble width;
+  gdouble scale_x;
+  gdouble scale_y;
+
+  g_return_val_if_fail (GIMP_IS_BRUSH_CORE (core), FALSE);
+  g_return_val_if_fail (matrix != 0, FALSE);
+  g_return_val_if_fail (core->main_brush != NULL, FALSE);
+  g_return_val_if_fail (core->brush_bound_segs != NULL, FALSE);
+
+  gimp_matrix3_identity (matrix);
+
+  scale = core->scale;
+  angle = core->angle;
+  aspect_ratio = core->aspect_ratio;
+
+  /* Generated brushes have their angle applied on top of base angle */
+  if (GIMP_IS_BRUSH_GENERATED (core->main_brush))
+    {
+      GimpBrushGenerated *generated_brush;
+      gdouble             base_angle;
+
+      generated_brush = GIMP_BRUSH_GENERATED (core->main_brush);
+
+      base_angle = gimp_brush_generated_get_angle (generated_brush);
+
+      angle = angle + base_angle / 360;
+
+      if (aspect_ratio == 1.0)
+        aspect_ratio = gimp_brush_generated_get_aspect_ratio (generated_brush);
+    }
+
+  height = core->brush_bound_width;
+  width  = core->brush_bound_height;
+
+  if (aspect_ratio < 1.0)
+    {
+      scale_x = scale * aspect_ratio;
+      scale_y = scale;
+    }
+  else
+    {
+      scale_x = scale;
+      scale_y = scale / aspect_ratio;
+    }
+
+  if ((scale > 0.0) && (aspect_ratio > 0.0))
+    {
+      scale = gimp_brush_core_clamp_brush_scale (core, scale);
+
+      gimp_brush_transform_matrix (height, width,
+                                   scale, aspect_ratio, angle, matrix);
+
+      /* FIXME. Do noy use scale_x/scale_y */
+      core->transformed_brush_bound_width  = core->brush_bound_width  * scale_x;
+      core->transformed_brush_bound_height = core->brush_bound_height * scale_y;
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+#endif
+
 void
 gimp_brush_core_paste_canvas (GimpBrushCore            *core,
                               GimpDrawable             *drawable,
@@ -1403,6 +1665,61 @@
   return core->transform_pixmap;
 }
 
+/* gimp-painter-2.7 */
+const static TempBuf *
+gimp_brush_core_texturize_mask (GimpBrushCore *core,
+                               const TempBuf       *brush_mask,
+                               gdouble        x,
+                               gdouble        y)
+{
+  TempBuf *texturized_mask;
+  TempBuf *pattern;
+  gint offset_x, offset_y;
+  PixelRegion srcPR;
+  PixelRegion maskPR;
+    
+  g_return_val_if_fail (brush_mask != NULL, NULL);
+  
+  if (!core->texture)
+    return brush_mask;
+
+  if (core->texturized_brush)
+    temp_buf_free (core->texturized_brush);
+  
+  texturized_mask = temp_buf_new (brush_mask->width, brush_mask->height,
+                                  brush_mask->bytes, brush_mask->x, brush_mask->y, NULL);
+
+  core->texturized_brush = texturized_mask;
+  pattern = gimp_pattern_get_mask (core->texture);
+
+  x = (gint) floor (x) - (brush_mask->width  >> 1);
+  y = (gint) floor (y) - (brush_mask->height >> 1);
+
+  offset_x = (gint)(x - brush_mask->x) % pattern->width;
+  offset_y = (gint)(y - brush_mask->y) % pattern->height;
+
+  /* fill texture pattern */
+  pixel_region_init_temp_buf (&srcPR, core->texturized_brush,
+                              core->texturized_brush->x,
+                              core->texturized_brush->y,
+                              core->texturized_brush->width, core->texturized_brush->height);
+  pattern_region (&srcPR, NULL, pattern, offset_x, offset_y);
+
+  /* re-initialize pixel regions */
+  pixel_region_init_temp_buf (&srcPR, core->texturized_brush,
+                              core->texturized_brush->x,
+                              core->texturized_brush->y,
+                              core->texturized_brush->width, core->texturized_brush->height);
+  pixel_region_init_temp_buf (&maskPR, brush_mask,
+                              brush_mask->x,
+                              brush_mask->y,
+                              brush_mask->width, brush_mask->height);
+  /* apply mask to texture */
+  apply_mask_to_region (&srcPR, &maskPR, 255);
+
+  return texturized_mask; 
+}
+
 const TempBuf *
 gimp_brush_core_get_brush_mask (GimpBrushCore            *core,
                                 const GimpCoords         *coords,
@@ -1410,6 +1727,7 @@
                                 gdouble                   dynamic_force)
 {
   const TempBuf *mask;
+  const TempBuf *mask2 = NULL;
 
   mask = gimp_brush_core_transform_mask (core, core->brush);
 
@@ -1419,25 +1737,28 @@
   switch (brush_hardness)
     {
     case GIMP_BRUSH_SOFT:
-      return gimp_brush_core_subsample_mask (core, mask,
+      mask2 = gimp_brush_core_subsample_mask (core, mask,
                                              coords->x,
                                              coords->y);
       break;
 
     case GIMP_BRUSH_HARD:
-      return gimp_brush_core_solidify_mask (core, mask,
+      mask2 = gimp_brush_core_solidify_mask (core, mask,
                                             coords->x,
                                             coords->y);
       break;
 
     case GIMP_BRUSH_PRESSURE:
-      return gimp_brush_core_pressurize_mask (core, mask,
+      mask2 = gimp_brush_core_pressurize_mask (core, mask,
                                               coords->x,
                                               coords->y,
                                               dynamic_force);
       break;
     }
 
+  if (mask2)
+    return gimp_brush_core_texturize_mask (core, mask2, coords->x, coords->y);
+
   g_return_val_if_reached (NULL);
 }
 
@@ -1477,10 +1798,11 @@
 
       output = gimp_dynamics_get_output (core->dynamics,
                                          GIMP_DYNAMICS_OUTPUT_SIZE);
-      core->scale *= gimp_dynamics_output_get_linear_value (output,
-                                                            coords,
-                                                            paint_options,
-                                                            fade_point);
+      if (!core->ignore_scale)
+        core->scale *= gimp_dynamics_output_get_linear_value (output,
+                                                              coords,
+                                                              paint_options,
+                                                              fade_point);
 
       output = gimp_dynamics_get_output (core->dynamics,
                                          GIMP_DYNAMICS_OUTPUT_ANGLE);
diff -Naur gimp-2.8.14/app/paint/gimpbrushcore.h gimp-2.8.14-new/app/paint/gimpbrushcore.h
--- gimp-2.8.14/app/paint/gimpbrushcore.h	2015-01-27 17:28:36.800833815 +0800
+++ gimp-2.8.14-new/app/paint/gimpbrushcore.h	2015-01-27 17:48:55.349751581 +0800
@@ -43,6 +43,7 @@
 
   GimpBrush     *main_brush;
   GimpBrush     *brush;
+  GimpPattern   *texture;
   GimpDynamics  *dynamics;
   gdouble        spacing;
   gdouble        scale;
@@ -67,8 +68,23 @@
   gdouble        jitter;
   gdouble        jitter_lut_x[BRUSH_CORE_JITTER_LUTSIZE];
   gdouble        jitter_lut_y[BRUSH_CORE_JITTER_LUTSIZE];
+  
+  TempBuf       *texturized_brush;
 
   GRand         *rand;
+
+  /* gimp-painter-2.7: tweaks for smudge */
+  gboolean       ignore_scale;
+
+#if 0
+  /*  don't use these...  */
+  BoundSeg      *brush_bound_segs;
+  gint           n_brush_bound_segs;
+  gint           brush_bound_width;
+  gint           brush_bound_height;
+  gint           transformed_brush_bound_width;
+  gint           transformed_brush_bound_height;
+#endif
 };
 
 struct _GimpBrushCoreClass
@@ -88,6 +104,8 @@
                          GimpBrush     *brush);
   void (* set_dynamics) (GimpBrushCore *core,
                          GimpDynamics  *brush);
+  void (* set_texture)  (GimpBrushCore *core,
+                         GimpPattern  *texture);
 };
 
 
@@ -99,6 +117,19 @@
 void   gimp_brush_core_set_dynamics   (GimpBrushCore            *core,
                                        GimpDynamics             *dynamics);
 
+/* for gimp-painter-2.7 */
+void    gimp_brush_core_set_texture    (GimpBrushCore            *core,
+                                        GimpPattern               *texture);
+
+#if 0
+/* for gimp-painter-2.7 */
+void    gimp_brush_core_create_boundary(GimpBrushCore            *core,
+                                        GimpPaintOptions         *options);
+/* for gimp-painter-2.7 */
+gboolean gimp_brush_core_get_transform (GimpBrushCore            *core,
+                                        GimpMatrix3              *matrix);
+#endif
+
 void   gimp_brush_core_paste_canvas   (GimpBrushCore            *core,
                                        GimpDrawable             *drawable,
                                        const GimpCoords         *coords,
diff -Naur gimp-2.8.14/app/paint/gimpink.c gimp-2.8.14-new/app/paint/gimpink.c
--- gimp-2.8.14/app/paint/gimpink.c	2015-01-27 17:28:36.786833816 +0800
+++ gimp-2.8.14-new/app/paint/gimpink.c	2015-01-27 17:48:55.350751581 +0800
@@ -187,6 +187,8 @@
       break;
 
     case GIMP_PAINT_STATE_FINISH:
+      gimp_circular_queue_free(ink->queue);
+      ink->queue = NULL;
       break;
     }
 }
@@ -257,6 +259,10 @@
   PixelRegion     blob_maskPR;
 
   image = gimp_item_get_image (GIMP_ITEM (drawable));
+#if 0  
+  modified_coords = gimp_paint_core_get_smoothed_coords (paint_core,
+                                                         paint_options, coords);
+#endif
 
   if (! ink->last_blob)
     {
diff -Naur gimp-2.8.14/app/paint/gimpink.h gimp-2.8.14-new/app/paint/gimpink.h
--- gimp-2.8.14/app/paint/gimpink.h	2015-01-27 17:28:36.785833816 +0800
+++ gimp-2.8.14-new/app/paint/gimpink.h	2015-01-27 17:48:55.350751581 +0800
@@ -21,6 +21,7 @@
 
 #include "gimppaintcore.h"
 #include "gimpink-blob.h"
+#include "gimppaintoptions.h"
 
 
 #define GIMP_TYPE_INK            (gimp_ink_get_type ())
@@ -41,6 +42,7 @@
 
   GimpBlob      *cur_blob;     /*  current blob                   */
   GimpBlob      *last_blob;    /*  blob for last cursor position  */
+  GimpCircularQueue * queue;
 };
 
 struct _GimpInkClass
diff -Naur gimp-2.8.14/app/paint/gimpmypaintcore.cpp gimp-2.8.14-new/app/paint/gimpmypaintcore.cpp
--- gimp-2.8.14/app/paint/gimpmypaintcore.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintcore.cpp	2015-01-27 17:48:55.353751581 +0800
@@ -0,0 +1,467 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern "C" {
+#include "config.h"
+
+#include <string.h>
+
+#include <gegl.h>
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpmath/gimpmath.h"
+
+#include "paint-types.h"
+
+#include "base/pixel-region.h"
+#include "base/temp-buf.h"
+#include "base/tile-manager.h"
+#include "base/tile.h"
+
+#include "paint-funcs/paint-funcs.h"
+
+#include "core/gimp.h"
+#include "core/gimp-utils.h"
+#include "core/gimpdrawable.h"
+#include "core/gimpimage.h"
+#include "core/gimpimage-undo.h"
+#include "core/gimppickable.h"
+#include "core/gimpprojection.h"
+#include "core/gimpmypaintbrush.h"
+#include "core/gimplayer.h"
+
+#include "gimpmypaintcoreundo.h"
+#include "gimpmypaintoptions.h"
+
+#include "gimpairbrush.h"
+
+#include "gimp-intl.h"
+};
+
+#include "base/delegators.hpp"
+#include "gimpmypaintcore.hpp"
+#include "gimpmypaintcore-surface.hpp"
+#include "core/gimpmypaintbrush-private.hpp"
+
+/*  local function prototypes  */
+
+GimpMypaintCore::GimpMypaintCore()
+{
+  ID               = 0; //global_core_ID++;
+
+  surface = NULL;
+  brush   = NULL;
+  stroke  = NULL;
+  option_changed_handler = NULL;
+}
+
+
+GimpMypaintCore::~GimpMypaintCore ()
+{
+  g_print("GimpMypaintCore(%lx)::destructor\n", (gulong)this);
+  cleanup ();
+}
+
+void GimpMypaintCore::cleanup()
+{
+  g_print("GimpMypaintCore(%lx)::cleanup\n", (gulong)this);
+  if (option_changed_handler)
+    delete option_changed_handler;
+  option_changed_handler = NULL;
+  
+  if (surface && stroke) {
+    split_stroke();
+  }
+  if (stroke) {
+    delete stroke;
+    stroke = NULL;
+  }
+  if (brush) {
+    delete brush;
+    brush = NULL;
+  }
+  if (surface) {
+    delete surface;
+    surface = NULL;
+  }
+}
+
+void GimpMypaintCore::stroke_to (GimpDrawable* drawable, 
+                                 gdouble dtime, 
+                                 const GimpCoords* coords,
+                                 GimpMypaintOptions* options)
+{
+  bool split = false;
+  
+  if (options != this->options) {
+    if (this->options && option_changed_handler) {
+      delete option_changed_handler;
+      option_changed_handler = NULL;
+    }
+    this->options = options;
+    option_changed_handler = g_signal_connect_delegator(G_OBJECT(options), "notify", Delegator::delegator(this, &GimpMypaintCore::option_changed));
+  }
+  
+  // Prepare Brush.
+  update_resource(options);
+  
+  /// from Document#stroke_to
+
+  // Prepare Stroke object
+  if (!stroke) {
+    stroke = new Stroke();
+    stroke->start(brush);
+
+    if (!surface) {
+      g_print("MypaintCore(%lx)::create new surface...\n", (gulong)this);
+      surface = GimpMypaintSurface_new(drawable);
+    } else if (!surface->is_surface_for(drawable)) {
+      surface->end_session();
+      g_print("MypaintCore(%lx)::delete surface...\n", (gulong)this);
+      delete surface;
+      g_print("MypaintCore(%lx)::recreate new surface...\n", (gulong)this);
+      surface = GimpMypaintSurface_new(drawable);
+     }
+
+    GimpContext* context = GIMP_CONTEXT (options);
+
+    // update color values
+    // FIXME: Color should be updated when Foreground color is selected
+    GimpRGB rgb;
+    gimp_context_get_foreground(GIMP_CONTEXT(options), &rgb);
+    GimpHSV hsv;
+    gimp_rgb_to_hsv (&rgb, &hsv);
+    brush->set_base_value(BRUSH_COLOR_H, hsv.h);
+    brush->set_base_value(BRUSH_COLOR_S, hsv.s);
+    brush->set_base_value(BRUSH_COLOR_V, hsv.v);
+
+    gimp_context_get_background(GIMP_CONTEXT(options), &rgb);
+    surface->set_bg_color(&rgb);
+
+    // Attach gimp brush to the surface object.
+    gboolean use_gimp_brushmark;
+    g_object_get(G_OBJECT(options), "use_gimp_brushmark", &use_gimp_brushmark, NULL);
+    if (use_gimp_brushmark) {
+      GimpBrush* brushmark = gimp_context_get_brush (GIMP_CONTEXT(options));
+      surface->set_brushmark(brushmark);
+    } else {
+      surface->set_brushmark(NULL);
+    }
+
+    gboolean use_gimp_texture;
+    g_object_get(G_OBJECT(options), "use_gimp_texture", &use_gimp_texture, NULL);
+    if (use_gimp_texture) {
+      GimpPattern* pattern = gimp_context_get_pattern(GIMP_CONTEXT(options));
+      surface->set_texture(pattern);
+    } else {
+      surface->set_texture(NULL);
+    }
+
+    gboolean floating_stroke;
+    g_object_get(G_OBJECT(options), "non_incremental", &floating_stroke, NULL);
+    surface->set_floating_stroke(floating_stroke);
+    gdouble stroke_opacity;
+    g_object_get(G_OBJECT(options), "stroke_opacity", &stroke_opacity, NULL);
+    surface->set_stroke_opacity(stroke_opacity);
+    
+    if (GIMP_IS_LAYER (drawable)) {
+      gboolean lock_alpha = gimp_layer_get_lock_alpha (GIMP_LAYER (drawable));
+
+      if (lock_alpha)
+        brush->set_base_value(BRUSH_LOCK_ALPHA, 1.0);
+      else
+        brush->set_base_value(BRUSH_LOCK_ALPHA, 0.0);
+    }
+    surface->begin_session();
+  }
+  
+  surface->set_coords(coords);
+  
+  stroke->record(dtime, coords);
+
+  /// from Layer#stroke_to
+  split = brush->stroke_to(surface, coords->x, coords->y, 
+                           coords->pressure, 
+                           coords->xtilt, coords->ytilt, dtime);
+  
+  if (split)
+    split_stroke();
+}
+
+void GimpMypaintCore::split_stroke()
+{
+//  g_print("splitting stroke...\n");
+  if (!stroke)
+    return;
+    
+  stroke->stop();
+  surface->end_session();
+  // push stroke to undo stack.
+
+  delete stroke;  
+  stroke = NULL;
+  /*
+  if (brush) {
+    delete brush;
+    brush = NULL;
+  }
+  */
+  return;
+}
+
+void GimpMypaintCore::update_resource(GimpMypaintOptions* options)
+{
+  GimpContext* context = GIMP_CONTEXT (options);
+//  GimpMypaintBrush* myb = context->mypaint_brush;
+	GimpMypaintBrush* myb = gimp_mypaint_options_get_current_brush (options);
+  GimpMypaintBrushPrivate *myb_priv = NULL;
+#if 0  
+  if (mypaint_brush != myb) {
+    g_print("Other brush is selected.\n");
+    delete brush;
+    brush = NULL;
+  }
+#endif
+  if (!brush) {
+    g_print("MypaintCore(%lx)::Create brush object\n", (gulong)this);
+    brush = new Brush();
+    option_changed(G_OBJECT(options), NULL);
+    mypaint_brush = myb;
+    brush->reset();
+  }
+
+}
+
+void GimpMypaintCore::reset_brush()
+{
+  if (brush) {
+    brush->reset();
+  }
+}
+
+void GimpMypaintCore::option_changed(GObject* target, GParamSpec *pspec)
+{
+//  g_print("MypaintCore(%lx)::option_changed\n", (gulong)this);
+  split_stroke();
+
+  GimpMypaintOptions* options = GIMP_MYPAINT_OPTIONS(target);
+
+  GimpMypaintBrush* myb = gimp_mypaint_options_get_current_brush (options);
+  GimpMypaintBrushPrivate *myb_priv = NULL;
+  if (myb)
+    myb_priv = reinterpret_cast<GimpMypaintBrushPrivate*>(myb->p);
+
+
+  // copy brush setting here.
+  if (myb_priv) {
+    for (int i = 0; i < BRUSH_MAPPING_COUNT; i ++) {
+      Mapping* m = myb_priv->get_setting(i)->mapping;
+      if (m)
+        brush->copy_mapping(i, m);
+      else {
+        brush->set_mapping_n(i, 0, 0);
+        brush->set_base_value(i, myb_priv->get_setting(i)->base_value);
+      }
+    }
+  }
+}
+
+
+#if 0
+/*  public functions  */
+
+void
+gimp_mypaint_core_paint (GimpMypaintCore    *core,
+                       GimpDrawable     *drawable,
+                       GimpMypaintOptions *mypaint_options,
+                       GimpMypaintState    mypaint_state,
+                       guint32           time)
+{
+  GimpMypaintCoreClass *core_class;
+
+  g_return_if_fail (GIMP_IS_MYPAINT_CORE (core));
+  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));
+  g_return_if_fail (gimp_item_is_attached (GIMP_ITEM (drawable)));
+  g_return_if_fail (GIMP_IS_MYPAINT_OPTIONS (mypaint_options));
+
+  core_class = GIMP_MYPAINT_CORE_GET_CLASS (core);
+
+  if (core_class->pre_paint (core, drawable,
+                             mypaint_options,
+                             mypaint_state, time))
+    {
+
+      if (mypaint_state == GIMP_MYPAINT_STATE_MOTION)
+        {
+          /* Save coordinates for gimp_mypaint_core_interpolate() */
+          core->last_mypaint.x = core->cur_coords.x;
+          core->last_mypaint.y = core->cur_coords.y;
+        }
+
+      core_class->maint (core, drawable,
+                         mypaint_options,
+                         &core->cur_coords,
+                         mypaint_state, time);
+
+      core_class->post_paint (core, drawable,
+                              mypaint_options,
+                              mypaint_state, time);
+    }
+}
+#endif
+
+#if 0
+void
+gimp_mypaint_core_cancel (GimpMypaintCore *core,
+                        GimpDrawable  *drawable)
+{
+  gint x, y;
+  gint width, height;
+
+  g_return_if_fail (GIMP_IS_MYPAINT_CORE (core));
+  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));
+  g_return_if_fail (gimp_item_is_attached (GIMP_ITEM (drawable)));
+
+  /*  Determine if any part of the image has been altered--
+   *  if nothing has, then just return...
+   */
+  if ((core->x2 == core->x1) || (core->y2 == core->y1))
+    return;
+
+  if (gimp_rectangle_intersect (core->x1, core->y1,
+                                core->x2 - core->x1,
+                                core->y2 - core->y1,
+                                0, 0,
+                                gimp_item_get_width  (GIMP_ITEM (drawable)),
+                                gimp_item_get_height (GIMP_ITEM (drawable)),
+                                &x, &y, &width, &height))
+    {
+      gimp_mypaint_core_copy_valid_tiles (core->undo_tiles,
+                                        gimp_drawable_get_tiles (drawable),
+                                        x, y, width, height);
+    }
+
+  tile_manager_unref (core->undo_tiles);
+  core->undo_tiles = NULL;
+
+  if (core->saved_proj_tiles)
+    {
+      tile_manager_unref (core->saved_proj_tiles);
+      core->saved_proj_tiles = NULL;
+    }
+
+  gimp_drawable_update (drawable, x, y, width, height);
+
+  gimp_viewable_preview_thaw (GIMP_VIEWABLE (drawable));
+}
+
+void
+gimp_mypaint_core_interpolate (GimpMypaintCore    *core,
+                             GimpDrawable     *drawable,
+                             GimpMypaintOptions *mypaint_options,
+                             const GimpCoords *coords,
+                             guint32           time)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_CORE (core));
+  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));
+  g_return_if_fail (gimp_item_is_attached (GIMP_ITEM (drawable)));
+  g_return_if_fail (GIMP_IS_MYPAINT_OPTIONS (mypaint_options));
+  g_return_if_fail (coords != NULL);
+
+  core->cur_coords = *coords;
+
+  GIMP_MYPAINT_CORE_GET_CLASS (core)->interpolate (core, drawable,
+                                                 mypaint_options, time);
+}
+
+void
+gimp_mypaint_core_set_current_coords (GimpMypaintCore    *core,
+                                    const GimpCoords *coords)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_CORE (core));
+  g_return_if_fail (coords != NULL);
+
+  core->cur_coords = *coords;
+}
+
+void
+gimp_mypaint_core_get_current_coords (GimpMypaintCore    *core,
+                                    GimpCoords       *coords)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_CORE (core));
+  g_return_if_fail (coords != NULL);
+
+  *coords = core->cur_coords;
+
+}
+
+void
+gimp_mypaint_core_set_last_coords (GimpMypaintCore    *core,
+                                 const GimpCoords *coords)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_CORE (core));
+  g_return_if_fail (coords != NULL);
+
+  core->last_coords = *coords;
+}
+
+void
+gimp_mypaint_core_get_last_coords (GimpMypaintCore *core,
+                                 GimpCoords    *coords)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_CORE (core));
+  g_return_if_fail (coords != NULL);
+
+  *coords = core->last_coords;
+}
+
+/**
+ * gimp_mypaint_core_round_line:
+ * @core:                 the #GimpMypaintCore
+ * @options:              the #GimpMypaintOptions to use
+ * @constrain_15_degrees: the modifier state
+ *
+ * Adjusts core->last_coords and core_cur_coords in preparation to
+ * drawing a straight line. If @center_pixels is TRUE the endpoints
+ * get pushed to the center of the pixels. This avoids artefacts
+ * for e.g. the hard mode. The rounding of the slope to 15 degree
+ * steps if ctrl is pressed happens, as does rounding the start and
+ * end coordinates (which may be fractional in high zoom modes) to
+ * the center of pixels.
+ **/
+void
+gimp_mypaint_core_round_line (GimpMypaintCore    *core,
+                            GimpMypaintOptions *mypaint_options,
+                            gboolean          constrain_15_degrees)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_CORE (core));
+  g_return_if_fail (GIMP_IS_MYPAINT_OPTIONS (mypaint_options));
+
+  if (gimp_mypaint_options_get_brush_mode (mypaint_options) == GIMP_BRUSH_HARD)
+    {
+      core->last_coords.x = floor (core->last_coords.x) + 0.5;
+      core->last_coords.y = floor (core->last_coords.y) + 0.5;
+      core->cur_coords.x  = floor (core->cur_coords.x ) + 0.5;
+      core->cur_coords.y  = floor (core->cur_coords.y ) + 0.5;
+    }
+
+  if (constrain_15_degrees)
+    gimp_constrain_line (core->last_coords.x, core->last_coords.y,
+                         &core->cur_coords.x, &core->cur_coords.y,
+                         GIMP_CONSTRAIN_LINE_15_DEGREES);
+}
+#endif
diff -Naur gimp-2.8.14/app/paint/gimpmypaintcore.h.bak gimp-2.8.14-new/app/paint/gimpmypaintcore.h.bak
--- gimp-2.8.14/app/paint/gimpmypaintcore.h.bak	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintcore.h.bak	2015-01-27 17:48:55.353751581 +0800
@@ -0,0 +1,162 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_CORE_H__
+#define __GIMP_MYPAINT_CORE_H__
+
+
+#include "core/gimpobject.h"
+#include "gimpmypaintoptions.h" /* GimpCircularQueue */
+
+
+#define GIMP_TYPE_MYPAINT_CORE            (gimp_mypaint_core_get_type ())
+#define GIMP_MYPAINT_CORE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MYPAINT_CORE, GimpMypaintCore))
+#define GIMP_MYPAINT_CORE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MYPAINT_CORE, GimpMypaintCoreClass))
+#define GIMP_IS_MYPAINT_CORE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MYPAINT_CORE))
+#define GIMP_IS_MYPAINT_CORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MYPAINT_CORE))
+#define GIMP_MYPAINT_CORE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MYPAINT_CORE, GimpMypaintCoreClass))
+
+
+typedef struct _GimpMypaintCoreClass GimpMypaintCoreClass;
+
+struct _GimpMypaintCore
+{
+  GimpObject   parent_instance;
+
+  gint         ID;               /*  unique instance ID                  */
+
+  gchar       *undo_desc;        /*  undo description                    */
+
+  GimpCoords   start_coords;     /*  starting coords (for undo only)     */
+
+  GimpVector2  last_paint;       /*  last point that was painted         */
+
+  gdouble      distance;         /*  distance traveled by brush          */
+  gdouble      pixel_dist;       /*  distance in pixels                  */
+
+  gint         x1, y1;           /*  undo extents in image coords        */
+  gint         x2, y2;           /*  undo extents in image coords        */
+
+  TileManager *undo_tiles;       /*  tiles which have been modified      */
+
+  gpointer     p;
+};
+
+struct _GimpMypaintCoreClass
+{
+  GimpObjectClass  parent_class;
+
+  /*  virtual functions  */
+  TempBuf  * (* get_paint_area) (GimpMypaintCore    *core,
+                                 GimpDrawable     *drawable,
+                                 GimpMypaintOptions *mypaint_options,
+                                 const GimpCoords *coords);
+
+  GimpUndo * (* push_undo)      (GimpMypaintCore    *core,
+                                 GimpImage        *image,
+                                 const gchar      *undo_desc);
+};
+
+
+GType     gimp_mypaint_core_get_type                  (void) G_GNUC_CONST;
+
+void      gimp_mypaint_core_mypaint                     (GimpMypaintCore    *core,
+                                                     GimpDrawable     *drawable,
+                                                     GimpMypaintOptions *mypaint_options,
+                                                     GimpMypaintState    state,
+                                                     guint32           time);
+
+gboolean  gimp_mypaint_core_start                     (GimpMypaintCore    *core,
+                                                     GimpDrawable     *drawable,
+                                                     GimpMypaintOptions *mypaint_options,
+                                                     const GimpCoords *coords,
+                                                     GError          **error);
+void      gimp_mypaint_core_finish                    (GimpMypaintCore    *core,
+                                                     GimpDrawable     *drawable,
+                                                     gboolean          push_undo);
+void      gimp_mypaint_core_cancel                    (GimpMypaintCore    *core,
+                                                     GimpDrawable     *drawable);
+void      gimp_mypaint_core_cleanup                   (GimpMypaintCore    *core);
+
+void      gimp_mypaint_core_interpolate               (GimpMypaintCore    *core,
+                                                     GimpDrawable     *drawable,
+                                                     GimpMypaintOptions *mypaint_options,
+                                                     const GimpCoords *coords,
+                                                     guint32           time);
+
+void      gimp_mypaint_core_set_current_coords        (GimpMypaintCore    *core,
+                                                     const GimpCoords *coords);
+void      gimp_mypaint_core_get_current_coords        (GimpMypaintCore    *core,
+                                                     GimpCoords       *coords);
+
+void      gimp_mypaint_core_set_last_coords           (GimpMypaintCore    *core,
+                                                     const GimpCoords *coords);
+void      gimp_mypaint_core_get_last_coords           (GimpMypaintCore    *core,
+                                                     GimpCoords       *coords);
+
+void      gimp_mypaint_core_round_line                (GimpMypaintCore    *core,
+                                                     GimpMypaintOptions *options,
+                                                     gboolean          constrain_15_degrees);
+
+
+/*  protected functions  */
+
+TempBuf * gimp_mypaint_core_get_paint_area            (GimpMypaintCore    *core,
+                                                     GimpDrawable     *drawable,
+                                                     GimpMypaintOptions *options,
+                                                     const GimpCoords *coords);
+TempBuf * gimp_mypaint_core_get_orig_image            (GimpMypaintCore    *core,
+                                                     GimpDrawable     *drawable,
+                                                     gint              x,
+                                                     gint              y,
+                                                     gint              width,
+                                                     gint              height);
+TempBuf * gimp_mypaint_core_get_orig_proj             (GimpMypaintCore    *core,
+                                                     GimpPickable     *pickable,
+                                                     gint              x,
+                                                     gint              y,
+                                                     gint              width,
+                                                     gint              height);
+
+void      gimp_mypaint_core_paste             (GimpMypaintCore            *core,
+                                             PixelRegion              *mypaint_maskPR,
+                                             GimpDrawable             *drawable,
+                                             gdouble                   mypaint_opacity,
+                                             gdouble                   image_opacity,
+                                             GimpLayerModeEffects      mypaint_mode,
+                                             GimpMypaintApplicationMode  mode);
+void      gimp_mypaint_core_replace           (GimpMypaintCore            *core,
+                                             PixelRegion              *mypaint_maskPR,
+                                             GimpDrawable             *drawable,
+                                             gdouble                   mypaint_opacity,
+                                             gdouble                   image_opacity,
+                                             GimpMypaintApplicationMode  mode);
+
+void      gimp_mypaint_core_validate_undo_tiles       (GimpMypaintCore    *core,
+                                                     GimpDrawable     *drawable,
+                                                     gint              x,
+                                                     gint              y,
+                                                     gint              w,
+                                                     gint              h);
+void      gimp_mypaint_core_validate_canvas_tiles     (GimpMypaintCore    *core,
+                                                     gint              x,
+                                                     gint              y,
+                                                     gint              w,
+                                                     gint              h);
+
+
+#endif  /*  __GIMP_MYPAINT_CORE_H__  */
diff -Naur gimp-2.8.14/app/paint/gimpmypaintcore.hpp gimp-2.8.14-new/app/paint/gimpmypaintcore.hpp
--- gimp-2.8.14/app/paint/gimpmypaintcore.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintcore.hpp	2015-01-27 17:48:55.353751581 +0800
@@ -0,0 +1,67 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_CORE_H__
+#define __GIMP_MYPAINT_CORE_H__
+
+extern "C" {
+#include "core/gimpobject.h"
+#include "gimpmypaintoptions.h"
+#include "core/gimpmypaintbrush.h"
+};
+
+extern "C++" {
+#include "gimpmypaintcore-surface.hpp"
+#include "mypaintbrush-brush.hpp"
+#include "mypaintbrush-stroke.hpp"
+#include "base/delegators.hpp"
+
+class GimpMypaintCore
+{
+  gint         ID;               /*  unique instance ID                  */
+
+  GimpMypaintSurface*     surface;
+  Brush*       brush;
+  Stroke*      stroke;
+  GimpMypaintBrush* mypaint_brush;
+  GimpMypaintOptions*     options;
+
+  Delegator::Connection* option_changed_handler;
+  
+  public:
+  GimpMypaintCore();
+  ~GimpMypaintCore();
+  void cleanup();
+  virtual void stroke_to (GimpDrawable* drawable, 
+                            gdouble dtime, 
+                            const GimpCoords* coords,
+                            GimpMypaintOptions* options);
+
+  virtual void update_resource (GimpMypaintOptions* options);
+  void split_stroke();
+  void reset_brush();
+  
+  void option_changed(GObject* object, GParamSpec *pspec);
+  
+};
+
+void      gimp_mypaint_core_round_line                (GimpMypaintCore    *core,
+                                                     GimpMypaintOptions *options,
+                                                     gboolean          constrain_15_degrees);
+
+}; // extern C++
+#endif  /*  __GIMP_MYPAINT_CORE_H__  */
diff -Naur gimp-2.8.14/app/paint/gimpmypaintcore-surface.cpp gimp-2.8.14-new/app/paint/gimpmypaintcore-surface.cpp
--- gimp-2.8.14/app/paint/gimpmypaintcore-surface.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintcore-surface.cpp	2015-01-27 17:48:55.351751581 +0800
@@ -0,0 +1,1391 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern "C" {
+#include "config.h"
+
+#include <string.h>
+#include <math.h>
+
+#include <gegl.h>
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpmath/gimpmath.h"
+
+#include "paint-types.h"
+
+#include "base/base-types.h"
+#include "base/pixel-region.h"
+#include "base/temp-buf.h"
+#include "base/tile-manager.h"
+#include "base/tile.h"
+#include "base/pixel-processor.h"
+
+#include "core/gimp.h"
+#include "core/gimp-utils.h"
+#include "core/gimpdrawable.h"
+#include "core/gimpimage.h"
+#include "core/gimpimage-undo.h"
+#include "core/gimpimage-undo-push.h"
+#include "core/gimpchannel.h"
+#include "core/gimppattern.h"
+#include "core/gimppickable.h"
+#include "core/gimpprojection.h"
+
+#include "gimpmypaintcore.hpp"
+#include "gimpmypaintcoreundo.h"
+#include "gimpmypaintoptions.h"
+
+#include "gimp-intl.h"
+#include "paint-funcs/paint-funcs.h"
+};
+
+#define REAL_CALC
+
+#include "base/pixel.hpp"
+#include "base/scopeguard.hpp"
+#include "paint-funcs/mypaint-brushmodes.hpp"
+#include "gimpmypaintcore-surface.hpp"
+#include "base/delegators.hpp"
+
+const float ALPHA_THRESHOLD = (float)((1 << 16) - 1);
+
+////////////////////////////////////////////////////////////////////////////////
+template<typename PixelIter>
+class GimpMypaintSurfaceForGeneralBrush {
+protected:
+  float x, y;
+  float opaque;
+  float normal, lock_alpha;
+  float stroke_opacity;
+  float color_a;
+  Pixel::real fg_color[4];
+  Pixel::real bg_color[3];
+  float texture_grain;
+  float texture_contrast;
+public:
+  typedef PixelIter iterator;
+  bool 
+  prepare_brush(float x, 
+                float y, 
+                float radius, 
+                float hardness, 
+                float aspect_ratio, 
+                float angle, 
+                float normal, 
+                float opaque, 
+                float lock_alpha, 
+                Pixel::real* fg_color, 
+                float color_a, 
+                Pixel::real* bg_color, 
+                float stroke_opacity,
+                float texture_grain,
+                float texture_contrast,
+                void* /*unused*/)
+  {
+    this->x            = x;
+    this->y            = y;
+    this->normal       = normal;
+    this->opaque       = opaque;
+    this->lock_alpha   = lock_alpha;
+    this->color_a      = color_a;
+    this->fg_color[0]  = fg_color[0];
+    this->fg_color[1]  = fg_color[1];
+    this->fg_color[2]  = fg_color[2];
+    this->fg_color[3]  = fg_color[3];
+    this->bg_color[0]  = bg_color[0];
+    this->bg_color[1]  = bg_color[1];
+    this->bg_color[2]  = bg_color[2];
+    this->stroke_opacity = stroke_opacity;
+    this->texture_grain = texture_grain;
+    this->texture_contrast = texture_contrast;
+    return true;
+  }
+
+
+  void
+  draw_dab(PixelIter& iter) 
+  {
+    // second, we use the mask to stamp a dab for each activated blend mode
+    if (normal) {
+      if (color_a == 1.0) {
+        draw_dab_pixels_BlendMode_Normal(iter, 
+                                         normal * opaque);
+      } else {
+        // normal case for brushes that use smudging (eg. watercolor)
+        draw_dab_pixels_BlendMode_Normal_and_Eraser(iter,
+                                                    color_a,
+                                                    normal * opaque, 
+                                                    bg_color[0], bg_color[1], bg_color[2]);
+      }
+    }
+
+    if (lock_alpha) {
+      draw_dab_pixels_BlendMode_LockAlpha(iter,
+                                          lock_alpha * opaque);
+    }
+  }
+  
+
+  void
+  copy_stroke(PixelRegion* src1PR, 
+              PixelRegion* destPR, 
+              PixelRegion* brushPR, 
+              PixelRegion* maskPR,
+              PixelRegion* texturePR) 
+  {
+    BrushPixelIteratorForPlainData<PixmapBrushmarkIterator, Pixel::data_t, Pixel::data_t>
+       iter(brushPR->data, NULL, 
+            src1PR->data, destPR->data, 
+            src1PR->w, src1PR->h, 
+            brushPR->rowstride, 
+            src1PR->rowstride,
+            destPR->rowstride,
+            brushPR->bytes,
+            src1PR->bytes,
+            destPR->bytes);
+    // normal case for brushes that use smudging (eg. watercolor)
+    draw_dab_pixels_BlendMode_Normal_and_Eraser(iter,
+                                                color_a,
+                                                stroke_opacity,
+                                                bg_color[0], bg_color[1], bg_color[2]);
+//        draw_dab_pixels_BlendMode_Normal(iter, 0.4);
+  }
+
+};
+
+
+////////////////////////////////////////////////////////////////////////////////
+class GimpMypaintSurfaceForMypaintBrush : 
+  public GimpMypaintSurfaceForGeneralBrush<BrushPixelIteratorForRunLength>
+{
+  float radius;
+  float hardness, aspect_ratio, angle;
+
+public:
+  typedef BrushPixelIteratorForRunLength iterator;
+  typedef GimpMypaintSurfaceForGeneralBrush<iterator> Parent;
+
+  bool 
+  prepare_brush(float x, 
+                float y, 
+                float radius, 
+                float hardness, 
+                float aspect_ratio, 
+                float angle, 
+                float normal, 
+                float opaque, 
+                float lock_alpha, 
+                Pixel::real* fg_color, 
+                float color_a, 
+                Pixel::real* bg_color, 
+                float stroke_opacity,
+                float texture_grain,
+                float texture_contrast,
+                void* brush)
+  {
+    Parent::prepare_brush(x, y, 
+                          radius, 
+                          hardness, 
+                          aspect_ratio, 
+                          angle, 
+                          normal, 
+                          opaque, 
+                          lock_alpha, 
+                          fg_color, 
+                          color_a, 
+                          bg_color, stroke_opacity,
+                          texture_grain, texture_contrast,
+                          brush);
+    this->radius       = radius;
+    this->hardness     = hardness;
+    this->aspect_ratio = aspect_ratio;
+    this->angle        = angle;
+    return true;
+  }
+  
+  TempBuf* get_brush_data() { return NULL; }
+  
+
+  void 
+  get_boundary(int&x1, int& y1, int& x2, int& y2) 
+  {
+    float r_fringe = radius + 1;
+    
+    x1  = floor(x - r_fringe);
+    y1  = floor(y - r_fringe);
+    x2  = floor(x + r_fringe);
+    y2  = floor(y + r_fringe);
+  };
+
+  
+  void 
+  fill_brushmark_buffer (Pixel::real *dab_mask,
+                         gint          *offsets,
+                         float cx_in_tile_coords, 
+                         float cy_in_tile_coords,
+                         PixelRegion* srcPR,
+                         PixelRegion* channelPR,
+                         PixelRegion* texturePR) 
+  {
+    gint stride = srcPR->rowstride / srcPR->bytes;
+    hardness = CLAMP(hardness, 0.0, 1.0);
+    if (aspect_ratio<1.0) aspect_ratio=1.0;
+      assert(hardness != 0.0); // assured by caller
+
+    float r_fringe;
+    int xp, yp;
+    float xx, yy, rr;
+    float one_over_radius2;
+    Pixel::data_t* channel_data = NULL;
+    Pixel::data_t* texture_data = NULL;
+
+    r_fringe = radius + 1;
+    rr = radius*radius;
+    one_over_radius2 = 1.0/rr;
+
+    // For a graphical explanation, see:
+    // http://wiki.mypaint.info/Development/Documentation/Brushlib
+    //
+    // The hardness calculation is explained below:
+    //
+    // Dab opacity gradually fades out from the center (rr=0) to
+    // fringe (rr=1) of the dab. How exactly depends on the hardness.
+    // We use two linear segments, for which we pre-calculate slope
+    // and offset here.
+    //
+    // opa
+    // ^
+    // *   .
+    // |        *
+    // |          .
+    // +-----------*> rr = (distance_from_center/radius)^2
+    // 0           1
+    //
+    float segment1_offset = 1.0;
+    float segment1_slope  = -(1.0/hardness - 1.0);
+    float segment2_offset = hardness/(1.0-hardness);
+    float segment2_slope  = -hardness/(1.0-hardness);
+    // for hardness == 1.0, segment2 will never be used
+
+    float angle_rad=angle/360*2*M_PI;
+    float cs=cos(angle_rad);
+    float sn=sin(angle_rad);
+
+    int x0 = floor (cx_in_tile_coords - r_fringe);
+    int y0 = floor (cy_in_tile_coords - r_fringe);
+    int x1 = ceil (cx_in_tile_coords + r_fringe);
+    int y1 = ceil (cy_in_tile_coords + r_fringe);
+    if (x0 < 0) x0 = 0;
+    if (y0 < 0) y0 = 0;
+    if (x1 > srcPR->w-1) x1 = srcPR->w-1;
+    if (y1 > srcPR->h-1) y1 = srcPR->h-1;
+    
+//    g_print("dab area: (%d,%d)-(%d,%d)\n",x0,y0,x1,y1);
+    
+    // we do run length encoding: if opacity is zero, the next
+    // value in the mask is the number of pixels that can be skipped.
+    Pixel::real * dab_mask_p = dab_mask;
+    int skip=0;
+    
+    if (channelPR) {
+      channel_data = channelPR->data;
+      channel_data += channelPR->rowstride * y0;
+    }
+
+    if (texturePR) {
+      texture_data = texturePR->data;
+      texture_data += texturePR->rowstride * y0;
+    }
+    
+    skip += y0*stride;
+    for (yp = y0; yp <= y1; yp++) {
+      yy = (yp + 0.5 - cy_in_tile_coords);
+      skip += x0;
+      for (xp = x0; xp <= x1; xp++) {
+        xx = (xp + 0.5 - cx_in_tile_coords);
+        // code duplication, see brush::count_dabs_to()
+        float yyr=(yy*cs-xx*sn)*aspect_ratio;
+        float xxr=yy*sn+xx*cs;
+        rr = (yyr*yyr + xxr*xxr) * one_over_radius2;
+        // rr is in range 0.0..1.0*sqrt(2)
+        
+        float opa;
+        if (rr <= 1.0) {
+          float fac;
+          if (rr <= hardness) {
+            opa = segment1_offset;
+            fac = segment1_slope;
+          } else {
+            opa = segment2_offset;
+            fac = segment2_slope;
+          }
+          opa += rr*fac;
+  #ifdef HEAVY_DEBUG
+          assert(isfinite(opa));
+          assert(opa >= 0.0 && opa <= 1.0);
+  #endif
+        } else {
+          opa = 0.0;
+        }
+
+        result_t opa_ = eval(pix(0.0f));
+        if (channel_data)
+          opa_ = eval( pix(opa) * pix(channel_data[xp]) );
+        else
+          opa_ = eval( pix(opa) );
+
+        if (texture_data) {
+          opa_ = eval( pix(opa_) * 
+                      (pix(texture_data[xp * texturePR->bytes]) + pix(texture_grain)) * pix(texture_contrast));
+        }
+
+        if (opa_ * ALPHA_THRESHOLD < 1.0) {
+          skip++;
+        } else {
+          if (skip) {
+            *dab_mask_p++ = 0;
+            *offsets++ = skip;
+            skip = 0;
+          }
+          *dab_mask_p++ = opa_;
+        }
+      }
+      skip += stride-xp;
+      if (channelPR)
+        channel_data += channelPR->rowstride;
+      if (texturePR)
+        texture_data += texturePR->rowstride;
+    }
+    *dab_mask_p++ = 0;
+    *offsets  = 0;
+  }
+
+  void 
+  draw_dab(PixelRegion* src1PR, 
+           PixelRegion* destPR,
+           PixelRegion* , // unused 
+           PixelRegion* maskPR,
+           PixelRegion* texturePR)
+  {
+    // first, we calculate the mask (opacity for each pixel)
+    Pixel::real dab_mask[TILE_WIDTH*TILE_HEIGHT+2];
+    gint dab_offsets[TILE_WIDTH * TILE_HEIGHT];
+
+    Pixel::data_t* src_data  = src1PR->data;
+    Pixel::data_t* dest_data = destPR->data;
+
+    fill_brushmark_buffer (dab_mask,
+                           dab_offsets,
+                           x - src1PR->x,
+                           y - src1PR->y,
+                           src1PR,
+                           maskPR,
+                           texturePR);
+
+    BrushPixelIteratorForRunLength iter(dab_mask, dab_offsets, fg_color, src_data, dest_data, src1PR->bytes, destPR->bytes);
+    
+    Parent::draw_dab(iter);
+  }
+};
+
+////////////////////////////////////////////////////////////////////////////////
+class GimpMypaintSurfaceForGimpBrush : 
+  public GimpMypaintSurfaceForGeneralBrush<BrushPixelIteratorForPlainData<ColoredBrushmarkIterator, Pixel::real, Pixel::real> >
+{
+  GimpCoords* last_coords;
+  GimpCoords* current_coords;
+  const TempBuf* dab_mask;
+  float radius;
+  
+public:
+  typedef BrushPixelIteratorForPlainData<ColoredBrushmarkIterator, Pixel::real, Pixel::real> iterator;
+  typedef GimpMypaintSurfaceForGeneralBrush<iterator> Parent;
+  GimpMypaintSurfaceForGimpBrush(GimpCoords* current_coords,
+                                 GimpCoords* last_coords)
+    : dab_mask(NULL)
+  {
+    this->current_coords = current_coords;
+    this->last_coords    = last_coords;
+  };
+
+  const TempBuf* get_brush_data()
+  { 
+    return dab_mask;
+  }
+
+
+  bool 
+  prepare_brush(float x, 
+                float y, 
+                float radius, 
+                float hardness, 
+                float aspect_ratio, 
+                float angle, 
+                float normal, 
+                float opaque, 
+                float lock_alpha, 
+                Pixel::real* fg_color, 
+                float color_a, 
+                Pixel::real* bg_color, 
+                float stroke_opacity,
+                float texture_grain, float texture_contrast,
+                void* data)
+  {
+    Parent::prepare_brush(x, y, 
+                          radius, 
+                          hardness, 
+                          aspect_ratio, 
+                          angle, 
+                          normal, 
+                          opaque, 
+                          lock_alpha, 
+                          fg_color, 
+                          color_a, 
+                          bg_color,
+                          stroke_opacity,
+                          texture_grain, texture_contrast,
+                          data);
+    dab_mask         = NULL;
+    GimpBrush* brush = GIMP_BRUSH(data);
+    this->radius     = radius;
+    int brush_radius = MAX(brush->mask->width, brush->mask->height);
+
+    if (brush_radius < 1) 
+      return false;
+
+    float scale                   = radius * 2 / brush_radius;
+    float gimp_brush_aspect_ratio = 20 * (1.0 - ( 1.0 / aspect_ratio));
+
+    GimpBrush* current_brush;
+    current_brush = gimp_brush_select_brush (brush,
+                                            last_coords,
+                                            current_coords);
+
+    *last_coords = *current_coords;
+
+    dab_mask=
+      gimp_brush_transform_mask (current_brush,
+                                 scale,
+                                 gimp_brush_aspect_ratio,
+                                 -angle / 360,
+                                 hardness);
+    return true;
+  }
+  
+
+  void 
+  get_boundary(int&x1, int& y1, int& x2, int& y2) 
+  {
+    int radius_x  = (dab_mask->width + 1) / 2;
+    int radius_y  = (dab_mask->height + 1) / 2;
+    /* configure the pixel regions */
+    x1  = floor(x - radius_x);
+    y1  = floor(y - radius_y);
+    x2  = floor(x1 + dab_mask->width - 1);
+    y2  = floor(y1 + dab_mask->height - 1);
+  };
+
+  
+  void 
+  fill_brushmark_buffer (Pixel::real *dab_mask,
+                         gint*, //offsets: unused
+                         float ,//cx_in_tile: unused 
+                         float ,//cy_in_tile: unused
+                         PixelRegion* srcPR,
+                         PixelRegion* channelPR,
+                         PixelRegion* texturePR) 
+  {
+    Pixel::real*   mask_ptr;
+    Pixel::data_t* data;
+
+    mask_ptr = dab_mask;
+    data = srcPR->data;
+    for (int y = 0; y < srcPR->h; y ++) {
+      for (int x = 0; x < srcPR->w; x ++) {
+        *mask_ptr = eval(pix(data[x]));
+        mask_ptr ++;
+      }
+      data += srcPR->rowstride;
+    }
+
+    if (channelPR) {
+      mask_ptr = dab_mask;
+      data = srcPR->data;
+      Pixel::data_t* data2 = channelPR->data;
+      for (int y = 0; y < srcPR->h; y ++) {
+        for (int x = 0; x < srcPR->w; x ++) {
+          *mask_ptr = eval(pix(*mask_ptr) * pix(data2[x]));
+          mask_ptr ++;
+        }
+        data2 += channelPR->rowstride;
+      }
+    }
+
+    if (texturePR) {
+      mask_ptr = dab_mask;
+      data = srcPR->data;
+      Pixel::data_t* data2 = texturePR->data;
+      for (int y = 0; y < srcPR->h; y ++) {
+        for (int x = 0; x < srcPR->w; x ++) {
+          *mask_ptr = eval(pix(*mask_ptr) * (pix(data2[x * texturePR->bytes]) + pix(texture_grain)) * pix(texture_contrast) );
+          mask_ptr ++;
+        }
+        data2 += texturePR->rowstride;
+      }
+    }
+
+  }
+
+
+  void 
+  draw_dab(PixelRegion* srcPR, 
+           PixelRegion* destPR,
+           PixelRegion* brushPR, 
+           PixelRegion* maskPR,
+           PixelRegion* texturePR)
+  {
+    Pixel::real dab_mask[TILE_WIDTH*TILE_HEIGHT+2*TILE_HEIGHT];
+
+    Pixel::data_t* src_data  = srcPR->data;
+    Pixel::data_t* dest_data = destPR->data; 
+    
+    fill_brushmark_buffer (dab_mask,
+                           NULL,
+                           x - srcPR->x,
+                           y - srcPR->y,
+                           brushPR,
+                           maskPR, texturePR);
+
+    iterator iter(dab_mask, fg_color, 
+                  src_data, dest_data, 
+                  srcPR->w, srcPR->h, 
+                  brushPR->w, 
+                  srcPR->rowstride,
+                  destPR->rowstride,
+                      1,
+                  srcPR->bytes,
+                  destPR->bytes);
+
+    Parent::draw_dab(iter);        
+  }
+
+};
+
+////////////////////////////////////////////////////////////////////////////////
+#define DefineRegionProcessor(CLASS, FUNC) \
+template<typename MypaintSurfaceImpl> \
+class CLASS { \
+public: \
+  static void process_src_dest(MypaintSurfaceImpl* impl, \
+                               PixelRegion* srcPR, \
+                               PixelRegion* destPR) \
+  { \
+    impl->FUNC(srcPR, destPR, NULL, NULL, NULL); \
+  } \
+ \
+  static void process_src_dest_mask(MypaintSurfaceImpl* impl,  \
+                                    PixelRegion* srcPR,  \
+                                    PixelRegion* destPR,  \
+                                    PixelRegion* maskPR) \
+  { \
+    impl->FUNC(srcPR, destPR, NULL, maskPR, NULL); \
+  } \
+ \
+  static void process_src_dest_brush(MypaintSurfaceImpl* impl, \
+                                     PixelRegion* srcPR,  \
+                                     PixelRegion* destPR, \
+                                     PixelRegion* brushPR) \
+  { \
+    impl->FUNC(srcPR, destPR, brushPR, NULL, NULL); \
+  } \
+ \
+  static void process_full(MypaintSurfaceImpl* impl, \
+                           PixelRegion* srcPR, \
+                           PixelRegion* destPR, \
+                           PixelRegion* brushPR, \
+                           PixelRegion* maskPR, \
+                           PixelRegion* texturePR) \
+  { \
+    impl->FUNC(srcPR, destPR, brushPR, maskPR, texturePR); \
+  } \
+ \
+  void \
+  process(MypaintSurfaceImpl* impl, \
+          PixelRegion* srcPR, \
+          PixelRegion* destPR, \
+          PixelRegion* brushPR, \
+          PixelRegion* maskPR, \
+          PixelRegion* texturePR) \
+  { \
+    pixel_regions_process_parallel((PixelProcessorFunc)CLASS::process_full, \
+                                   impl, \
+                                   5, \
+                                   srcPR, destPR, brushPR, maskPR, texturePR); \
+  }; \
+      \
+};
+
+DefineRegionProcessor(DrawDabProcessor, draw_dab);
+DefineRegionProcessor(CopyStrokeProcessor, copy_stroke);
+
+////////////////////////////////////////////////////////////////////////////////
+class GimpMypaintSurfaceImpl : public GimpMypaintSurface
+{
+private:
+  virtual GimpUndo* push_undo (GimpImage *imag, const gchar* undo_desc);
+  GimpDrawable* drawable;
+  GimpRGB       bg_color;
+  GimpBrush*    brushmark;
+  GimpPattern*  texture;
+  GimpCoords    last_coords;
+  GimpCoords    current_coords;
+  bool          floating_stroke;
+  double        stroke_opacity;
+  
+  TileManager* undo_tiles;       /*  tiles which have been modified      */
+  TileManager* floating_stroke_tiles;
+
+  gint         x1, y1;           /*  undo extents in image coords        */
+  gint         x2, y2;           /*  undo extents in image coords        */
+  gint         session;          /*  reference counter of atomic scope   */
+
+  void      validate_undo_tiles       (gint              x,
+                                       gint              y,
+                                       gint              w,
+                                       gint              h);
+
+  void      validate_floating_stroke_tiles (gint              x,
+                                            gint              y,
+                                            gint              w,
+                                            gint              h);
+
+  void start_undo_group();
+  void stop_updo_group();
+  
+  void start_floating_stroke();
+  void stop_floating_stroke();
+public:
+  GimpMypaintSurfaceImpl(GimpDrawable* d) 
+    : undo_tiles(NULL), floating_stroke_tiles(NULL), 
+      session(0), drawable(d), brushmark(NULL), 
+      floating_stroke(false), stroke_opacity(1.0), texture(NULL)
+  {
+    g_object_add_weak_pointer(G_OBJECT(d), (gpointer*)&drawable);
+  }
+
+  virtual ~GimpMypaintSurfaceImpl()
+  {
+    if (drawable)
+      g_object_remove_weak_pointer(G_OBJECT(drawable), (gpointer*)&drawable);
+    if (undo_tiles) {
+      tile_manager_unref (undo_tiles);
+      undo_tiles = NULL;
+    }
+    if (floating_stroke_tiles) {
+      tile_manager_unref (floating_stroke_tiles);
+      floating_stroke_tiles = NULL;
+    }
+    if (brushmark)
+      g_object_unref(G_OBJECT(brushmark));
+
+    if (texture)
+      g_object_unref(G_OBJECT(texture));
+  }
+
+
+  virtual bool draw_dab (float x, float y, 
+                         float radius, 
+                         float color_r, float color_g, float color_b,
+                         float opaque, float hardness = 0.5,
+                         float alpha_eraser = 1.0,
+                         float aspect_ratio = 1.0, float angle = 0.0,
+                         float lock_alpha = 0.0, float colorize = 0.0,
+                         float texture_grain = 0.0, float texture_contrast = 1.0
+                         );
+
+  template<class BrushImpl>
+  bool draw_dab_impl (BrushImpl& brush_impl,
+                      float x, float y, 
+                      float radius, 
+                      float color_r, float color_g, float color_b,
+                      float opaque, float hardness,
+                      float color_a,
+                      float aspect_ratio, float angle,
+                      float lock_alpha,float colorize,
+                      float texture_grain = 0.0, float texture_contrast = 1.0)
+  {
+    GimpItem        *item  = GIMP_ITEM (drawable);
+    GimpImage       *image = gimp_item_get_image (item);
+    GimpChannel     *mask  = gimp_image_get_mask (image);
+    gint            offset_x, offset_y;
+    PixelRegion     src1PR, destPR;
+    PixelRegion     brushPR;
+    PixelRegion     maskPR;
+    PixelRegion     texturePR;
+    
+    opaque     = CLAMP(opaque, 0.0, 1.0);
+    hardness   = CLAMP(hardness, 0.0, 1.0);
+    lock_alpha = CLAMP(lock_alpha, 0.0, 1.0);
+    colorize   = CLAMP(colorize, 0.0, 1.0);
+
+    if (radius < 0.1) return false; // don't bother with dabs smaller than 0.1 pixel
+    if (hardness == 0.0) return false; // infintly small center point, fully transparent outside
+    if (opaque == 0.0) return false;
+
+    if (aspect_ratio<1.0) aspect_ratio=1.0;
+
+    /*  get the layer offsets  */
+    gimp_item_get_offset (item, &offset_x, &offset_y);
+
+    // blending mode preparation
+    float normal = 1.0;
+
+    normal *= 1.0-lock_alpha;
+    normal *= 1.0-colorize;
+
+    Pixel::real fg_color[4];
+    fg_color[0] = color_r;
+    fg_color[1] = color_g;
+    fg_color[2] = color_b;
+    fg_color[3] = color_a;
+    Pixel::real bg_color[3];
+    bg_color[0] = this->bg_color.r;
+    bg_color[1] = this->bg_color.g;
+    bg_color[2] = this->bg_color.b;
+
+    if (!brush_impl.prepare_brush(x, y, radius, 
+                                  hardness, aspect_ratio, angle, 
+                                  normal, opaque, lock_alpha,
+                                  fg_color, color_a, bg_color, stroke_opacity,
+                                  texture_grain, texture_contrast,
+                                  (void*)brushmark))
+      return false;
+
+    int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
+    brush_impl.get_boundary(x1, y1, x2, y2);
+
+    int rx1 = x1;
+    int ry1 = y1;
+    int rx2 = x2;
+    int ry2 = y2;
+    
+    GimpItem *mask_item = NULL;
+    if (mask && !gimp_channel_is_empty(GIMP_CHANNEL(mask))) {
+      mask_item = GIMP_ITEM (mask);
+
+      /*  make sure coordinates are in mask bounds ...
+       *  we need to add the layer offset to transform coords
+       *  into the mask coordinate system
+       */
+      rx1 = CLAMP (rx1, -offset_x, gimp_item_get_width  (mask_item) - offset_x);
+      ry1 = CLAMP (ry1, -offset_y, gimp_item_get_height (mask_item) - offset_y);
+      rx2 = CLAMP (rx2, -offset_x, gimp_item_get_width  (mask_item) - offset_x);
+      ry2 = CLAMP (ry2, -offset_y, gimp_item_get_height (mask_item) - offset_y);
+    }
+    rx1 = CLAMP (rx1, 0, gimp_item_get_width  (item) - 1);
+    ry1 = CLAMP (ry1, 0, gimp_item_get_height (item) - 1);
+    rx2 = CLAMP (rx2, 0, gimp_item_get_width  (item) - 1);
+    ry2 = CLAMP (ry2, 0, gimp_item_get_height (item) - 1);
+
+    TempBuf* dab_mask = (TempBuf*)brush_impl.get_brush_data();
+
+    if (dab_mask) {
+      if (dab_mask->width < rx2 - rx1 + 1)
+        rx2 = rx1 + dab_mask->width - 1;
+      if (dab_mask->height < ry2 - ry1 + 1)
+        ry2 = ry1 + dab_mask->height - 1;
+    }
+
+    int width    = (rx2 - rx1 + 1);
+    int height   = (ry2 - ry1 + 1);
+
+    if (rx1 > rx2 || ry1 > ry2)
+      return false;
+
+    if (dab_mask &&
+        (dab_mask->width < rx1 - x1 || dab_mask->height < ry1 - y1))
+      return false;
+
+    /*  set undo blocks  */
+    start_undo_group();
+    validate_undo_tiles (rx1, ry1, width, height);
+
+    if (floating_stroke) {
+      validate_floating_stroke_tiles(rx1, ry1, width, height);
+
+      pixel_region_init (&src1PR, floating_stroke_tiles,
+                         rx1, ry1, width, height,
+                         FALSE);
+
+      pixel_region_init (&destPR, floating_stroke_tiles,
+                         rx1, ry1, width, height,
+                         FALSE);
+    } else {
+      pixel_region_init (&src1PR, gimp_drawable_get_tiles (drawable),
+                         rx1, ry1, width, height,
+                         TRUE);
+
+      pixel_region_init (&destPR, gimp_drawable_get_tiles (drawable),
+                         rx1, ry1, width, height,
+                         TRUE);
+     }
+
+    TempBuf* pattern = NULL;
+    if (texture) {
+      pattern = gimp_pattern_get_mask (texture);
+    }
+
+    if (dab_mask)
+      pixel_region_init_temp_buf(&brushPR, dab_mask, 
+                                 MAX(rx1 - x1, 0), 
+                                 MAX(ry1 - y1, 0), 
+                                 width, height);
+
+    if (mask_item) {
+      pixel_region_init (&maskPR,
+                         gimp_drawable_get_tiles (GIMP_DRAWABLE (mask)),
+                         rx1 + offset_x,
+                         ry1 + offset_y,
+                         width, height,
+                         TRUE);
+     }
+
+    if (pattern) {
+      pixel_region_init_temp_buf(&texturePR, pattern,
+                                 rx1 % pattern->width,
+                                 ry1 % pattern->height,
+                                 pattern->width, pattern->height);
+      pixel_region_set_closed_loop(&texturePR, TRUE);
+    }
+    
+    DrawDabProcessor<BrushImpl> processor;
+    processor.process(&brush_impl,
+                     &src1PR, 
+                     &destPR, 
+                     (dab_mask)? &brushPR: NULL, 
+                     (mask_item)? &maskPR: NULL,
+                     (pattern)? &texturePR: NULL);
+
+    if (floating_stroke) {
+      /* Copy floating stroke buffer into drawable buffer */
+      pixel_region_init (&src1PR, undo_tiles,
+                         rx1, ry1, width, height,
+                         TRUE);
+
+      pixel_region_init (&destPR, gimp_drawable_get_tiles(drawable),
+                         rx1, ry1, width, height,
+                         TRUE);
+
+      pixel_region_init (&brushPR, floating_stroke_tiles,
+                         rx1, ry1, width, height,
+                         FALSE);
+
+      if (mask_item) {
+        pixel_region_init (&maskPR,
+                           gimp_drawable_get_tiles (GIMP_DRAWABLE (mask)),
+                           rx1 + offset_x,
+                           ry1 + offset_y,
+                           rx2 - rx1, ry2 - ry1,
+                           TRUE);
+        }
+      
+      CopyStrokeProcessor<BrushImpl> stroke_processor;
+      stroke_processor.process(&brush_impl,
+                               &src1PR,
+                               &destPR,
+                               &brushPR,
+                               NULL, NULL);
+    }
+
+    /*  Update the drawable  */
+    gimp_drawable_update (drawable, rx1, ry1, width, height);
+    if (rx1 < this->x1)
+      this->x1 = rx1;
+    if (ry1 < this->y1)
+      this->y1 = ry1;
+    if (rx1 + width > this->x2)
+      this->x2 = rx1 + width;
+    if (ry1 + height > this->y2)
+      this->y2 = ry1 + height;
+
+    return true;
+  }
+
+
+  virtual void get_color (float x, float y, 
+                          float radius, 
+                          float * color_r, float * color_g, float * color_b, float * color_a,
+                          float texture_grain, float texture_contrast
+                          );
+
+  virtual void begin_session();
+  virtual void end_session();
+  
+  bool is_surface_for (GimpDrawable* drawable) { return drawable == this->drawable; }
+  void set_bg_color (GimpRGB* src) 
+  { 
+    if (src)
+      bg_color = *src; 
+  }
+
+  void get_bg_color (GimpRGB* dest) 
+  {
+    if (dest)
+      *dest = bg_color; 
+  }
+
+  void set_brushmark(GimpBrush* brush_)
+  {
+    if (brushmark) {
+      gimp_brush_end_use(brushmark);
+      g_object_unref(G_OBJECT(brushmark));
+      brushmark = NULL;
+    }
+
+    if (brush_) {
+      brushmark = brush_;
+      gimp_brush_begin_use(brushmark);
+      g_object_ref(G_OBJECT(brushmark));
+    }
+  }
+
+  GimpBrush* get_brushmark()
+  {
+    return brushmark;
+  }
+
+  void set_texture(GimpPattern* texture_)
+  {
+    if (texture) {
+      g_object_unref(G_OBJECT(texture));
+      texture = NULL;
+    }
+
+    if (texture_) {
+      texture = texture_;
+      g_object_ref(G_OBJECT(texture));
+    }
+  }
+
+  GimpPattern* get_texture()
+  {
+    return texture;
+  }
+
+  void set_floating_stroke(bool value) {
+    floating_stroke = value;
+  }
+
+  bool get_floating_stroke () {
+    return floating_stroke;
+  }
+
+  void set_stroke_opacity(double value) {
+    stroke_opacity = CLAMP(value, 0.0, 1.0);
+  }
+
+  virtual void set_coords(const GimpCoords* coords) { current_coords = *coords; }
+};
+
+
+
+bool
+GimpMypaintSurfaceImpl::draw_dab (float x, float y, 
+                                  float radius, 
+                                  float color_r, float color_g, float color_b,
+                                  float opaque, float hardness,
+                                  float color_a,
+                                  float aspect_ratio, float angle,
+                                  float lock_alpha,
+                                  float colorize,
+                                  float texture_grain,
+                                  float texture_contrast)
+{
+  if (brushmark) {
+//	 g_print("GimpBrush::draw_dab_impl@%4f,%4f\n", x, y);
+    GimpMypaintSurfaceForGimpBrush brush_impl(&current_coords, &last_coords);
+    return draw_dab_impl(brush_impl,
+                          x, y, radius, color_r, color_g, color_b, opaque,
+                          hardness, color_a, aspect_ratio, angle, lock_alpha,
+                          colorize, texture_grain, texture_contrast);
+  } else {
+//	 g_print("MypaintBrush::draw_dab_impl@%4f,%4f\n",x,y);
+    GimpMypaintSurfaceForMypaintBrush brush_impl;
+    return draw_dab_impl(brush_impl,
+                          x, y, radius, color_r, color_g, color_b, opaque,
+                          hardness, color_a, aspect_ratio, angle, lock_alpha,
+                          colorize, texture_grain, texture_contrast);
+  }
+}
+
+void 
+GimpMypaintSurfaceImpl::get_color (float x, float y, 
+                                   float radius, 
+                                   float * color_r, 
+                                   float * color_g, 
+                                   float * color_b, 
+                                   float * color_a,
+                                   float texture_grain,
+                                   float texture_contrast)
+{
+  GimpMypaintSurfaceForMypaintBrush brush_impl;
+
+  if (radius < 1.0) radius = 1.0;
+
+  float sum_weight, sum_r, sum_g, sum_b, sum_a;
+  sum_weight = sum_r = sum_g = sum_b = sum_a = 0.0;
+  const float hardness = 0.5;
+  const float aspect_ratio = 1.0;
+  const float angle = 0.0;
+
+  // in case we return with an error
+  *color_r = 0.0;
+  *color_g = 1.0;
+  *color_b = 0.0;
+
+  // WARNING: some code duplication with draw_dab
+
+  GimpItem        *item  = GIMP_ITEM (drawable);
+  GimpImage       *image = gimp_item_get_image (item);
+  GimpChannel     *mask  = gimp_image_get_mask (image);
+  gint             offset_x, offset_y;
+  PixelRegion      src1PR;
+  PixelRegion maskPR;
+  
+  /*  get the layer offsets  */
+  gimp_item_get_offset (item, &offset_x, &offset_y);
+  Pixel::real fg_color[] = {0.0, 0.0, 0.0, 1.0};
+  Pixel::real bg_color[] = {1.0, 1.0, 1.0};
+  if (!brush_impl.prepare_brush(x, y, radius, 
+                                hardness, aspect_ratio, angle, 
+                                1.0, 1.0, 0.0,
+                                fg_color, 1.0, bg_color, stroke_opacity,
+                                texture_grain, texture_contrast,
+                                brushmark))
+      return;
+
+  int x1, y1, x2, y2;
+  brush_impl.get_boundary(x1, y1, x2, y2);
+
+  int rx1 = x1;
+  int ry1 = y1;
+  int rx2 = x2;
+  int ry2 = y2;
+
+  if (rx1 > rx2 || ry1 > ry2)
+    return;
+
+  GimpItem *mask_item = NULL;
+  if (mask && !gimp_channel_is_empty(GIMP_CHANNEL(mask))) {
+    mask_item = GIMP_ITEM (mask);
+
+    /*  make sure coordinates are in mask bounds ...
+     *  we need to add the layer offset to transform coords
+     *  into the mask coordinate system
+     */
+    rx1 = CLAMP (rx1, -offset_x, gimp_item_get_width  (mask_item) - offset_x);
+    ry1 = CLAMP (ry1, -offset_y, gimp_item_get_height (mask_item) - offset_y);
+    rx2 = CLAMP (rx2, -offset_x, gimp_item_get_width  (mask_item) - offset_x);
+    ry2 = CLAMP (ry2, -offset_y, gimp_item_get_height (mask_item) - offset_y);
+  }
+  rx1 = CLAMP (rx1, 0, gimp_item_get_width  (item) - 1);
+  ry1 = CLAMP (ry1, 0, gimp_item_get_height (item) - 1);
+  rx2 = CLAMP (rx2, 0, gimp_item_get_width  (item) - 1);
+  ry2 = CLAMP (ry2, 0, gimp_item_get_height (item) - 1);
+  
+  int width   = (rx2 - rx1 + 1);
+  int height   = (ry2 - ry1 + 1);
+  if (floating_stroke) {
+  
+    pixel_region_init (&src1PR, floating_stroke_tiles,
+                       rx1, ry1, width, height,
+                       FALSE);
+
+  } else {
+    pixel_region_init (&src1PR, gimp_drawable_get_tiles (drawable),
+                       rx1, ry1, width, height,
+                       FALSE);
+  }
+
+  gpointer pr;
+  if (mask_item) {
+    pixel_region_init (&maskPR,
+                       gimp_drawable_get_tiles (GIMP_DRAWABLE (mask)),
+                       rx1 + offset_x,
+                       ry1 + offset_y,
+                       rx2 - rx1, ry2 - ry1,
+                       FALSE);
+
+    pr = pixel_regions_register (2, &src1PR, &maskPR);
+  } else {
+    pr = pixel_regions_register (1, &src1PR);
+  }
+
+  // first, we calculate the mask (opacity for each pixel)
+  Pixel::real dab_mask[TILE_WIDTH*TILE_HEIGHT+2*TILE_HEIGHT];
+  gint dab_offsets[(TILE_HEIGHT + 2)*2];
+  for (;
+       pr != NULL;
+       pr = pixel_regions_process ((PixelRegionIterator*)pr)) {
+    Pixel::data_t*  src_data = src1PR.data;
+    
+
+    brush_impl.fill_brushmark_buffer(dab_mask,
+                                     dab_offsets,
+                                     x - src1PR.x,
+                                     y - src1PR.y,
+                                     &src1PR, (mask_item)? &maskPR : NULL, NULL
+                                     );
+
+    BrushPixelIteratorForRunLength iter(dab_mask, dab_offsets, NULL, src_data, src_data,  src1PR.bytes, src1PR.bytes);
+
+    get_color_pixels_accumulate (iter,
+                                 &sum_weight, &sum_r, &sum_g, &sum_b, &sum_a);
+  }
+
+//  assert(sum_weight > 0.0);
+  if (sum_weight > 0.0) {
+    sum_a /= sum_weight;
+    sum_r /= sum_weight;
+    sum_g /= sum_weight;
+    sum_b /= sum_weight;
+  }
+
+  *color_a = sum_a;
+  // now un-premultiply the alpha
+  if (sum_a > 0.0) {
+    *color_r = sum_r / sum_a;
+    *color_g = sum_g / sum_a;
+    *color_b = sum_b / sum_a;
+  } else {
+    // it is all transparent, so don't care about the colors
+    // (let's make them ugly so bugs will be visible)
+    *color_r = 0.0;
+    *color_g = 1.0;
+    *color_b = 0.0;
+  }
+
+  // fix rounding problems that do happen due to floating point math
+  *color_r = CLAMP(*color_r, 0.0, 1.0);
+  *color_g = CLAMP(*color_g, 0.0, 1.0);
+  *color_b = CLAMP(*color_b, 0.0, 1.0);
+  *color_a = CLAMP(*color_a, 0.0, 1.0);
+}
+
+void 
+GimpMypaintSurfaceImpl::begin_session()
+{
+  session = 0;
+  if (floating_stroke)
+    start_floating_stroke();
+}
+
+void 
+GimpMypaintSurfaceImpl::end_session()
+{
+  if (session <= 0)
+    return;
+    
+  stop_updo_group();
+  if (floating_stroke)
+    stop_floating_stroke();
+  session = 0;
+}
+
+void 
+GimpMypaintSurfaceImpl::start_undo_group()
+{
+  GimpItem *item;
+  
+  if (session > 0)
+    return;
+  g_print("Stroke::start_undo_group...\n");
+  session = 1;
+
+  g_return_if_fail (gimp_item_is_attached (GIMP_ITEM (drawable)));
+  g_print("Stroke::begin_session:: do begining of session...\n");
+//  g_return_if_fail (coords != NULL);
+//  g_return_if_fail (error == NULL || *error == NULL);
+
+  item = GIMP_ITEM (drawable);
+
+  /*  Allocate the undo structure  */
+  if (undo_tiles)
+    tile_manager_unref (undo_tiles);
+
+  undo_tiles = tile_manager_new (gimp_item_get_width  (item),
+                                 gimp_item_get_height (item),
+                                 gimp_drawable_bytes (drawable));
+
+  /*  Get the initial undo extents  */
+  x1 = gimp_item_get_width (item) + 1;
+  y1 = gimp_item_get_height (item) + 1;
+  x2 = -1;
+  y2 = -1;
+
+  /*  Freeze the drawable preview so that it isn't constantly updated.  */
+  gimp_viewable_preview_freeze (GIMP_VIEWABLE (drawable));
+
+  return;
+}
+
+void 
+GimpMypaintSurfaceImpl::stop_updo_group()
+{
+  GimpImage *image;
+
+  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));
+  g_return_if_fail (gimp_item_is_attached (GIMP_ITEM (drawable)));
+
+  image = gimp_item_get_image (GIMP_ITEM (drawable));
+
+  /*  Determine if any part of the image has been altered--
+   *  if nothing has, then just return...
+   */
+  if (x2 < x1 || y2 < y1) {
+    gimp_viewable_preview_thaw (GIMP_VIEWABLE (drawable));
+    return;
+  }
+
+  g_print("Stroke::end_session::push_undo(%d,%d)-(%d,%d)\n",x1,y1,x2,y2);
+  push_undo (image, "Mypaint Brush");
+
+  gimp_viewable_preview_thaw (GIMP_VIEWABLE (drawable));
+  
+  return;
+}
+
+GimpUndo *
+GimpMypaintSurfaceImpl::push_undo (GimpImage     *image,
+                                const gchar   *undo_desc)
+{
+  gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_MYPAINT,
+                               undo_desc);
+
+  gimp_image_undo_push (image, GIMP_TYPE_MYPAINT_CORE_UNDO,
+                               GIMP_UNDO_PAINT, NULL,
+                               GimpDirtyMask(0),
+                               NULL);
+  if (undo_tiles) {
+    gimp_image_undo_push_drawable (image, "Mypaint Brush",
+                                   drawable, undo_tiles,
+                                   TRUE, x1, y1, x2 - x1, y2 - y1);
+  }
+  gimp_image_undo_group_end (image);
+
+  tile_manager_unref (undo_tiles);
+  undo_tiles = NULL;
+
+  return NULL;
+}
+
+void 
+GimpMypaintSurfaceImpl::start_floating_stroke()
+{
+  g_return_if_fail(drawable);
+  GimpItem* item = GIMP_ITEM (drawable);
+
+  if (floating_stroke_tiles) {
+    tile_manager_unref(floating_stroke_tiles);
+    floating_stroke_tiles = NULL;
+  }
+
+  gint bytes = gimp_drawable_bytes_with_alpha (drawable);
+  floating_stroke_tiles = tile_manager_new(gimp_item_get_width(item),
+                                           gimp_item_get_height(item),
+                                           bytes);
+
+}
+
+void 
+GimpMypaintSurfaceImpl::stop_floating_stroke()
+{
+  if (floating_stroke_tiles) {
+    tile_manager_unref(floating_stroke_tiles);
+    floating_stroke_tiles = NULL;
+  }
+}
+
+void
+GimpMypaintSurfaceImpl::validate_floating_stroke_tiles(gint x, 
+                                                   gint y,
+                                                   gint w,
+                                                   gint h)
+{
+  gint i, j;
+
+  g_return_if_fail (floating_stroke_tiles != NULL);
+
+  for (i = y; i < (y + h); i += (TILE_HEIGHT - (i % TILE_HEIGHT))) {
+    for (j = x; j < (x + w); j += (TILE_WIDTH - (j % TILE_WIDTH))) {
+      Tile *tile = tile_manager_get_tile (floating_stroke_tiles, j, i,
+                                          FALSE, FALSE);
+
+      if (! tile_is_valid (tile)) {
+        tile = tile_manager_get_tile (floating_stroke_tiles, j, i,
+                                      TRUE, TRUE);
+        memset (tile_data_pointer (tile, 0, 0), 0, tile_size (tile));
+        tile_release (tile, TRUE);
+      }
+      
+    }
+  }
+
+}
+
+void
+GimpMypaintSurfaceImpl::validate_undo_tiles (
+                                             gint           x,
+                                             gint           y,
+                                             gint           w,
+                                             gint           h)
+{
+  gint i, j;
+  GimpItem* item = GIMP_ITEM (drawable);
+
+  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));
+  g_return_if_fail (undo_tiles != NULL);
+  
+  if (x + w > gimp_item_get_width(item))
+    w = MAX(0, gimp_item_get_width(item) - x);
+  if (y + h > gimp_item_get_height(item))
+    h = MAX(0, gimp_item_get_height(item) - y);
+  
+  for (i = y; i < (y + h); i += (TILE_HEIGHT - (i % TILE_HEIGHT))) {
+    for (j = x; j < (x + w); j += (TILE_WIDTH - (j % TILE_WIDTH))) {
+      Tile *dest_tile = tile_manager_get_tile (undo_tiles, j, i, FALSE, FALSE);
+      assert(j< gimp_item_get_width(item));
+      assert(i< gimp_item_get_height(item));
+
+      if (! tile_is_valid (dest_tile)) {
+        Tile *src_tile =
+          tile_manager_get_tile (gimp_drawable_get_tiles (drawable),
+                                 j, i, TRUE, FALSE);
+        tile_manager_map_tile (undo_tiles, j, i, src_tile);
+        tile_release (src_tile, FALSE);
+
+      }
+    }
+  }
+  
+}
+
+GimpMypaintSurface* GimpMypaintSurface_new(GimpDrawable* drawable)
+{
+  return new GimpMypaintSurfaceImpl(drawable);
+}
diff -Naur gimp-2.8.14/app/paint/gimpmypaintcore-surface.hpp gimp-2.8.14-new/app/paint/gimpmypaintcore-surface.hpp
--- gimp-2.8.14/app/paint/gimpmypaintcore-surface.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintcore-surface.hpp	2015-01-27 17:48:55.352751581 +0800
@@ -0,0 +1,56 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_CORE_SURFACE_HPP__
+#define __GIMP_MYPAINT_CORE_SURFACE_HPP__
+
+extern "C" {
+#include <glib-object.h>
+#include "core/gimpobject.h"
+#include "gimpmypaintoptions.h"
+#include "core/gimpmypaintbrush.h"
+#include "core/gimpundo.h"
+#include "core/gimpbrush.h"
+}
+
+extern "C++" {
+#include "mypaintbrush-surface.hpp"
+#define REAL_CALC
+#include "core/gimpcoords.h"
+#include "base/pixel.hpp"
+
+class GimpMypaintSurface : public Surface
+{
+public:
+
+  virtual bool is_surface_for (GimpDrawable* drawable) = 0;
+  virtual void set_bg_color (GimpRGB* src) = 0;
+  virtual void get_bg_color(GimpRGB* dest) = 0;
+  virtual void set_brushmark(GimpBrush* brush_) = 0;
+  virtual GimpBrush* get_brushmark() = 0;
+  virtual void set_floating_stroke(bool value) = 0;
+  virtual bool get_floating_stroke() = 0;
+  virtual void set_stroke_opacity(double value) = 0;
+  virtual void set_coords(const GimpCoords* coords) = 0;
+  virtual void set_texture(GimpPattern* texture) = 0;
+  virtual GimpPattern* get_texture() = 0;
+};
+
+GimpMypaintSurface* GimpMypaintSurface_new(GimpDrawable* drawable);
+
+}
+#endif  /*  __GIMP_MYPAINT_SURFACE_HPP__  */
diff -Naur gimp-2.8.14/app/paint/gimpmypaintcoreundo.cpp gimp-2.8.14-new/app/paint/gimpmypaintcoreundo.cpp
--- gimp-2.8.14/app/paint/gimpmypaintcoreundo.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintcoreundo.cpp	2015-01-27 17:48:55.354751581 +0800
@@ -0,0 +1,164 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern "C" {
+#include "config.h"
+
+#include <glib-object.h>
+
+#include "paint-types.h"
+
+#include "libgimpmath/gimpmath.h"
+#include "gimpmypaintcore.hpp"
+#include "gimpmypaintcoreundo.h"
+};
+#include "mypaintbrush-surface.hpp"
+#include "mypaintbrush-stroke.hpp"
+
+enum
+{
+  PROP_0,
+  PROP_STROKE
+};
+
+
+static void   gimp_mypaint_core_undo_constructed  (GObject             *object);
+static void   gimp_mypaint_core_undo_set_property (GObject             *object,
+                                                 guint                property_id,
+                                                 const GValue        *value,
+                                                 GParamSpec          *pspec);
+static void   gimp_mypaint_core_undo_get_property (GObject             *object,
+                                                 guint                property_id,
+                                                 GValue              *value,
+                                                 GParamSpec          *pspec);
+
+static void   gimp_mypaint_core_undo_pop          (GimpUndo            *undo,
+                                                 GimpUndoMode         undo_mode,
+                                                 GimpUndoAccumulator *accum);
+static void   gimp_mypaint_core_undo_free         (GimpUndo            *undo,
+                                                 GimpUndoMode         undo_mode);
+
+
+G_DEFINE_TYPE (GimpMypaintCoreUndo, gimp_mypaint_core_undo, GIMP_TYPE_UNDO)
+
+#define parent_class gimp_mypaint_core_undo_parent_class
+
+
+static void
+gimp_mypaint_core_undo_class_init (GimpMypaintCoreUndoClass *klass)
+{
+  GObjectClass  *object_class = G_OBJECT_CLASS (klass);
+  GimpUndoClass *undo_class   = GIMP_UNDO_CLASS (klass);
+
+  object_class->constructed  = gimp_mypaint_core_undo_constructed;
+  object_class->set_property = gimp_mypaint_core_undo_set_property;
+  object_class->get_property = gimp_mypaint_core_undo_get_property;
+
+  undo_class->pop            = gimp_mypaint_core_undo_pop;
+  undo_class->free           = gimp_mypaint_core_undo_free;
+
+  g_object_class_install_property (object_class, PROP_STROKE,
+                                   g_param_spec_object ("stroke", NULL, NULL,
+                                                        G_TYPE_POINTER,
+                                                        (GParamFlags)(GIMP_PARAM_READWRITE |
+                                                        G_PARAM_CONSTRUCT_ONLY)));
+}
+
+static void
+gimp_mypaint_core_undo_init (GimpMypaintCoreUndo *undo)
+{
+}
+
+static void
+gimp_mypaint_core_undo_constructed (GObject *object)
+{
+  GimpMypaintCoreUndo *mypaint_core_undo = GIMP_MYPAINT_CORE_UNDO (object);
+
+  if (G_OBJECT_CLASS (parent_class)->constructed)
+    G_OBJECT_CLASS (parent_class)->constructed (object);
+
+}
+
+static void
+gimp_mypaint_core_undo_set_property (GObject      *object,
+                                   guint         property_id,
+                                   const GValue *value,
+                                   GParamSpec   *pspec)
+{
+  GimpMypaintCoreUndo *mypaint_core_undo = GIMP_MYPAINT_CORE_UNDO (object);
+
+  switch (property_id)
+    {
+    case PROP_STROKE:
+      mypaint_core_undo->stroke = g_value_get_pointer (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+static void
+gimp_mypaint_core_undo_get_property (GObject    *object,
+                                   guint       property_id,
+                                   GValue     *value,
+                                   GParamSpec *pspec)
+{
+  GimpMypaintCoreUndo *mypaint_core_undo = GIMP_MYPAINT_CORE_UNDO (object);
+
+  switch (property_id)
+    {
+    case PROP_STROKE:
+      g_value_set_pointer (value, mypaint_core_undo->stroke);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+static void
+gimp_mypaint_core_undo_pop (GimpUndo              *undo,
+                          GimpUndoMode           undo_mode,
+                          GimpUndoAccumulator   *accum)
+{
+  GimpMypaintCoreUndo *mypaint_core_undo = GIMP_MYPAINT_CORE_UNDO (undo);
+
+  GIMP_UNDO_CLASS (parent_class)->pop (undo, undo_mode, accum);
+
+  /*  only pop if the core still exists  */
+  if (mypaint_core_undo->stroke)
+    {
+    }
+}
+
+static void
+gimp_mypaint_core_undo_free (GimpUndo     *undo,
+                           GimpUndoMode  undo_mode)
+{
+  GimpMypaintCoreUndo *mypaint_core_undo = GIMP_MYPAINT_CORE_UNDO (undo);
+
+  if (mypaint_core_undo->stroke) {
+    Stroke* stroke = reinterpret_cast<Stroke*>(mypaint_core_undo->stroke);
+    delete stroke;
+    mypaint_core_undo->stroke = NULL;
+  }
+
+  GIMP_UNDO_CLASS (parent_class)->free (undo, undo_mode);
+}
diff -Naur gimp-2.8.14/app/paint/gimpmypaintcoreundo.h gimp-2.8.14-new/app/paint/gimpmypaintcoreundo.h
--- gimp-2.8.14/app/paint/gimpmypaintcoreundo.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintcoreundo.h	2015-01-27 17:48:55.354751581 +0800
@@ -0,0 +1,50 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_CORE_UNDO_H__
+#define __GIMP_MYPAINT_CORE_UNDO_H__
+
+
+#include "core/gimpundo.h"
+
+
+#define GIMP_TYPE_MYPAINT_CORE_UNDO            (gimp_mypaint_core_undo_get_type ())
+#define GIMP_MYPAINT_CORE_UNDO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MYPAINT_CORE_UNDO, GimpMypaintCoreUndo))
+#define GIMP_MYPAINT_CORE_UNDO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MYPAINT_CORE_UNDO, GimpMypaintCoreUndoClass))
+#define GIMP_IS_MYPAINT_CORE_UNDO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MYPAINT_CORE_UNDO))
+#define GIMP_IS_MYPAINT_CORE_UNDO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MYPAINT_CORE_UNDO))
+#define GIMP_MYPAINT_CORE_UNDO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MYPAINT_CORE_UNDO, GimpMypaintCoreUndoClass))
+
+
+typedef struct _GimpMypaintCoreUndoClass GimpMypaintCoreUndoClass;
+
+struct _GimpMypaintCoreUndo
+{
+  GimpUndo         parent_instance;
+  gpointer         stroke;
+};
+
+struct _GimpMypaintCoreUndoClass
+{
+  GimpUndoClass  parent_class;
+};
+
+
+GType   gimp_mypaint_core_undo_get_type (void) G_GNUC_CONST;
+
+
+#endif /* __GIMP_MYPAINT_CORE_UNDO_H__ */
diff -Naur gimp-2.8.14/app/paint/gimpmypaintoptions.cpp gimp-2.8.14-new/app/paint/gimpmypaintoptions.cpp
--- gimp-2.8.14/app/paint/gimpmypaintoptions.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintoptions.cpp	2015-01-27 17:48:55.355751581 +0800
@@ -0,0 +1,444 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern "C" {
+#include "config.h"
+
+#include <glib.h>
+#include <gegl.h>
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpmath/gimpmath.h"
+#include "libgimpconfig/gimpconfig.h"
+
+#include "paint-types.h"
+#include "core/core-types.h"
+
+#include "core/gimp.h"
+#include "core/gimpimage.h"
+#include "core/gimptoolinfo.h"
+#include "core/gimpmypaintbrush.h"
+#include "core/mypaintbrush-enum-settings.h"
+#include "core/mypaintbrush-brushsettings.h"
+
+#include "gimpmypaintoptions.h"
+
+#include "gimp-intl.h"
+
+}; // extern "C"
+
+extern "C++" {
+#include "core/gimpmypaintbrush-private.hpp"
+#include "base/scopeguard.hpp"
+#include "base/glib-cxx-utils.hpp"
+#include "gimpmypaintoptions-history.hpp"
+} // extern "C++"
+
+extern "C" {
+#define DEFAULT_BRUSH_SIZE             20.0
+#define DEFAULT_BRUSH_ASPECT_RATIO     0.0
+#define DEFAULT_BRUSH_ANGLE            0.0
+
+#define DEFAULT_BRUSH_MODE             GIMP_MYPAINT_NORMAL
+
+enum
+{
+  PROP_0 = BRUSH_SETTINGS_COUNT,
+
+  PROP_BRUSH_MODE,
+
+  PROP_BRUSH_VIEW_TYPE,
+  PROP_BRUSH_VIEW_SIZE,
+};
+
+
+static void    gimp_mypaint_options_dispose          (GObject      *object);
+static void    gimp_mypaint_options_finalize         (GObject      *object);
+static void    gimp_mypaint_options_set_property     (GObject      *object,
+                                                    guint         property_id,
+                                                    const GValue *value,
+                                                    GParamSpec   *pspec);
+static void    gimp_mypaint_options_get_property     (GObject      *object,
+                                                    guint         property_id,
+                                                    GValue       *value,
+                                                    GParamSpec   *pspec);
+static void    gimp_mypaint_options_mypaint_brush_changed (GObject *object,
+                                                           GimpData *data);
+
+
+G_DEFINE_TYPE (GimpMypaintOptions, gimp_mypaint_options, GIMP_TYPE_TOOL_OPTIONS)
+
+#define parent_class gimp_mypaint_options_parent_class
+
+
+static void
+gimp_mypaint_options_class_init (GimpMypaintOptionsClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose      = gimp_mypaint_options_dispose;
+  object_class->finalize     = gimp_mypaint_options_finalize;
+  object_class->set_property = gimp_mypaint_options_set_property;
+  object_class->get_property = gimp_mypaint_options_get_property;
+
+  GListHolder brush_settings(mypaint_brush_get_brush_settings ());
+  for (GList* i = brush_settings.ptr(); i; i = i->next) {
+    MyPaintBrushSettings* setting = reinterpret_cast<MyPaintBrushSettings*>(i->data);
+    gchar* signal_name = mypaint_brush_internal_name_to_signal_name (setting->internal_name);
+    g_print("install double parameter %d:%s:(%f-%f),default=%f\n",
+      setting->index + 1, signal_name, setting->minimum, setting->maximum, setting->default_value);
+      
+    GIMP_CONFIG_INSTALL_PROP_DOUBLE (object_class, setting->index + 1,
+      signal_name, _(setting->displayed_name),
+      setting->minimum, setting->maximum,
+      setting->default_value, 
+      (GParamFlags)(GIMP_PARAM_STATIC_STRINGS));
+  }
+  GListHolder switch_settings(mypaint_brush_get_brush_switch_settings ());
+  for (GList* i = switch_settings.ptr(); i; i = i->next) {
+    MyPaintBrushSwitchSettings* setting = reinterpret_cast<MyPaintBrushSwitchSettings*>(i->data);
+    gchar* signal_name = mypaint_brush_internal_name_to_signal_name (setting->internal_name);
+    g_print("install boolean parameter %d:%s,default=%d\n",
+      setting->index + 1, signal_name, setting->default_value);
+      
+    GIMP_CONFIG_INSTALL_PROP_BOOLEAN (object_class, setting->index + 1,
+      signal_name, _(setting->displayed_name),
+      setting->default_value, 
+      (GParamFlags)(GIMP_PARAM_STATIC_STRINGS));
+  }
+  GListHolder text_settings(mypaint_brush_get_brush_text_settings ());
+  for (GList* i = text_settings.ptr(); i; i = i->next) {
+    MyPaintBrushTextSettings* setting = reinterpret_cast<MyPaintBrushTextSettings*>(i->data);
+    gchar* signal_name = mypaint_brush_internal_name_to_signal_name (setting->internal_name);
+    g_print("install string parameter %d:%s,default=%s\n",
+      setting->index + 1, signal_name, setting->default_value);
+      
+    GIMP_CONFIG_INSTALL_PROP_STRING (object_class, setting->index + 1,
+      signal_name, _(setting->displayed_name),
+      setting->default_value, 
+      (GParamFlags)(GIMP_PARAM_STATIC_STRINGS));
+  }
+
+  GIMP_CONFIG_INSTALL_PROP_ENUM (object_class, PROP_BRUSH_MODE,
+                                 "brush-mode", _("Every stamp has its own opacity"),
+                                 GIMP_TYPE_MYPAINT_BRUSH_MODE,
+                                 DEFAULT_BRUSH_MODE,
+                                 GParamFlags(GIMP_PARAM_STATIC_STRINGS));
+
+  GIMP_CONFIG_INSTALL_PROP_ENUM (object_class, PROP_BRUSH_VIEW_TYPE,
+                                 "brush-view-type", NULL,
+                                 GIMP_TYPE_VIEW_TYPE,
+                                 GIMP_VIEW_TYPE_GRID,
+                                 GParamFlags(GIMP_PARAM_STATIC_STRINGS));
+
+  GIMP_CONFIG_INSTALL_PROP_INT (object_class, PROP_BRUSH_VIEW_SIZE,
+                                "brush-view-size", NULL,
+                                GIMP_VIEW_SIZE_TINY,
+                                GIMP_VIEWABLE_MAX_BUTTON_SIZE,
+                                GIMP_VIEW_SIZE_SMALL,
+                                GParamFlags(GIMP_PARAM_STATIC_STRINGS));
+
+}
+
+static void
+gimp_mypaint_options_init (GimpMypaintOptions *options)
+{
+  options->brush_mode      = DEFAULT_BRUSH_MODE;
+  options->brush           = NULL;
+  g_signal_connect(G_OBJECT(options),  
+    gimp_context_type_to_signal_name (GIMP_TYPE_MYPAINT_BRUSH),
+    G_CALLBACK(gimp_mypaint_options_mypaint_brush_changed),
+    NULL);
+}
+
+static void
+gimp_mypaint_options_dispose (GObject *object)
+{
+  GimpMypaintOptions *options = GIMP_MYPAINT_OPTIONS (object);
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+gimp_mypaint_options_finalize (GObject *object)
+{
+  GimpMypaintOptions *options = GIMP_MYPAINT_OPTIONS (object);
+
+  if (options->brush) {
+    g_object_unref(options->brush);
+    options->brush = NULL;
+  }
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gimp_mypaint_options_set_property (GObject      *object,
+                                 guint         property_id,
+                                 const GValue *value,
+                                 GParamSpec   *pspec)
+{
+  GimpMypaintOptions* options = GIMP_MYPAINT_OPTIONS (object);
+
+  if (property_id <= PROP_0) {
+    if (options->brush) {
+      GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(options->brush->p);
+      gchar* name = mypaint_brush_settings_index_to_internal_name (property_id - 1);
+      GType type  = mypaint_brush_get_prop_type (name);
+
+      switch (type) {
+      case G_TYPE_DOUBLE:
+        priv->set_base_value (property_id - 1, g_value_get_double (value));
+        break;
+      case G_TYPE_BOOLEAN:
+        priv->set_bool_value (property_id - 1, g_value_get_boolean (value));
+        break;
+      case G_TYPE_STRING:
+//        priv->set_text_value (property_id - 1, g_value_get_string (value));
+        break;
+      }
+    }
+
+  } else {
+    switch (property_id) {
+    case PROP_BRUSH_MODE:
+      options->brush_mode = (GimpMypaintBrushMode)(g_value_get_enum (value));
+      break;
+
+    case PROP_BRUSH_VIEW_TYPE:
+      options->brush_view_type = (GimpViewType)(g_value_get_enum (value));
+      break;
+
+    case PROP_BRUSH_VIEW_SIZE:
+      options->brush_view_size = (GimpViewSize)(g_value_get_int (value));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+  }
+}
+
+static void
+gimp_mypaint_options_get_property (GObject    *object,
+                                 guint       property_id,
+                                 GValue     *value,
+                                 GParamSpec *pspec)
+{
+  GimpMypaintOptions     *options           = GIMP_MYPAINT_OPTIONS (object);
+
+  if (property_id <= PROP_0) {
+    if (options->brush) {
+      GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(options->brush->p);
+      gchar* name = mypaint_brush_settings_index_to_internal_name (property_id - 1);
+      GType type  = mypaint_brush_get_prop_type (name);
+      switch (type) {
+      case G_TYPE_DOUBLE: {
+        float fval = priv->get_base_value (property_id - 1);
+        g_value_set_double (value, fval);
+        break;
+      }
+      case G_TYPE_BOOLEAN: {
+        bool bval = priv->get_bool_value (property_id - 1);
+        g_value_set_boolean (value, bval);
+        break;
+      }
+      case G_TYPE_STRING:
+        break;
+      }
+    }
+
+  } else {
+    switch (property_id) {
+    case PROP_BRUSH_MODE:
+      g_value_set_enum (value, options->brush_mode);
+      break;
+
+    case PROP_BRUSH_VIEW_TYPE:
+      g_value_set_enum (value, options->brush_view_type);
+      break;
+
+    case PROP_BRUSH_VIEW_SIZE:
+      g_value_set_int (value, options->brush_view_size);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+  }
+}
+
+
+GimpMypaintOptions *
+gimp_mypaint_options_new (GimpToolInfo *tool_info)
+{
+  GimpMypaintOptions *options;
+
+  options = GIMP_MYPAINT_OPTIONS (g_object_new (GIMP_TYPE_MYPAINT_OPTIONS,
+                          "gimp",       tool_info->gimp,
+                          "name",       "Mypaint",
+                          NULL));
+
+  return options;
+}
+
+GimpMypaintBrushMode
+gimp_mypaint_options_get_brush_mode (GimpMypaintOptions *mypaint_options)
+{
+  GimpDynamics       *dynamics;
+  GimpDynamicsOutput *force_output;
+
+  g_return_val_if_fail (GIMP_IS_MYPAINT_OPTIONS (mypaint_options), GIMP_MYPAINT_NORMAL);
+
+  return GIMP_MYPAINT_NORMAL;
+}
+
+void
+gimp_mypaint_options_copy_brush_props (GimpMypaintOptions *src,
+                                     GimpMypaintOptions *dest)
+{
+  gdouble  brush_size;
+  gdouble  brush_angle;
+  gdouble  brush_aspect_ratio;
+
+  g_return_if_fail (GIMP_IS_MYPAINT_OPTIONS (src));
+  g_return_if_fail (GIMP_IS_MYPAINT_OPTIONS (dest));
+
+  g_object_get (src,
+                "brush-size", &brush_size,
+                "brush-angle", &brush_angle,
+                "brush-aspect-ratio", &brush_aspect_ratio,
+                NULL);
+
+  g_object_set (dest,
+                "brush-size", brush_size,
+                "brush-angle", brush_angle,
+                "brush-aspect-ratio", brush_aspect_ratio,
+                NULL);
+}
+
+static void    
+gimp_mypaint_options_mypaint_brush_changed (GObject *object,
+                                            GimpData *data)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_OPTIONS (object));
+  g_return_if_fail (GIMP_IS_MYPAINT_BRUSH (data));
+
+  g_print("GimpMpaintOptions::brush_changed\n");
+  GimpMypaintOptions* options = GIMP_MYPAINT_OPTIONS(object);
+  GimpData* brush_copied = gimp_mypaint_brush_duplicate(GIMP_MYPAINT_BRUSH(data));
+
+  if (options->brush) {
+    GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(options->brush->p);
+    if (priv && priv->is_dirty()) {
+      GimpMypaintOptionsHistory* history;
+      history = GimpMypaintOptionsHistory::get_singleton();
+      history->push_brush(options->brush);
+    } else
+      g_object_unref(options->brush);
+  }
+
+  options->brush = GIMP_MYPAINT_BRUSH(brush_copied);
+  GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(options->brush->p);
+  priv->clear_dirty_flag();
+  
+  GListHolder brush_settings = mypaint_brush_get_brush_settings ();
+  
+  for (GList* i = brush_settings.ptr(); i; i = i->next) {
+    MyPaintBrushSettings* setting = reinterpret_cast<MyPaintBrushSettings*>(i->data);
+    gchar* signal = mypaint_brush_internal_name_to_signal_name(setting->internal_name);
+    g_object_notify(object, signal);
+    g_free(signal);
+  }
+}
+
+
+GimpMypaintBrush*
+gimp_mypaint_options_get_current_brush (GimpMypaintOptions* options) 
+{
+  return options->brush;
+}
+
+void
+gimp_mypaint_options_set_mapping_point(GimpMypaintOptions* options, 
+                                       gchar* prop_name,
+                                       guint inputs,
+                                       guint size, 
+                                       GimpVector2* points)
+{
+  GHashTableHolder<gchar*, MyPaintBrushSettings*> brush_settings_dict = mypaint_brush_get_brush_settings_dict ();
+  StringHolder     brush_setting_name  = mypaint_brush_signal_name_to_internal_name(prop_name);
+
+  MyPaintBrushSettings* brush_setting = brush_settings_dict[brush_setting_name];
+
+  if (options->brush) {
+    GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(options->brush->p);
+    GimpMypaintBrushPrivate::Value* setting = priv->get_setting(brush_setting->index);
+
+    if (setting && setting->mapping) {
+      Mapping* mapping = setting->mapping;
+      mapping->set_n(inputs, size);
+
+      for (int i = 0; i < size; i ++)
+        mapping->set_point(inputs, i, points[i].x, points[i].y);
+
+    }
+
+    priv->mark_as_dirty();
+
+    g_object_notify(G_OBJECT(options), prop_name);
+  }
+}
+
+
+void
+gimp_mypaint_options_get_mapping_point(GimpMypaintOptions* options, 
+                                       gchar*              prop_name,
+                                       guint               inputs,
+                                       guint*              size, 
+                                       GimpVector2**       points)
+{
+  float x, y;
+  GHashTableHolder<gchar*, MyPaintBrushSettings*> brush_settings_dict = mypaint_brush_get_brush_settings_dict ();
+  StringHolder     brush_setting_name  = mypaint_brush_signal_name_to_internal_name(prop_name);
+
+  MyPaintBrushSettings* brush_setting = brush_settings_dict[brush_setting_name];
+  
+  *size = 0;
+  
+  if (options->brush) {
+    GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(options->brush->p);
+    GimpMypaintBrushPrivate::Value* setting = priv->get_setting(brush_setting->index);
+    
+    if (setting && setting->mapping) {
+      Mapping* mapping = setting->mapping;
+      *size = mapping->get_n(inputs);
+
+      *points = g_new0(GimpVector2, *size);
+  
+      for (int i = 0; i < *size; i++) {
+        mapping->get_point(inputs, i, &x, &y);
+        (*points)[i].x = x;
+        (*points)[i].y = y;
+      }
+  
+    }
+  }
+}
+
+};
diff -Naur gimp-2.8.14/app/paint/gimpmypaintoptions.h gimp-2.8.14-new/app/paint/gimpmypaintoptions.h
--- gimp-2.8.14/app/paint/gimpmypaintoptions.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintoptions.h	2015-01-27 17:48:55.356751581 +0800
@@ -0,0 +1,95 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_OPTIONS_H__
+#define __GIMP_MYPAINT_OPTIONS_H__
+
+
+#include "core/gimptooloptions.h"
+
+
+#define GIMP_MYPAINT_OPTIONS_CONTEXT_MASK GIMP_CONTEXT_FOREGROUND_MASK  | \
+                                        GIMP_CONTEXT_BACKGROUND_MASK    | \
+                                        GIMP_CONTEXT_OPACITY_MASK       | \
+                                        GIMP_CONTEXT_BRUSH_MASK         | \
+                                        GIMP_CONTEXT_MYPAINT_MODE_MASK  | \
+                                        GIMP_CONTEXT_MYPAINT_BRUSH_MASK | \
+                                        GIMP_CONTEXT_PATTERN_MASK       |\
+                                        GIMP_CONTEXT_DYNAMICS_MASK
+
+#define GIMP_TYPE_MYPAINT_OPTIONS            (gimp_mypaint_options_get_type ())
+#define GIMP_MYPAINT_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MYPAINT_OPTIONS, GimpMypaintOptions))
+#define GIMP_MYPAINT_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MYPAINT_OPTIONS, GimpMypaintOptionsClass))
+#define GIMP_IS_MYPAINT_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MYPAINT_OPTIONS))
+#define GIMP_IS_MYPAINT_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MYPAINT_OPTIONS))
+#define GIMP_MYPAINT_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MYPAINT_OPTIONS, GimpMypaintOptionsClass))
+
+
+typedef struct _GimpMypaintOptionsClass GimpMypaintOptionsClass;
+
+struct _GimpMypaintOptions
+{
+  GimpToolOptions           parent_instance;
+/*
+  GimpMypaintInfo            *mypaint_info;
+*/
+  gdouble                   brush_size;
+  gdouble                   brush_angle;
+  gdouble                   brush_aspect_ratio;
+
+  GimpMypaintBrushMode      brush_mode;
+  GimpMypaintBrush         *brush;
+
+  GimpViewType              brush_view_type;
+  GimpViewSize              brush_view_size;
+};
+
+struct _GimpMypaintOptionsClass
+{
+  GimpToolOptionsClass  parent_instance;
+};
+
+
+GType              gimp_mypaint_options_get_type (void) G_GNUC_CONST;
+
+//GimpMypaintOptions * gimp_mypaint_options_new      (GimpMypaintInfo    *mypaint_info);
+GimpMypaintOptions * gimp_mypaint_options_new      (GimpToolInfo    *tool_info);
+
+GimpMypaintBrushMode
+gimp_mypaint_options_get_brush_mode (GimpMypaintOptions *mypaint_options);
+
+GimpMypaintBrush*
+gimp_mypaint_options_get_current_brush (GimpMypaintOptions* options);
+
+void    gimp_mypaint_options_copy_brush_props    (GimpMypaintOptions *src,
+                                                GimpMypaintOptions *dest);
+
+void
+gimp_mypaint_options_set_mapping_point(GimpMypaintOptions* options, 
+                                       gchar* prop_name,
+                                       guint inputs,
+                                       guint size, 
+                                       GimpVector2* points);
+
+void
+gimp_mypaint_options_get_mapping_point(GimpMypaintOptions* options, 
+                                       gchar*              name,
+                                       guint               inputs,
+                                       guint*              size, 
+                                       GimpVector2**       points);
+
+#endif  /*  __GIMP_MYPAINT_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/paint/gimpmypaintoptions-history.cpp gimp-2.8.14-new/app/paint/gimpmypaintoptions-history.cpp
--- gimp-2.8.14/app/paint/gimpmypaintoptions-history.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintoptions-history.cpp	2015-01-27 17:48:55.354751581 +0800
@@ -0,0 +1,97 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern "C" {
+#include "config.h"
+
+#include <glib.h>
+#include <gegl.h>
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpmath/gimpmath.h"
+#include "libgimpconfig/gimpconfig.h"
+
+#include "core/core-types.h"
+#include "paint-types.h"
+
+#include "core/gimp.h"
+#include "core/gimpimage.h"
+#include "core/gimptoolinfo.h"
+#include "core/gimpmypaintbrush.h"
+#include "core/mypaintbrush-enum-settings.h"
+#include "core/mypaintbrush-brushsettings.h"
+
+#include "gimp-intl.h"
+}; // extern "C"
+
+extern "C++" {
+#include "core/gimpmypaintbrush-private.hpp"
+#include "base/scopeguard.hpp"
+#include "base/glib-cxx-utils.hpp"
+#include "gimpmypaintoptions-history.hpp"
+
+static GimpMypaintOptionsHistory* instance = NULL;
+static void free_brush(GimpMypaintBrush* brush);
+
+  
+GimpMypaintOptionsHistory::GimpMypaintOptionsHistory() : brushes(NULL)
+{
+}
+
+GimpMypaintOptionsHistory::~GimpMypaintOptionsHistory()
+{
+  if (brushes)
+    g_list_free_full(brushes, GDestroyNotify(free_brush));
+}
+
+void
+GimpMypaintOptionsHistory::push_brush(GimpMypaintBrush* brush)
+{
+  brushes = g_list_append(brushes, brush);
+  g_print("Add custom brush to the history: %s\n", gimp_data_get_filename(GIMP_DATA(brush)) );
+  gimp_data_save(GIMP_DATA(brush), NULL);
+}
+
+GimpMypaintBrush* 
+GimpMypaintOptionsHistory::get_brush(int index)
+{
+  GList* item = g_list_nth(brushes, index);
+  return item? GIMP_MYPAINT_BRUSH(item->data) : NULL;
+}
+
+int 
+GimpMypaintOptionsHistory::get_brush_history_size()
+{
+  return g_list_length(brushes);
+}
+
+GimpMypaintOptionsHistory* 
+GimpMypaintOptionsHistory::get_singleton()
+{
+  if (!instance) {
+    instance = new GimpMypaintOptionsHistory();
+  }
+  return instance;
+}
+
+static void
+free_brush (GimpMypaintBrush* brush)
+{
+  g_object_unref (brush);
+}
+
+}; // extern "C++"
\ No newline at end of file
diff -Naur gimp-2.8.14/app/paint/gimpmypaintoptions-history.hpp gimp-2.8.14-new/app/paint/gimpmypaintoptions-history.hpp
--- gimp-2.8.14/app/paint/gimpmypaintoptions-history.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/gimpmypaintoptions-history.hpp	2015-01-27 17:48:55.354751581 +0800
@@ -0,0 +1,34 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_OPTIONS_HISTORY_HPP__
+#define __GIMP_MYPAINT_OPTIONS_HISTORY_HPP__
+
+class GimpMypaintOptionsHistory {
+private:
+  GList* brushes;
+public:
+  GimpMypaintOptionsHistory();
+  ~GimpMypaintOptionsHistory();
+  void push_brush(GimpMypaintBrush* brush);
+  GimpMypaintBrush* get_brush(int index);
+  int get_brush_history_size();
+
+  static GimpMypaintOptionsHistory* get_singleton();
+};
+
+#endif
diff -Naur gimp-2.8.14/app/paint/gimppaintcore.c gimp-2.8.14-new/app/paint/gimppaintcore.c
--- gimp-2.8.14/app/paint/gimppaintcore.c	2015-01-27 17:28:36.793833815 +0800
+++ gimp-2.8.14-new/app/paint/gimppaintcore.c	2015-01-27 17:48:55.356751581 +0800
@@ -359,7 +359,7 @@
   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
 
   item = GIMP_ITEM (drawable);
-
+  
   if (core->stroke_buffer)
     {
       g_array_free (core->stroke_buffer, TRUE);
@@ -439,7 +439,7 @@
   g_return_if_fail (GIMP_IS_PAINT_CORE (core));
   g_return_if_fail (GIMP_IS_DRAWABLE (drawable));
   g_return_if_fail (gimp_item_is_attached (GIMP_ITEM (drawable)));
-
+  
   if (core->stroke_buffer)
     {
       g_array_free (core->stroke_buffer, TRUE);
diff -Naur gimp-2.8.14/app/paint/gimppaintcore.h gimp-2.8.14-new/app/paint/gimppaintcore.h
--- gimp-2.8.14/app/paint/gimppaintcore.h	2015-01-27 17:28:36.788833816 +0800
+++ gimp-2.8.14-new/app/paint/gimppaintcore.h	2015-01-27 17:48:55.357751581 +0800
@@ -20,6 +20,7 @@
 
 
 #include "core/gimpobject.h"
+#include "gimppaintoptions.h" /* GimpCircularQueue */
 
 
 #define GIMP_TYPE_PAINT_CORE            (gimp_paint_core_get_type ())
diff -Naur gimp-2.8.14/app/paint/gimppaintoptions.c gimp-2.8.14-new/app/paint/gimppaintoptions.c
--- gimp-2.8.14/app/paint/gimppaintoptions.c	2015-01-27 17:28:36.794833815 +0800
+++ gimp-2.8.14-new/app/paint/gimppaintoptions.c	2015-01-27 17:48:55.357751581 +0800
@@ -37,6 +37,54 @@
 
 #include "gimp-intl.h"
 
+GimpCircularQueue* gimp_circular_queue_new(guint element_size, guint queue_size)
+{
+  GimpCircularQueue* queue = g_new0(GimpCircularQueue, 1);
+  queue->data = g_malloc0(element_size * queue_size);
+  if (queue->data) {
+    queue->element_size = element_size;
+    queue->queue_size = queue_size;
+  }
+  queue->start = 0;
+  queue->end = 0;
+  return queue;
+}
+
+void gimp_circular_queue_free(GimpCircularQueue* queue)
+{
+  if (queue) {
+    if (queue->data)
+      g_free(queue->data);
+    g_free(queue);
+  }
+}
+
+void gimp_circular_queue_enqueue_data(GimpCircularQueue* queue, gpointer data)
+{
+  guint index = queue->end % queue->queue_size;
+
+  if (index > queue->start && index == queue->start % queue->queue_size)
+    queue->start ++;
+    
+  index *= queue->element_size;
+  g_memmove((guchar*)queue->data + index, data, queue->element_size);
+  queue->end ++;
+}
+
+gpointer gimp_circular_queue_get_nth_offset(GimpCircularQueue* queue, guint index)
+{
+  index = (queue->start + index) % queue->queue_size;
+  index *= queue->element_size;
+  return (guchar*)queue->data + index;
+}
+
+gpointer gimp_circular_queue_get_last_offset(GimpCircularQueue* queue)
+{
+  gint index = (queue->end - 1) % queue->queue_size;
+  index *= queue->element_size;
+  return (guchar*)queue->data + index;
+}
+
 
 #define DEFAULT_BRUSH_SIZE             20.0
 #define DEFAULT_BRUSH_ASPECT_RATIO     0.0
@@ -103,7 +151,9 @@
 
   PROP_USE_SMOOTHING,
   PROP_SMOOTHING_QUALITY,
-  PROP_SMOOTHING_FACTOR
+  PROP_SMOOTHING_FACTOR,
+  
+  PROP_USE_TEXTURE
 };
 
 
@@ -268,6 +318,10 @@
                                     * less than velcoty results in numeric
                                     * instablility */
                                    GIMP_PARAM_STATIC_STRINGS);
+  GIMP_CONFIG_INSTALL_PROP_BOOLEAN (object_class, PROP_USE_TEXTURE,
+                                    "use-texture", NULL,
+                                    FALSE,
+                                    GIMP_PARAM_STATIC_STRINGS);
 }
 
 static void
@@ -279,6 +333,7 @@
   options->fade_options      = g_slice_new0 (GimpFadeOptions);
   options->gradient_options  = g_slice_new0 (GimpGradientOptions);
   options->smoothing_options = g_slice_new0 (GimpSmoothingOptions);
+  options->texture_options   = g_slice_new0 (GimpTextureOptions);
 }
 
 static void
@@ -319,6 +374,7 @@
   GimpJitterOptions   *jitter_options     = options->jitter_options;
   GimpGradientOptions *gradient_options   = options->gradient_options;
   GimpSmoothingOptions *smoothing_options = options->smoothing_options;
+  GimpTextureOptions   *texture_options   = options->texture_options;
 
   switch (property_id)
     {
@@ -422,6 +478,10 @@
       smoothing_options->smoothing_factor = g_value_get_double (value);
       break;
 
+    case PROP_USE_TEXTURE:
+      texture_options->use_texture = g_value_get_boolean (value);
+      break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -439,6 +499,7 @@
   GimpJitterOptions    *jitter_options    = options->jitter_options;
   GimpGradientOptions  *gradient_options  = options->gradient_options;
   GimpSmoothingOptions *smoothing_options = options->smoothing_options;
+  GimpTextureOptions   *texture_options   = options->texture_options;
 
   switch (property_id)
     {
@@ -529,7 +590,7 @@
     case PROP_GRADIENT_VIEW_SIZE:
       g_value_set_int (value, options->gradient_view_size);
       break;
-
+    
     case PROP_USE_SMOOTHING:
       g_value_set_boolean (value, smoothing_options->use_smoothing);
       break;
@@ -542,6 +603,10 @@
       g_value_set_double (value, smoothing_options->smoothing_factor);
       break;
 
+    case PROP_USE_TEXTURE:
+      g_value_set_boolean (value, texture_options->use_texture);
+      break;
+
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
diff -Naur gimp-2.8.14/app/paint/gimppaintoptions.h gimp-2.8.14-new/app/paint/gimppaintoptions.h
--- gimp-2.8.14/app/paint/gimppaintoptions.h	2015-01-27 17:28:36.797833815 +0800
+++ gimp-2.8.14-new/app/paint/gimppaintoptions.h	2015-01-27 17:48:55.358751581 +0800
@@ -30,11 +30,31 @@
                                         GIMP_CONTEXT_DYNAMICS_MASK   | \
                                         GIMP_CONTEXT_PALETTE_MASK
 
+typedef struct _GimpCircularQueue   GimpCircularQueue;
+struct _GimpCircularQueue
+{
+  guint    element_size;
+  guint    queue_size;
+  guint    start;
+  guint    end;
+  gpointer data;
+};
+GimpCircularQueue* gimp_circular_queue_new(guint element_size, guint queue_size);
+void gimp_circular_queue_free(GimpCircularQueue* queue);
+void gimp_circular_queue_enqueue_data(GimpCircularQueue* queue, gpointer data);
+gpointer gimp_circular_queue_get_nth_offset(GimpCircularQueue* queue, guint index);
+gpointer gimp_circular_queue_get_last_offset(GimpCircularQueue* queue);
+#define gimp_circular_queue_length(q) ((q)->end - (q)->start)
+#define gimp_circular_queue_enqueue(q, a) gimp_circular_queue_enqueue_data(q, (void*)(&(a)))
+#define gimp_circular_queue_index(q, type, i) (*(type*)gimp_circular_queue_get_nth_offset(q, i))
+#define gimp_circular_queue_last(q, type) (*(type*)gimp_circular_queue_get_last_offset(q))
+
 
 typedef struct _GimpJitterOptions   GimpJitterOptions;
 typedef struct _GimpFadeOptions     GimpFadeOptions;
 typedef struct _GimpGradientOptions GimpGradientOptions;
 typedef struct _GimpSmoothingOptions GimpSmoothingOptions;
+typedef struct _GimpTextureOptions  GimpTextureOptions;
 
 struct _GimpJitterOptions
 {
@@ -63,6 +83,10 @@
   gdouble  smoothing_factor;
 };
 
+struct _GimpTextureOptions
+{
+  gboolean use_texture;
+};
 
 #define GIMP_TYPE_PAINT_OPTIONS            (gimp_paint_options_get_type ())
 #define GIMP_PAINT_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PAINT_OPTIONS, GimpPaintOptions))
@@ -95,6 +119,7 @@
   GimpFadeOptions          *fade_options;
   GimpGradientOptions      *gradient_options;
   GimpSmoothingOptions     *smoothing_options;
+  GimpTextureOptions       *texture_options;
 
   GimpViewType              brush_view_type;
   GimpViewSize              brush_view_size;
@@ -129,6 +154,10 @@
                                                 gdouble           pixel_dist,
                                                 GimpRGB          *color);
 
+GimpCoords gimp_paint_options_get_smoothed_coords (GimpPaintOptions  *paint_options,
+                                                   const GimpCoords *original_coords,
+                                                   GimpCircularQueue *history);
+
 GimpBrushApplicationMode
              gimp_paint_options_get_brush_mode (GimpPaintOptions *paint_options);
 
diff -Naur gimp-2.8.14/app/paint/gimpsmudge.c gimp-2.8.14-new/app/paint/gimpsmudge.c
--- gimp-2.8.14/app/paint/gimpsmudge.c	2015-01-27 17:28:36.786833816 +0800
+++ gimp-2.8.14-new/app/paint/gimpsmudge.c	2015-01-27 17:48:55.358751581 +0800
@@ -59,6 +59,14 @@
                                             GimpPaintOptions *paint_options,
                                             const GimpCoords *coords);
 
+static void       gimp_smudge_brush_coords (GimpPaintCore    *paint_core,
+                                            GimpPaintOptions  *options,
+                                            const GimpCoords *coords,
+                                            gint             *x,
+                                            gint             *y,
+                                            gint             *w,
+                                            gint             *h);
+#if 0
 static void       gimp_smudge_accumulator_coords (GimpPaintCore    *paint_core,
                                                   const GimpCoords *coords,
                                                   gint             *x,
@@ -66,6 +74,7 @@
 
 static void       gimp_smudge_accumulator_size   (GimpPaintOptions *paint_options,
                                                   gint             *accumulator_size);
+#endif
 
 
 G_DEFINE_TYPE (GimpSmudge, gimp_smudge, GIMP_TYPE_BRUSH_CORE)
@@ -106,7 +115,10 @@
 {
   smudge->initialized = FALSE;
   smudge->accum_data  = NULL;
+  smudge->blending_data = NULL;
+#if 0
   smudge->accum_size  = 0;
+#endif
 }
 
 static void
@@ -119,8 +131,17 @@
       g_free (smudge->accum_data);
       smudge->accum_data = NULL;
     }
+  
+  if (smudge->blending_data)
+    {
+      g_free (smudge->blending_data);
+      smudge->blending_data = NULL;
+    }
+  
 
+#if 0
   smudge->accum_size = 0;
+#endif
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -153,6 +174,11 @@
           g_free (smudge->accum_data);
           smudge->accum_data = NULL;
         }
+      if (smudge->blending_data)
+        {
+          g_free (smudge->blending_data);
+          smudge->blending_data = NULL;
+        }
       smudge->initialized = FALSE;
       break;
 
@@ -167,20 +193,47 @@
                    GimpPaintOptions *paint_options,
                    const GimpCoords *coords)
 {
+#if 0
+  GimpSmudge        *smudge     = GIMP_SMUDGE (paint_core);
+  GimpImage         *image;
+  TempBuf           *area;
+  PixelRegion        srcPR;
+  gint               bytes;
+  gint               x, y, w, h;
+#endif
   GimpSmudge  *smudge = GIMP_SMUDGE (paint_core);
   TempBuf     *area;
   PixelRegion  srcPR;
   gint         bytes;
+  gint         x, y, w, h;
+  GimpBrushCore *brush_core  = GIMP_BRUSH_CORE (paint_core);        /* gimp-painter-2.7 */
+  GimpSmudgeOptions *options = GIMP_SMUDGE_OPTIONS (paint_options); /* gimp-painter-2.7 */
+#if 0
   gint         x, y;
+#endif
 
   if (gimp_drawable_is_indexed (drawable))
     return FALSE;
 
-  area = gimp_paint_core_get_paint_area (paint_core, drawable, paint_options,
+  brush_core->ignore_scale = TRUE;
+
+  area  = gimp_paint_core_get_paint_area (paint_core, drawable, paint_options,
                                          coords);
   if (! area)
     return FALSE;
 
+  /*  adjust the x and y coordinates to the upper left corner of the brush  */
+  smudge->max_radius = 0;
+  w = h = 0;
+  gimp_smudge_brush_coords (paint_core, paint_options, coords, &x, &y, &w, &h);
+//  g_print ("smudge:start: (x,y,w,h)=%d,%d,%d,%d\n", x, y, w, h);
+
+  /*  Allocate the accumulation buffer */
+  bytes = gimp_drawable_bytes (drawable);
+  smudge->accum_data = g_malloc (w * h * bytes);
+  if (options->use_color_blending)
+    smudge->blending_data = g_malloc (w * h * bytes);
+#if 0
   gimp_smudge_accumulator_size(paint_options, &smudge->accum_size);
 
   /*  adjust the x and y coordinates to the upper left corner of the
@@ -191,14 +244,15 @@
   /*  Allocate the accumulation buffer */
   bytes = gimp_drawable_bytes (drawable);
   smudge->accum_data = g_malloc (SQR (smudge->accum_size) * bytes);
+#endif
 
   /*  If clipped, prefill the smudge buffer with the color at the
    *  brush position.
    */
   if (x != area->x ||
       y != area->y ||
-      smudge->accum_size != area->width ||
-      smudge->accum_size != area->height)
+      w != area->width ||
+      h != area->height)
     {
       guchar fill[4];
 
@@ -212,8 +266,8 @@
                                   fill);
 
       pixel_region_init_data (&srcPR, smudge->accum_data,
-                              bytes, bytes * smudge->accum_size,
-                              0, 0, smudge->accum_size, smudge->accum_size);
+                              bytes, bytes * w,
+                              0, 0, w, h);
 
       color_region (&srcPR, fill);
     }
@@ -222,7 +276,7 @@
                      area->x, area->y, area->width, area->height, FALSE);
 
   pixel_region_init_data (&smudge->accumPR, smudge->accum_data,
-                          bytes, bytes * smudge->accum_size,
+                          bytes, bytes * w,
                           area->x - x,
                           area->y - y,
                           area->width,
@@ -232,11 +286,13 @@
   copy_region (&srcPR, &smudge->accumPR);
 
   pixel_region_init_data (&smudge->accumPR, smudge->accum_data,
-                          bytes, bytes * smudge->accum_size,
-                          0,
-                          0,
-                          smudge->accum_size,
-                          smudge->accum_size);
+                          bytes, bytes * w,
+                          area->x - x,
+                          area->y - y,
+                          area->width,
+                          area->height);
+
+  brush_core->ignore_scale = FALSE;
 
   return TRUE;
 }
@@ -254,6 +310,7 @@
   GimpDynamicsOutput *opacity_output;
   GimpDynamicsOutput *rate_output;
   GimpDynamicsOutput *hardness_output;
+  GimpDynamicsOutput *blending_output;
   GimpImage          *image;
   TempBuf            *area;
   PixelRegion         srcPR, destPR, tempPR;
@@ -261,8 +318,10 @@
   gdouble             opacity;
   gdouble             rate;
   gdouble             dynamic_rate;
-  gint                x, y;
+  gint                x, y, w, h;
   gdouble             hardness;
+  TempBuf            *old_canvas_buf = NULL; /* gimp-painter-2.7 */
+  GimpBrushCore      *brush_core = GIMP_BRUSH_CORE (paint_core); /* gimp-painter-2.7 */
 
   if (gimp_drawable_is_indexed (drawable))
     return;
@@ -282,13 +341,21 @@
   if (opacity == 0.0)
     return;
 
+  brush_core->ignore_scale = TRUE;
+
   area = gimp_paint_core_get_paint_area (paint_core, drawable, paint_options,
                                          coords);
   if (! area)
     return;
 
+#if 1
+  /*  Get the unclipped brush coordinates  */
+  gimp_smudge_brush_coords (paint_core, paint_options, coords, &x, &y, &w, &h);
+//  g_print ("smudge:motion: (x,y,w,h)=%d,%d,%d,%d\n", x, y, w, h);
+#else
   /*  Get the unclipped acumulator coordinates  */
   gimp_smudge_accumulator_coords (paint_core, coords, &x, &y);
+#endif
 
   /* srcPR will be the pixels under the current painthit from the drawable */
   pixel_region_init (&srcPR, gimp_drawable_get_tiles (drawable),
@@ -317,7 +384,7 @@
   /* The dest will be the paint area we got above (= canvas_buf) */
   pixel_region_init_temp_buf (&destPR, area,
                               0, 0, area->width, area->height);
-
+ 
   /*  Smudge uses the buffer Accum.
    *  For each successive painthit Accum is built like this
    *    Accum =  rate*Accum  + (1-rate)*I.
@@ -337,11 +404,97 @@
                           area->width,
                           area->height);
 
+  if (options->use_color_blending)
+    {
+      guchar col[MAX_CHANNELS];
+      gdouble blending_rate = 1.0;
+      PixelRegion        blendPR;
+      
+      pixel_region_init_data (&blendPR, smudge->blending_data,
+                              smudge->accumPR.bytes,
+                              smudge->accumPR.rowstride,
+                              area->x - x,
+                              area->y - y,
+                              area->width,
+                              area->height);
+
+      blending_output = gimp_dynamics_get_output (dynamics,
+                                                  GIMP_DYNAMICS_OUTPUT_BLENDING);
+
+      blending_rate *= gimp_dynamics_output_get_linear_value (blending_output,
+                                                              coords,
+                                                              paint_options,
+                                                              fade_point);
+
+      gimp_image_get_foreground (image, context, gimp_drawable_type (drawable), col);
+      col[area->bytes - 1] = OPAQUE_OPACITY;
+      shade_region (&tempPR, &blendPR, col, ROUND (blending_rate * 255.0));
+
+      /* re-initialize the tempPR */
+      pixel_region_init_data (&tempPR, smudge->blending_data,
+                              smudge->accumPR.bytes,
+                              smudge->accumPR.rowstride,
+                              area->x - x,
+                              area->y - y,
+                              area->width,
+                              area->height);
+    }
+
   if (! gimp_drawable_has_alpha (drawable))
     add_alpha_region (&tempPR, &destPR);
   else
     copy_region (&tempPR, &destPR);
 
+  brush_core->ignore_scale = FALSE;
+
+  {
+    gint brush_width,brush_height;
+    gint x, y;
+    gint x1, y1, x2, y2;
+    gint drawable_width, drawable_height;
+    
+    gimp_brush_core_eval_transform_dynamics (brush_core,
+                                             drawable,
+                                             paint_options,
+                                             coords);
+    /* FIXME: following code is simply copied from gimp_brush_core_clamp_scale */
+    {
+      TempBuf *mask = brush_core->main_brush->mask;
+
+      /* ensure that the final brush mask remains >= 0.5 pixel along both axes */
+      brush_core->scale = MAX (0.5 / (gfloat) MIN (mask->width, mask->height), brush_core->scale);
+    }
+
+    gimp_brush_transform_size (brush_core->brush,
+                               brush_core->scale, brush_core->aspect_ratio, brush_core->angle,
+                               &brush_width, &brush_height);
+
+    /*  adjust the x and y coordinates to the upper left corner of the brush  */
+    x = (gint) floor (coords->x) - (brush_width  / 2);
+    y = (gint) floor (coords->y) - (brush_height / 2);
+
+    drawable_width  = gimp_item_get_width  (GIMP_ITEM (drawable));
+    drawable_height = gimp_item_get_height (GIMP_ITEM (drawable));
+
+    x1 = CLAMP (x - 1, 0, drawable_width);
+    y1 = CLAMP (y - 1, 0, drawable_height);
+    x2 = CLAMP (x + brush_width  + 1, 0, drawable_width);
+    y2 = CLAMP (y + brush_height + 1, 0, drawable_height);
+
+    /*  configure the canvas buffer  */
+    if ((x2 - x1) && (y2 - y1))
+      {
+        gint bytes;
+
+        bytes = gimp_drawable_bytes_with_alpha (drawable);
+
+        old_canvas_buf         = paint_core->canvas_buf;
+        paint_core->canvas_buf = temp_buf_subwindow (paint_core->canvas_buf,
+                                                     x1, y1,
+                                                     (x2 - x1), (y2 - y1));
+      }
+  }
+  
   hardness_output = gimp_dynamics_get_output (dynamics,
                                               GIMP_DYNAMICS_OUTPUT_HARDNESS);
 
@@ -357,8 +510,51 @@
                                   gimp_paint_options_get_brush_mode (paint_options),
                                   hardness,
                                   GIMP_PAINT_INCREMENTAL);
+  if (old_canvas_buf)
+     paint_core->canvas_buf = old_canvas_buf;
 }
 
+#if 1
+static void
+gimp_smudge_brush_coords (GimpPaintCore    *paint_core,
+                          GimpPaintOptions *paint_options,
+                          const GimpCoords *coords,
+                          gint             *x,
+                          gint             *y,
+                          gint             *w,
+                          gint             *h)
+{
+  GimpBrushCore *brush_core = GIMP_BRUSH_CORE (paint_core);
+  GimpSmudge    *smudge     = GIMP_SMUDGE (paint_core);
+  gint           width = 0;
+  gint           height = 0;
+
+  if (smudge->max_radius == 0)
+    {
+      if (brush_core->main_brush)
+        brush_core->scale = paint_options->brush_size /
+                            MAX (brush_core->main_brush->mask->width,
+                                 brush_core->main_brush->mask->height);
+      else
+        brush_core->scale = -1;
+
+      gimp_brush_transform_size (brush_core->brush,
+                                 brush_core->scale,
+                                 brush_core->aspect_ratio,
+                                 brush_core->angle,
+                                 &width, &height);
+      smudge->max_radius = ceil(sqrt(width * width + height * height));
+    }
+
+  width = height = (gint)smudge->max_radius;
+
+  /* Note: these are the brush mask size plus a border of 1 pixel */
+  *x = (gint) coords->x - width  / 2 - 1;
+  *y = (gint) coords->y - height / 2 - 1;
+  *w = width  + 2;
+  *h = height + 2;
+}
+#else
 static void
 gimp_smudge_accumulator_coords (GimpPaintCore    *paint_core,
                                 const GimpCoords *coords,
@@ -380,3 +576,4 @@
    * headroom */
   *accumulator_size = ceil (sqrt (2 * SQR (paint_options->brush_size + 1)) + 2);
 }
+#endif
diff -Naur gimp-2.8.14/app/paint/gimpsmudge.h gimp-2.8.14-new/app/paint/gimpsmudge.h
--- gimp-2.8.14/app/paint/gimpsmudge.h	2015-01-27 17:28:36.792833816 +0800
+++ gimp-2.8.14-new/app/paint/gimpsmudge.h	2015-01-27 17:48:55.359751581 +0800
@@ -41,7 +41,11 @@
   gboolean       initialized;
   PixelRegion    accumPR;
   guchar        *accum_data;
+  guchar        *blending_data;
+  guint          max_radius;
+#if 0
   gint           accum_size;
+#endif
 };
 
 struct _GimpSmudgeClass
diff -Naur gimp-2.8.14/app/paint/gimpsmudgeoptions.c gimp-2.8.14-new/app/paint/gimpsmudgeoptions.c
--- gimp-2.8.14/app/paint/gimpsmudgeoptions.c	2015-01-27 17:28:36.784833816 +0800
+++ gimp-2.8.14-new/app/paint/gimpsmudgeoptions.c	2015-01-27 17:48:55.359751581 +0800
@@ -27,12 +27,14 @@
 
 
 #define SMUDGE_DEFAULT_RATE 50.0
+#define DEFAULT_USE_COLOR_BLENDING FALSE
 
 
 enum
 {
   PROP_0,
-  PROP_RATE
+  PROP_RATE,
+  PROP_USE_COLOR_BLENDING
 };
 
 
@@ -62,6 +64,11 @@
                                    "rate", NULL,
                                    0.0, 100.0, SMUDGE_DEFAULT_RATE,
                                    GIMP_PARAM_STATIC_STRINGS);
+                                   
+  GIMP_CONFIG_INSTALL_PROP_BOOLEAN (object_class, PROP_USE_COLOR_BLENDING,
+                                    "use-color-blending", NULL,
+                                    DEFAULT_USE_COLOR_BLENDING,
+                                    GIMP_PARAM_STATIC_STRINGS);
 }
 
 static void
@@ -82,6 +89,11 @@
     case PROP_RATE:
       options->rate = g_value_get_double (value);
       break;
+      
+    case PROP_USE_COLOR_BLENDING:
+      options->use_color_blending = g_value_get_boolean (value);
+      break;
+    
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -101,6 +113,11 @@
     case PROP_RATE:
       g_value_set_double (value, options->rate);
       break;
+ 
+    case PROP_USE_COLOR_BLENDING:
+      g_value_set_boolean (value, options->use_color_blending);
+      break;
+ 
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
diff -Naur gimp-2.8.14/app/paint/gimpsmudgeoptions.h gimp-2.8.14-new/app/paint/gimpsmudgeoptions.h
--- gimp-2.8.14/app/paint/gimpsmudgeoptions.h	2015-01-27 17:28:36.795833815 +0800
+++ gimp-2.8.14-new/app/paint/gimpsmudgeoptions.h	2015-01-27 17:48:55.359751581 +0800
@@ -37,6 +37,7 @@
   GimpPaintOptions  parent_instance;
 
   gdouble           rate;
+  gboolean          use_color_blending;
 };
 
 struct _GimpSmudgeOptionsClass
diff -Naur gimp-2.8.14/app/paint/Makefile.am gimp-2.8.14-new/app/paint/Makefile.am
--- gimp-2.8.14/app/paint/Makefile.am	2015-01-27 17:28:36.783833816 +0800
+++ gimp-2.8.14-new/app/paint/Makefile.am	2015-01-27 17:48:55.348751581 +0800
@@ -55,12 +55,26 @@
 	gimpinkundo.h			\
 	gimppaintcore.c			\
 	gimppaintcore.h			\
+	gimpmypaintcore.cpp		\
+	gimpmypaintcore.hpp		\
+	gimpmypaintcoreundo.cpp		\
+	gimpmypaintcoreundo.h		\
+	gimpmypaintcore-surface.cpp		\
+	gimpmypaintcore-surface.hpp		\
 	gimppaintcore-stroke.c		\
 	gimppaintcore-stroke.h		\
 	gimppaintcoreundo.c		\
 	gimppaintcoreundo.h		\
 	gimppaintoptions.c		\
 	gimppaintoptions.h		\
+	gimpmypaintoptions.cpp		\
+	gimpmypaintoptions.h		\
+	gimpmypaintoptions-history.cpp	\
+	gimpmypaintoptions-history.hpp	\
+	mypaintbrush-brush.hpp		\
+	mypaintbrush-surface.hpp		\
+	mypaintbrush-stroke.hpp		\
+	mypaintbrush-stroke.cpp		\
 	gimppencil.c			\
 	gimppencil.h			\
 	gimppenciloptions.c		\
diff -Naur gimp-2.8.14/app/paint/mypaintbrush-brush.hpp gimp-2.8.14-new/app/paint/mypaintbrush-brush.hpp
--- gimp-2.8.14/app/paint/mypaintbrush-brush.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/mypaintbrush-brush.hpp	2015-01-27 17:48:55.360751581 +0800
@@ -0,0 +1,925 @@
+/* brushlib - The MyPaint Brush Library
+ * Copyright (C) 2007-2011 Martin Renold <martinxyz@gmx.ch>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __MYPAINT_BRUSH_HPP__
+#define __MYPAINT_BRUSH_HPP__
+
+#include <stdio.h>
+#include <string.h>
+#include <glib.h>
+#include <math.h>
+#include <stdlib.h>
+extern "C" {
+#include "libgimpcolor/gimpcolor.h"
+};
+
+/* #include "Python.h" */
+
+#include "core/mypaintbrush-brushsettings.h"
+#include "core/mypaintbrush-enum-settings.h"
+#include "core/mypaintbrush-mapping.hpp"
+
+///
+/// Helper functions
+///
+
+#define assert(x) g_assert(x)
+
+// Optimized version from one in GIMP (noisify.c), where it was
+// adapted from ppmforge.c, which is part of PBMPLUS. The algorithm
+// comes from: 'The Science Of Fractal Images'. Peitgen, H.-O., and
+// Saupe, D. eds.  Springer Verlag, New York, 1988.
+inline float rand_gauss (GRand * rng)
+{
+  float sum = 0.0;
+  gint32 rand1 = g_rand_int(rng);
+  gint32 rand2 = g_rand_int(rng);
+  sum +=  rand1        & 0x7FFF;
+  sum += (rand1 >> 16) & 0x7FFF;
+  sum +=  rand2        & 0x7FFF;
+  sum += (rand2 >> 16) & 0x7FFF;
+  return sum * 5.28596089837e-5 - 3.46410161514;
+}
+
+inline void
+rgb_to_hsv_float (float *r_ /*h*/, float *g_ /*s*/, float *b_ /*v*/)
+{
+  GimpRGB rgb;
+  GimpHSV hsv;
+  rgb.r = *r_;
+  rgb.g = *g_;
+  rgb.b = *b_;
+  gimp_rgb_to_hsv(&rgb, &hsv);
+  *r_ = hsv.h;
+  *g_ = hsv.s;
+  *b_ = hsv.v;
+}
+
+inline void
+hsv_to_rgb_float (float *h_, float *s_, float *v_)
+{
+  GimpRGB rgb;
+  GimpHSV hsv;
+  hsv.h = *h_;
+  hsv.s = *s_;
+  hsv.v = *v_;
+  gimp_hsv_to_rgb(&hsv, &rgb);
+  *h_ = rgb.r;
+  *s_ = rgb.g;
+  *v_ = rgb.b;
+}
+
+inline void
+rgb_to_hsl_float (float *r_ /*h*/, float *g_ /*s*/, float *b_ /*v*/)
+{
+  GimpRGB rgb;
+  GimpHSL hsl;
+  rgb.r = *r_;
+  rgb.g = *g_;
+  rgb.b = *b_;
+  gimp_rgb_to_hsl(&rgb, &hsl);
+  *r_ = hsl.h;
+  *g_ = hsl.s;
+  *b_ = hsl.l;
+}
+
+inline void
+hsl_to_rgb_float (float *h_, float *s_, float *v_)
+{
+  GimpRGB rgb;
+  GimpHSL hsl;
+  hsl.h = *h_;
+  hsl.s = *s_;
+  hsl.l = *v_;
+  gimp_hsl_to_rgb(&hsl, &rgb);
+  *h_ = rgb.r;
+  *s_ = rgb.g;
+  *v_ = rgb.b;
+}
+
+
+#define ACTUAL_RADIUS_MIN 0.2
+#define ACTUAL_RADIUS_MAX 800 // safety guard against radius like 1e20 and against rendering overload with unexpected brush dynamics
+
+/* The Brush class stores two things:
+   b) settings: constant during a stroke (eg. size, spacing, dynamics, color selected by the user)
+   a) states: modified during a stroke (eg. speed, smudge colors, time/distance to next dab, position filter states)
+
+   FIXME: Actually those are two orthogonal things. Should separate them:
+          a) brush settings class that is saved/loaded/selected  (without states)
+          b) brush core class to draw the dabs (using an instance of the above)
+
+   In python, there are two kinds of instances from this: a "global
+   brush" which does the cursor tracking, and the "brushlist" where
+   the states are ignored. When a brush is selected, its settings are
+   copied into the global one, leaving the state intact.
+ */
+
+
+class Brush {
+public:
+  bool print_inputs; // debug menu
+  // for stroke splitting (undo/redo)
+  double stroke_total_painting_time;
+  double stroke_current_idling_time; 
+
+private:
+  // see also brushsettings.py
+
+  // the states (get_state, set_state, reset) that change during a stroke
+  float states[STATE_COUNT];
+  GRand * rng;
+
+  // Those mappings describe how to calculate the current value for each setting.
+  // Most of settings will be constant (eg. only their base_value is used).
+  Mapping * settings[BRUSH_SETTINGS_COUNT];
+
+  // the current value of all settings (calculated using the current state)
+  float settings_value[BRUSH_SETTINGS_COUNT];
+
+  // cached calculation results
+  float speed_mapping_gamma[2], speed_mapping_m[2], speed_mapping_q[2];
+
+  bool reset_requested;
+
+public:
+  Brush() {
+    for (int i=0; i<BRUSH_SETTINGS_COUNT; i++) {
+      settings[i] = new Mapping(INPUT_COUNT);
+    }
+    rng = g_rand_new();
+    print_inputs = false;
+    
+    for (int i=0; i<STATE_COUNT; i++) {
+      states[i] = 0;
+    }
+    new_stroke();
+
+    settings_base_values_have_changed();
+
+    reset_requested = true;
+  }
+
+  ~Brush() {
+    for (int i=0; i<BRUSH_SETTINGS_COUNT; i++) {
+      delete settings[i];
+    }
+    g_rand_free (rng); rng = NULL;
+  }
+
+  void reset()
+  {
+    reset_requested = true;
+  }
+
+  void new_stroke()
+  {
+    stroke_current_idling_time = 0;
+    stroke_total_painting_time = 0;
+  }
+
+  void set_base_value (int id, float value) {
+    assert (id >= 0 && id < BRUSH_SETTINGS_COUNT);
+    settings[id]->base_value = value;
+
+    settings_base_values_have_changed ();
+  }
+
+  void set_mapping_n (int id, int input, int n) {
+    assert (id >= 0 && id < BRUSH_SETTINGS_COUNT);
+    settings[id]->set_n (input, n);
+  }
+
+  void set_mapping_point (int id, int input, int index, float x, float y) {
+    assert (id >= 0 && id < BRUSH_SETTINGS_COUNT);
+    settings[id]->set_point (input, index, x, y);
+  }
+  
+  void copy_mapping (int id, const Mapping* src) {
+    assert (id >= 0 && id < BRUSH_SETTINGS_COUNT);
+    assert (src != NULL);
+    
+    *(settings[id]) = *src;
+  }
+
+  float get_state (int i)
+  {
+    assert (i >= 0 && i < STATE_COUNT);
+    return states[i];
+  }
+
+  void set_state (int i, float value)
+  {
+    assert (i >= 0 && i < STATE_COUNT);
+    states[i] = value;
+  }
+
+private:
+  // returns the fraction still left after t seconds
+  float exp_decay (float T_const, float t)
+  {
+    // the argument might not make mathematical sense (whatever.)
+    if (T_const <= 0.001) {
+      return 0.0;
+    } else {
+      return exp(- t / T_const);
+    }
+  }
+
+
+  void settings_base_values_have_changed ()
+  {
+    // precalculate stuff that does not change dynamically
+
+    // Precalculate how the physical speed will be mapped to the speed input value.
+    // The forumla for this mapping is:
+    //
+    // y = log(gamma+x)*m + q;
+    //
+    // x: the physical speed (pixels per basic dab radius)
+    // y: the speed input that will be reported
+    // gamma: parameter set by ths user (small means a logarithmic mapping, big linear)
+    // m, q: parameters to scale and translate the curve
+    //
+    // The code below calculates m and q given gamma and two hardcoded constraints.
+    //
+    for (int i=0; i<2; i++) {
+      float gamma;
+      gamma = settings[(i==0)?BRUSH_SPEED1_GAMMA:BRUSH_SPEED2_GAMMA]->base_value;
+      gamma = exp(gamma);
+
+      float fix1_x, fix1_y, fix2_x, fix2_dy;
+      fix1_x = 45.0;
+      fix1_y = 0.5;
+      fix2_x = 45.0;
+      fix2_dy = 0.015;
+
+      float m, q;
+      float c1;
+      c1 = log(fix1_x+gamma);
+      m = fix2_dy * (fix2_x + gamma);
+      q = fix1_y - m*c1;
+    
+      speed_mapping_gamma[i] = gamma;
+      speed_mapping_m[i] = m;
+      speed_mapping_q[i] = q;
+    }
+  }
+
+  // This function runs a brush "simulation" step. Usually it is
+  // called once or twice per dab. In theory the precision of the
+  // "simulation" gets better when it is called more often. In
+  // practice this only matters if there are some highly nonlinear
+  // mappings in critical places or extremely few events per second.
+  //
+  // note: parameters are is dx/ddab, ..., dtime/ddab (dab is the number, 5.0 = 5th dab)
+  void update_states_and_setting_values (float step_dx, float step_dy, float step_dpressure, float step_declination, float step_ascension, float step_dtime)
+  {
+    float pressure;
+    float inputs[INPUT_COUNT];
+
+    if (step_dtime < 0.0) {
+      printf("Time is running backwards!\n");
+      step_dtime = 0.001;
+    } else if (step_dtime == 0.0) {
+      // FIXME: happens about every 10th start, workaround (against division by zero)
+      step_dtime = 0.001;
+    }
+
+    states[STATE_X]        += step_dx;
+    states[STATE_Y]        += step_dy;
+    states[STATE_PRESSURE] += step_dpressure;
+
+    states[STATE_DECLINATION] += step_declination;
+    states[STATE_ASCENSION] += step_ascension;
+
+    float base_radius = expf(settings[BRUSH_RADIUS_LOGARITHMIC]->base_value);
+
+    // FIXME: does happen (interpolation problem?)
+    states[STATE_PRESSURE] = CLAMP(states[STATE_PRESSURE], 0.0, 1.0);
+    pressure = states[STATE_PRESSURE];
+
+    { // start / end stroke (for "stroke" input only)
+      if (!states[STATE_STROKE_STARTED]) {
+        if (pressure > settings[BRUSH_STROKE_THRESHOLD]->base_value + 0.0001) {
+          // start new stroke
+          //printf("stroke start %f\n", pressure);
+          states[STATE_STROKE_STARTED] = 1;
+          states[STATE_STROKE] = 0.0;
+        }
+      } else {
+        if (pressure <= settings[BRUSH_STROKE_THRESHOLD]->base_value * 0.9 + 0.0001) {
+          // end stroke
+          //printf("stroke end\n");
+          states[STATE_STROKE_STARTED] = 0;
+        }
+      }
+    }
+
+    // now follows input handling
+
+    float norm_dx, norm_dy, norm_dist, norm_speed;
+    norm_dx = step_dx / step_dtime / base_radius;
+    norm_dy = step_dy / step_dtime / base_radius;
+    norm_speed = sqrt(SQR(norm_dx) + SQR(norm_dy));
+    norm_dist = norm_speed * step_dtime;
+
+    inputs[INPUT_PRESSURE] = pressure;
+    inputs[INPUT_SPEED1] = log(speed_mapping_gamma[0] + states[STATE_NORM_SPEED1_SLOW])*speed_mapping_m[0] + speed_mapping_q[0];
+    inputs[INPUT_SPEED2] = log(speed_mapping_gamma[1] + states[STATE_NORM_SPEED2_SLOW])*speed_mapping_m[1] + speed_mapping_q[1];
+    inputs[INPUT_RANDOM] = g_rand_double (rng);
+    inputs[INPUT_STROKE] = MIN(states[STATE_STROKE], 1.0);
+    inputs[INPUT_DIRECTION] = fmodf (atan2f (states[STATE_DIRECTION_DY], states[STATE_DIRECTION_DX])/M_PI*180.0 + 360, 360.0);
+    inputs[INPUT_TILT_DECLINATION] = states[STATE_DECLINATION];
+    inputs[INPUT_TILT_ASCENSION] = states[STATE_ASCENSION];
+    inputs[INPUT_CUSTOM] = states[STATE_CUSTOM_INPUT];
+    if (print_inputs) {
+      g_print("press=% 4.3f, speed1=% 4.4f\tspeed2=% 4.4f\tstroke=% 4.3f\tcustom=% 4.3f\n", (double)inputs[INPUT_PRESSURE], (double)inputs[INPUT_SPEED1], (double)inputs[INPUT_SPEED2], (double)inputs[INPUT_STROKE], (double)inputs[INPUT_CUSTOM]);
+    }
+    // FIXME: this one fails!!!
+    //assert(inputs[INPUT_SPEED1] >= 0.0 && inputs[INPUT_SPEED1] < 1e8); // checking for inf
+
+    for (int i=0; i<BRUSH_SETTINGS_COUNT; i++) {
+      settings_value[i] = settings[i]->calculate (inputs);
+    }
+
+    {
+      float fac = 1.0 - exp_decay (settings_value[BRUSH_SLOW_TRACKING_PER_DAB], 1.0);
+      states[STATE_ACTUAL_X] += (states[STATE_X] - states[STATE_ACTUAL_X]) * fac; // FIXME: should this depend on base radius?
+      states[STATE_ACTUAL_Y] += (states[STATE_Y] - states[STATE_ACTUAL_Y]) * fac;
+    }
+
+    { // slow speed
+      float fac;
+      fac = 1.0 - exp_decay (settings_value[BRUSH_SPEED1_SLOWNESS], step_dtime);
+      states[STATE_NORM_SPEED1_SLOW] += (norm_speed - states[STATE_NORM_SPEED1_SLOW]) * fac;
+      fac = 1.0 - exp_decay (settings_value[BRUSH_SPEED2_SLOWNESS], step_dtime);
+      states[STATE_NORM_SPEED2_SLOW] += (norm_speed - states[STATE_NORM_SPEED2_SLOW]) * fac;
+    }
+  
+    { // slow speed, but as vector this time
+
+      // FIXME: offset_by_speed should be removed.
+      //   Is it broken, non-smooth, system-dependent math?!
+      //   A replacement could be a directed random offset.
+
+      float time_constant = exp(settings_value[BRUSH_OFFSET_BY_SPEED_SLOWNESS]*0.01)-1.0;
+      // Workaround for a bug that happens mainly on Windows, causing
+      // individual dabs to be placed far far away. Using the speed
+      // with zero filtering is just asking for trouble anyway.
+      if (time_constant < 0.002) time_constant = 0.002;
+      float fac = 1.0 - exp_decay (time_constant, step_dtime);
+      states[STATE_NORM_DX_SLOW] += (norm_dx - states[STATE_NORM_DX_SLOW]) * fac;
+      states[STATE_NORM_DY_SLOW] += (norm_dy - states[STATE_NORM_DY_SLOW]) * fac;
+    }
+
+    { // orientation (similar lowpass filter as above, but use dabtime instead of wallclock time)
+      float dx = step_dx / base_radius;
+      float dy = step_dy / base_radius;
+      float step_in_dabtime = hypotf(dx, dy); // FIXME: are we recalculating something here that we already have?
+      float fac = 1.0 - exp_decay (exp(settings_value[BRUSH_DIRECTION_FILTER]*0.5)-1.0, step_in_dabtime);
+
+      float dx_old = states[STATE_DIRECTION_DX];
+      float dy_old = states[STATE_DIRECTION_DY];
+      #if 0
+      // gimp-painter-2.7: Disable to use opposite speed vector. We should care about 180 deg. turn
+      // when we use brushmarks...
+      // use the opposite speed vector if it is closer (we don't care about 180 degree turns)
+      if (SQR(dx_old-dx) + SQR(dy_old-dy) > SQR(dx_old-(-dx)) + SQR(dy_old-(-dy))) {
+        dx = -dx;
+        dy = -dy;
+      }
+      #endif
+      states[STATE_DIRECTION_DX] += (dx - states[STATE_DIRECTION_DX]) * fac;
+      states[STATE_DIRECTION_DY] += (dy - states[STATE_DIRECTION_DY]) * fac;
+    }
+
+    { // custom input
+      float fac;
+      fac = 1.0 - exp_decay (settings_value[BRUSH_CUSTOM_INPUT_SLOWNESS], 0.1);
+      states[STATE_CUSTOM_INPUT] += (settings_value[BRUSH_CUSTOM_INPUT] - states[STATE_CUSTOM_INPUT]) * fac;
+    }
+
+    { // stroke length
+      float frequency;
+      float wrap;
+      frequency = expf(-settings_value[BRUSH_STROKE_DURATION_LOGARITHMIC]);
+      states[STATE_STROKE] += norm_dist * frequency;
+      // can happen, probably caused by rounding
+      if (states[STATE_STROKE] < 0) states[STATE_STROKE] = 0;
+      wrap = 1.0 + settings_value[BRUSH_STROKE_HOLDTIME];
+      if (states[STATE_STROKE] > wrap) {
+        if (wrap > 9.9 + 1.0) {
+          // "inifinity", just hold stroke somewhere >= 1.0
+          states[STATE_STROKE] = 1.0;
+        } else {
+          states[STATE_STROKE] = fmodf(states[STATE_STROKE], wrap);
+          // just in case
+          if (states[STATE_STROKE] < 0) states[STATE_STROKE] = 0;
+        }
+      }
+    }
+
+    // calculate final radius
+    float radius_log;
+    radius_log = settings_value[BRUSH_RADIUS_LOGARITHMIC];
+    states[STATE_ACTUAL_RADIUS] = expf(radius_log);
+    if (states[STATE_ACTUAL_RADIUS] < ACTUAL_RADIUS_MIN) states[STATE_ACTUAL_RADIUS] = ACTUAL_RADIUS_MIN;
+    if (states[STATE_ACTUAL_RADIUS] > ACTUAL_RADIUS_MAX) states[STATE_ACTUAL_RADIUS] = ACTUAL_RADIUS_MAX;
+
+    // aspect ratio (needs to be caluclated here because it can affect the dab spacing)
+    states[STATE_ACTUAL_ELLIPTICAL_DAB_RATIO] = settings_value[BRUSH_ELLIPTICAL_DAB_RATIO];
+    states[STATE_ACTUAL_ELLIPTICAL_DAB_ANGLE] = settings_value[BRUSH_ELLIPTICAL_DAB_ANGLE];
+  }
+
+  // Called only from stroke_to(). Calculate everything needed to
+  // draw the dab, then let the surface do the actual drawing.
+  //
+  // This is only gets called right after update_states_and_setting_values().
+  // Returns true if the surface was modified.
+  bool prepare_and_draw_dab (Surface * surface)
+  {
+    float x, y, opaque;
+    float radius;
+
+    // ensure we don't get a positive result with two negative opaque values
+    if (settings_value[BRUSH_OPAQUE] < 0) settings_value[BRUSH_OPAQUE] = 0;
+    opaque = settings_value[BRUSH_OPAQUE] * settings_value[BRUSH_OPAQUE_MULTIPLY];
+    opaque = CLAMP(opaque, 0.0, 1.0);
+    //if (opaque == 0.0) return false; <-- cannot do that, since we need to update smudge state.
+    if (settings_value[BRUSH_OPAQUE_LINEARIZE]) {
+      // OPTIMIZE: no need to recalculate this for each dab
+      float alpha, beta, alpha_dab, beta_dab;
+      float dabs_per_pixel;
+      // dabs_per_pixel is just estimated roughly, I didn't think hard
+      // about the case when the radius changes during the stroke
+      dabs_per_pixel = (
+                        settings[BRUSH_DABS_PER_ACTUAL_RADIUS]->base_value + 
+                        settings[BRUSH_DABS_PER_BASIC_RADIUS]->base_value
+                        ) * 2.0;
+
+      // the correction is probably not wanted if the dabs don't overlap
+      if (dabs_per_pixel < 1.0) dabs_per_pixel = 1.0;
+
+      // interpret the user-setting smoothly
+      dabs_per_pixel = 1.0 + settings[BRUSH_OPAQUE_LINEARIZE]->base_value*(dabs_per_pixel-1.0);
+
+      // see doc/brushdab_saturation.png
+      //      beta = beta_dab^dabs_per_pixel
+      // <==> beta_dab = beta^(1/dabs_per_pixel)
+      alpha = opaque;
+      beta = 1.0-alpha;
+      beta_dab = powf(beta, 1.0/dabs_per_pixel);
+      alpha_dab = 1.0-beta_dab;
+      opaque = alpha_dab;
+    }
+
+    x = states[STATE_ACTUAL_X];
+    y = states[STATE_ACTUAL_Y];
+
+    float base_radius = expf(settings[BRUSH_RADIUS_LOGARITHMIC]->base_value);
+
+    if (settings_value[BRUSH_OFFSET_BY_SPEED]) {
+      x += states[STATE_NORM_DX_SLOW] * settings_value[BRUSH_OFFSET_BY_SPEED] * 0.1 * base_radius;
+      y += states[STATE_NORM_DY_SLOW] * settings_value[BRUSH_OFFSET_BY_SPEED] * 0.1 * base_radius;
+    }
+
+    if (settings_value[BRUSH_OFFSET_BY_RANDOM]) {
+      float amp = settings_value[BRUSH_OFFSET_BY_RANDOM];
+      if (amp < 0.0) amp = 0.0;
+      x += rand_gauss (rng) * amp * base_radius;
+      y += rand_gauss (rng) * amp * base_radius;
+    }
+
+  
+    radius = states[STATE_ACTUAL_RADIUS];
+    if (settings_value[BRUSH_RADIUS_BY_RANDOM]) {
+      float radius_log, alpha_correction;
+      // go back to logarithmic radius to add the noise
+      radius_log  = settings_value[BRUSH_RADIUS_LOGARITHMIC];
+      radius_log += rand_gauss (rng) * settings_value[BRUSH_RADIUS_BY_RANDOM];
+      radius = expf(radius_log);
+      radius = CLAMP(radius, ACTUAL_RADIUS_MIN, ACTUAL_RADIUS_MAX);
+      alpha_correction = states[STATE_ACTUAL_RADIUS] / radius;
+      alpha_correction = SQR(alpha_correction);
+      if (alpha_correction <= 1.0) {
+        opaque *= alpha_correction;
+      }
+    }
+
+    // color part
+
+    float color_h = settings[BRUSH_COLOR_H]->base_value;
+    float color_s = settings[BRUSH_COLOR_S]->base_value;
+    float color_v = settings[BRUSH_COLOR_V]->base_value;
+    float eraser_target_alpha = 1.0;
+    if (settings_value[BRUSH_SMUDGE] > 0.0) {
+      // mix (in RGB) the smudge color with the brush color
+      hsv_to_rgb_float (&color_h, &color_s, &color_v);
+      float fac = settings_value[BRUSH_SMUDGE];
+      if (fac > 1.0) fac = 1.0;
+      // If the smudge color somewhat transparent, then the resulting
+      // dab will do erasing towards that transparency level.
+      // see also ../doc/smudge_math.png
+      eraser_target_alpha = (1-fac)*1.0 + fac*states[STATE_SMUDGE_A];
+      // fix rounding errors (they really seem to happen in the previous line)
+      eraser_target_alpha = CLAMP(eraser_target_alpha, 0.0, 1.0);
+      if (eraser_target_alpha > 0) {
+        color_h = (fac*states[STATE_SMUDGE_RA] + (1-fac)*color_h) / eraser_target_alpha;
+        color_s = (fac*states[STATE_SMUDGE_GA] + (1-fac)*color_s) / eraser_target_alpha;
+        color_v = (fac*states[STATE_SMUDGE_BA] + (1-fac)*color_v) / eraser_target_alpha;
+      } else {
+        // we are only erasing; the color does not matter
+        color_h = 1.0;
+        color_s = 0.0;
+        color_v = 0.0;
+      }
+      rgb_to_hsv_float (&color_h, &color_s, &color_v);
+    }
+
+    if (settings_value[BRUSH_SMUDGE_LENGTH] < 1.0 and
+        // optimization, since normal brushes have smudge_length == 0.5 without actually smudging
+        (settings_value[BRUSH_SMUDGE] != 0.0 or not settings[BRUSH_SMUDGE]->is_constant())) {
+
+      float fac = settings_value[BRUSH_SMUDGE_LENGTH];
+      if (fac < 0.01) fac = 0.01;
+      int px, py;
+      px = ROUND(x);
+      py = ROUND(y);
+
+      // Calling get_color() is almost as expensive as rendering a
+      // dab. Because of this we use the previous value if it is not
+      // expected to hurt quality too much. We call it at most every
+      // second dab.
+      float r, g, b, a;
+      states[STATE_LAST_GETCOLOR_RECENTNESS] *= fac;
+      if (states[STATE_LAST_GETCOLOR_RECENTNESS] < 0.5*fac) {
+        states[STATE_LAST_GETCOLOR_RECENTNESS] = 1.0;
+
+        float smudge_radius = radius * expf(settings_value[BRUSH_SMUDGE_RADIUS_LOG]);
+        smudge_radius = CLAMP(smudge_radius, ACTUAL_RADIUS_MIN, ACTUAL_RADIUS_MAX);
+        surface->get_color (px, py, smudge_radius, &r, &g, &b, &a);
+
+        states[STATE_LAST_GETCOLOR_R] = r;
+        states[STATE_LAST_GETCOLOR_G] = g;
+        states[STATE_LAST_GETCOLOR_B] = b;
+        states[STATE_LAST_GETCOLOR_A] = a;
+      } else {
+        r = states[STATE_LAST_GETCOLOR_R];
+        g = states[STATE_LAST_GETCOLOR_G];
+        b = states[STATE_LAST_GETCOLOR_B];
+        a = states[STATE_LAST_GETCOLOR_A];
+      }
+
+      // updated the smudge color (stored with premultiplied alpha)
+      states[STATE_SMUDGE_A ] = fac*states[STATE_SMUDGE_A ] + (1-fac)*a;
+      // fix rounding errors
+      states[STATE_SMUDGE_A ] = CLAMP(states[STATE_SMUDGE_A], 0.0, 1.0);
+
+      states[STATE_SMUDGE_RA] = fac*states[STATE_SMUDGE_RA] + (1-fac)*r*a;
+      states[STATE_SMUDGE_GA] = fac*states[STATE_SMUDGE_GA] + (1-fac)*g*a;
+      states[STATE_SMUDGE_BA] = fac*states[STATE_SMUDGE_BA] + (1-fac)*b*a;
+    }
+
+    // eraser
+    if (settings_value[BRUSH_ERASER]) {
+      eraser_target_alpha *= (1.0-settings_value[BRUSH_ERASER]);
+    }
+
+    // HSV color change
+    color_h += settings_value[BRUSH_CHANGE_COLOR_H];
+    color_s += settings_value[BRUSH_CHANGE_COLOR_HSV_S];
+    color_v += settings_value[BRUSH_CHANGE_COLOR_V];
+
+    // HSL color change
+    if (settings_value[BRUSH_CHANGE_COLOR_L] || settings_value[BRUSH_CHANGE_COLOR_HSL_S]) {
+      // (calculating way too much here, can be optimized if neccessary)
+      // this function will CLAMP the inputs
+      hsv_to_rgb_float (&color_h, &color_s, &color_v);
+      rgb_to_hsl_float (&color_h, &color_s, &color_v);
+      color_v += settings_value[BRUSH_CHANGE_COLOR_L];
+      color_s += settings_value[BRUSH_CHANGE_COLOR_HSL_S];
+      hsl_to_rgb_float (&color_h, &color_s, &color_v);
+      rgb_to_hsv_float (&color_h, &color_s, &color_v);
+    }
+
+    float hardness = CLAMP(settings_value[BRUSH_HARDNESS], 0.0, 1.0);
+
+    // anti-aliasing attempt (works surprisingly well for ink brushes)
+    float current_fadeout_in_pixels = radius * (1.0 - hardness);
+    float min_fadeout_in_pixels = settings_value[BRUSH_ANTI_ALIASING];
+    if (current_fadeout_in_pixels < min_fadeout_in_pixels) {
+      // need to soften the brush (decrease hardness), but keep optical radius
+      // so we tune both radius and hardness, to get the desired fadeout_in_pixels
+      float current_optical_radius = radius - (1.0-hardness)*radius/2.0;
+
+      // Equation 1: (new fadeout must be equal to min_fadeout)
+      //   min_fadeout_in_pixels = radius_new*(1.0 - hardness_new)
+      // Equation 2: (optical radius must remain unchanged)
+      //   current_optical_radius = radius_new - (1.0-hardness_new)*radius_new/2.0
+      //
+      // Solved Equation 1 for hardness_new, using Equation 2: (thanks to mathomatic)
+      float hardness_new = ((current_optical_radius - (min_fadeout_in_pixels/2.0))/(current_optical_radius + (min_fadeout_in_pixels/2.0)));
+      // Using Equation 1:
+      float radius_new = (min_fadeout_in_pixels/(1.0 - hardness_new));
+
+      hardness = hardness_new;
+      radius = radius_new;
+    }
+
+    // the functions below will CLAMP most inputs
+    hsv_to_rgb_float (&color_h, &color_s, &color_v);
+    return surface->draw_dab (x, y, radius, color_h, color_s, color_v, opaque, hardness, eraser_target_alpha,
+                              states[STATE_ACTUAL_ELLIPTICAL_DAB_RATIO], states[STATE_ACTUAL_ELLIPTICAL_DAB_ANGLE],
+                              settings_value[BRUSH_LOCK_ALPHA], false, 
+                              settings_value[BRUSH_TEXTURE_GRAIN], settings_value[BRUSH_TEXTURE_CONTRAST]);
+  }
+
+  // How many dabs will be drawn between the current and the next (x, y, pressure, +dt) position?
+  float count_dabs_to (float x, float y, float pressure, float dt)
+  {
+    float xx, yy;
+    float res1, res2, res3;
+    float dist;
+
+    if (states[STATE_ACTUAL_RADIUS] == 0.0) states[STATE_ACTUAL_RADIUS] = expf(settings[BRUSH_RADIUS_LOGARITHMIC]->base_value);
+    if (states[STATE_ACTUAL_RADIUS] < ACTUAL_RADIUS_MIN) states[STATE_ACTUAL_RADIUS] = ACTUAL_RADIUS_MIN;
+    if (states[STATE_ACTUAL_RADIUS] > ACTUAL_RADIUS_MAX) states[STATE_ACTUAL_RADIUS] = ACTUAL_RADIUS_MAX;
+
+
+    // OPTIMIZE: expf() called too often
+    float base_radius = expf(settings[BRUSH_RADIUS_LOGARITHMIC]->base_value);
+    if (base_radius < ACTUAL_RADIUS_MIN) base_radius = ACTUAL_RADIUS_MIN;
+    if (base_radius > ACTUAL_RADIUS_MAX) base_radius = ACTUAL_RADIUS_MAX;
+    //if (base_radius < 0.5) base_radius = 0.5;
+    //if (base_radius > 500.0) base_radius = 500.0;
+
+    xx = x - states[STATE_X];
+    yy = y - states[STATE_Y];
+    //dp = pressure - pressure; // Not useful?
+    // TODO: control rate with pressure (dabs per pressure) (dpressure is useless)
+
+    if (states[STATE_ACTUAL_ELLIPTICAL_DAB_RATIO] > 1.0) {
+      // code duplication, see tiledsurface::draw_dab()
+      float angle_rad=states[STATE_ACTUAL_ELLIPTICAL_DAB_ANGLE]/360*2*M_PI;
+      float cs=cos(angle_rad);
+      float sn=sin(angle_rad);
+      float yyr=(yy*cs-xx*sn)*states[STATE_ACTUAL_ELLIPTICAL_DAB_RATIO];
+      float xxr=yy*sn+xx*cs;
+      dist = sqrt(yyr*yyr + xxr*xxr);
+    } else {
+      dist = hypotf(xx, yy);
+    }
+
+    // FIXME: no need for base_value or for the range checks above IF always the interpolation
+    //        function will be called before this one
+    res1 = dist / states[STATE_ACTUAL_RADIUS] * settings[BRUSH_DABS_PER_ACTUAL_RADIUS]->base_value;
+    res2 = dist / base_radius   * settings[BRUSH_DABS_PER_BASIC_RADIUS]->base_value;
+    res3 = dt * settings[BRUSH_DABS_PER_SECOND]->base_value;
+    return res1 + res2 + res3;
+  }
+
+public:
+  // This function:
+  // - is called once for each motion event
+  // - does motion event interpolation
+  // - paints zero, one or several dabs
+  // - decides whether the stroke is finished (for undo/redo)
+  // returns true if the stroke is finished or empty
+  bool stroke_to (Surface * surface, float x, float y, float pressure, float xtilt, float ytilt, double dtime)
+  {
+    //printf("%f %f %f %f\n", (double)dtime, (double)x, (double)y, (double)pressure);
+
+    float tilt_ascension = 0.0;
+    float tilt_declination = 90.0;
+    if (xtilt != 0 || ytilt != 0) {
+      // shield us from insane tilt input
+      xtilt = CLAMP(xtilt, -1.0, 1.0);
+      ytilt = CLAMP(ytilt, -1.0, 1.0);
+      assert(isfinite(xtilt) && isfinite(ytilt));
+
+      tilt_ascension = 180.0*atan2(-xtilt, ytilt)/M_PI;
+      float e;
+      if (abs(xtilt) > abs(ytilt)) {
+        e = sqrt(1+ytilt*ytilt);
+      } else {
+        e = sqrt(1+xtilt*xtilt);
+      }
+      float rad = hypot(xtilt, ytilt);
+      float cos_alpha = rad/e;
+      if (cos_alpha >= 1.0) cos_alpha = 1.0; // fix numerical inaccuracy
+      tilt_declination = 180.0*acos(cos_alpha)/M_PI;
+
+      assert(isfinite(tilt_ascension));
+      assert(isfinite(tilt_declination));
+    }
+
+    // printf("xtilt %f, ytilt %f\n", (double)xtilt, (double)ytilt);
+    // printf("ascension %f, declination %f\n", (double)tilt_ascension, (double)tilt_declination);
+      
+    pressure = CLAMP(pressure, 0.0, 1.0);
+    if (!isfinite(x) || !isfinite(y) ||
+        (x > 1e10 || y > 1e10 || x < -1e10 || y < -1e10)) {
+      // workaround attempt for https://gna.org/bugs/?14372
+      g_print("Warning: ignoring brush::stroke_to with insane inputs (x = %f, y = %f)\n", (double)x, (double)y);
+      x = 0.0;
+      y = 0.0;
+      pressure = 0.0;
+    }
+    // the assertion below is better than out-of-memory later at save time
+    assert(x < 1e8 && y < 1e8 && x > -1e8 && y > -1e8);
+
+    if (dtime < 0) g_print("Time jumped backwards by dtime=%f seconds!\n", dtime);
+    if (dtime <= 0) dtime = 0.0001; // protect against possible division by zero bugs
+    
+    if (dtime > 0.100 && pressure && states[STATE_PRESSURE] == 0) {
+      // Workaround for tablets that don't report motion events without pressure.
+      // This is to avoid linear interpolation of the pressure between two events.
+      stroke_to (surface, x, y, 0.0, 90.0, 0.0, dtime-0.0001);
+      dtime = 0.0001;
+    }
+
+    g_rand_set_seed (rng, states[STATE_RNG_SEED]);
+
+    { // calculate the actual "virtual" cursor position
+
+      // noise first
+      if (settings[BRUSH_TRACKING_NOISE]->base_value) {
+        // OPTIMIZE: expf() called too often
+        float base_radius = expf(settings[BRUSH_RADIUS_LOGARITHMIC]->base_value);
+
+        x += rand_gauss (rng) * settings[BRUSH_TRACKING_NOISE]->base_value * base_radius;
+        y += rand_gauss (rng) * settings[BRUSH_TRACKING_NOISE]->base_value * base_radius;
+      }
+
+      float fac = 1.0 - exp_decay (settings[BRUSH_SLOW_TRACKING]->base_value, 100.0*dtime);
+      x = states[STATE_X] + (x - states[STATE_X]) * fac;
+      y = states[STATE_Y] + (y - states[STATE_Y]) * fac;
+    }
+
+    // draw many (or zero) dabs to the next position
+
+    // see doc/stroke2dabs.png
+    float dist_moved = states[STATE_DIST];
+    float dist_todo = count_dabs_to (x, y, pressure, dtime);
+
+    //if (dtime > 5 || dist_todo > 300) {
+    if (dtime > 5 || reset_requested) {
+      reset_requested = false;
+
+      /*
+        TODO:
+        if (dist_todo > 300) {
+        // this happens quite often, eg when moving the cursor back into the window
+        // FIXME: bad to hardcode a distance treshold here - might look at zoomed image
+        //        better detect leaving/entering the window and reset then.
+        g_print ("Warning: NOT drawing %f dabs.\n", dist_todo);
+        g_print ("dtime=%f, dx=%f\n", dtime, x-states[STATE_X]);
+        //must_reset = 1;
+        }
+      */
+
+      //printf("Brush reset.\n");
+      for (int i=0; i<STATE_COUNT; i++) {
+        states[i] = 0;
+      }
+
+      states[STATE_X] = x;
+      states[STATE_Y] = y;
+      states[STATE_PRESSURE] = pressure;
+
+      // not resetting, because they will get overwritten below:
+      //dx, dy, dpress, dtime
+
+      states[STATE_ACTUAL_X] = states[STATE_X];
+      states[STATE_ACTUAL_Y] = states[STATE_Y];
+      states[STATE_STROKE] = 1.0; // start in a state as if the stroke was long finished
+
+      return true;
+    }
+
+    //g_print("dist = %f\n", states[STATE_DIST]);
+    enum { UNKNOWN, YES, NO } painted = UNKNOWN;
+    double dtime_left = dtime;
+
+    float step_dx, step_dy, step_dpressure, step_dtime;
+    float step_declination, step_ascension;
+    while (dist_moved + dist_todo >= 1.0) { // there are dabs pending
+      { // linear interpolation (nonlinear variant was too slow, see SVN log)
+        float frac; // fraction of the remaining distance to move
+        if (dist_moved > 0) {
+          // "move" the brush exactly to the first dab (moving less than one dab)
+          frac = (1.0 - dist_moved) / dist_todo;
+          dist_moved = 0;
+        } else {
+          // "move" the brush from one dab to the next
+          frac = 1.0 / dist_todo;
+        }
+        step_dx        = frac * (x - states[STATE_X]);
+        step_dy        = frac * (y - states[STATE_Y]);
+        step_dpressure = frac * (pressure - states[STATE_PRESSURE]);
+        step_dtime     = frac * (dtime_left - 0.0);
+        step_declination = frac * (tilt_declination - states[STATE_DECLINATION]);
+        step_ascension   = frac * (tilt_ascension - states[STATE_ASCENSION]);
+        // Though it looks different, time is interpolated exactly like x/y/pressure.
+      }
+    
+      update_states_and_setting_values (step_dx, step_dy, step_dpressure, step_declination, step_ascension, step_dtime);
+      bool painted_now = prepare_and_draw_dab (surface);
+      if (painted_now) {
+        painted = YES;
+      } else if (painted == UNKNOWN) {
+        painted = NO;
+      }
+
+      dtime_left   -= step_dtime;
+      dist_todo  = count_dabs_to (x, y, pressure, dtime_left);
+    }
+
+    {
+      // "move" the brush to the current time (no more dab will happen)
+      // Important to do this at least once every event, because
+      // brush_count_dabs_to depends on the radius and the radius can
+      // depend on something that changes much faster than only every
+      // dab (eg speed).
+    
+      step_dx        = x - states[STATE_X];
+      step_dy        = y - states[STATE_Y];
+      step_dpressure = pressure - states[STATE_PRESSURE];
+      step_declination = tilt_declination - states[STATE_DECLINATION];
+      step_ascension = tilt_ascension - states[STATE_ASCENSION];
+      step_dtime     = dtime_left;
+    
+      //dtime_left = 0; but that value is not used any more
+
+      update_states_and_setting_values (step_dx, step_dy, step_dpressure, step_declination, step_ascension, step_dtime);
+    }
+
+    // save the fraction of a dab that is already done now
+    states[STATE_DIST] = dist_moved + dist_todo;
+    //g_print("dist_final = %f\n", states[STATE_DIST]);
+
+    // next seed for the RNG (GRand has no get_state() and states[] must always contain our full state)
+    states[STATE_RNG_SEED] = g_rand_int(rng);
+
+    // stroke separation logic (for undo/redo)
+
+    if (painted == UNKNOWN) {
+      if (stroke_current_idling_time > 0 || stroke_total_painting_time == 0) {
+        // still idling
+        painted = NO;
+      } else {
+        // probably still painting (we get more events than brushdabs)
+        painted = YES;
+        //if (pressure == 0) g_print ("info: assuming 'still painting' while there is no pressure\n");
+      }
+    }
+    if (painted == YES) {
+      //if (stroke_current_idling_time > 0) g_print ("idling ==> painting\n");
+      stroke_total_painting_time += dtime;
+      stroke_current_idling_time = 0;
+      // force a stroke split after some time
+      if (stroke_total_painting_time > 4 + 3*pressure) {
+        // but only if pressure is not being released
+        // FIXME: use some smoothed state for dpressure, not the output of the interpolation code
+        //        (which might easily wrongly give dpressure == 0)
+        if (step_dpressure >= 0) {
+          return true;
+        }
+      }
+    } else if (painted == NO) {
+      //if (stroke_current_idling_time == 0) g_print ("painting ==> idling\n");
+      stroke_current_idling_time += dtime;
+      if (stroke_total_painting_time == 0) {
+        // not yet painted, start a new stroke if we have accumulated a lot of irrelevant motion events
+        if (stroke_current_idling_time > 1.0) {
+          return true;
+        }
+      } else {
+        // Usually we have pressure==0 here. But some brushes can paint
+        // nothing at full pressure (eg gappy lines, or a stroke that
+        // fades out). In either case this is the prefered moment to split.
+//        if (stroke_total_painting_time+stroke_current_idling_time > 0.9 + 5*pressure) {
+          return true;
+//        }
+      }
+    }
+    return false;
+  }
+
+};
+
+#endif
diff -Naur gimp-2.8.14/app/paint/mypaintbrush-stroke.cpp gimp-2.8.14-new/app/paint/mypaintbrush-stroke.cpp
--- gimp-2.8.14/app/paint/mypaintbrush-stroke.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/mypaintbrush-stroke.cpp	2015-01-27 17:48:55.361751580 +0800
@@ -0,0 +1,106 @@
+
+
+extern "C" {
+
+#include "config.h"
+
+#include <gegl.h>
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpmath/gimpmath.h"
+#include "libgimpconfig/gimpconfig.h"
+
+#include "paint-types.h"
+
+#include "core/gimp.h"
+#include "core/gimpimage.h"
+#include "core/gimpdynamics.h"
+#include "core/gimpdynamicsoutput.h"
+#include "core/gimpgradient.h"
+
+#include "gimpmypaintoptions.h"
+
+#include "gimp-intl.h"
+
+#include <cairo.h>
+}
+
+#include "mypaintbrush-surface.hpp"
+#include "mypaintbrush-brush.hpp"
+#include "mypaintbrush-stroke.hpp"
+#include "gimpmypaintcore.hpp"
+
+gint Stroke::_serial_number = 0;
+
+Stroke::Stroke() : brush(NULL), finished(FALSE)
+{
+  serial_number = ++_serial_number;
+}
+
+
+Stroke::~Stroke() 
+{
+}
+
+void 
+Stroke::start(Brush* brush)
+{
+  g_assert (!finished);
+  
+  //TODO: record brush state and setting here.
+  
+  brush->new_stroke();
+  coords.clear();
+  this->brush = brush;
+  
+}
+
+void 
+Stroke::record(gdouble dtime, 
+               const GimpCoords* coord)
+{
+  // TODO:
+  g_assert (!finished);
+  StrokeRecord rec;
+  rec.dtime  = dtime;
+  rec.coords = *coord;
+  coords.push_back(rec);
+}
+
+void 
+Stroke::stop()
+{
+ // TODO:
+  finished = true;
+  total_painting_time += brush->stroke_total_painting_time;
+}
+
+bool 
+Stroke::is_empty()
+{
+  return total_painting_time == 0;
+}
+
+void 
+Stroke::render(Surface* surface)
+{
+  // TODO:
+  for (std::vector<StrokeRecord>::iterator i = coords.begin(); i != coords.end(); i ++) {
+    brush->stroke_to(surface, i->coords.x, i->coords.y, 
+                     i->coords.pressure, 
+                     i->coords.xtilt, i->coords.ytilt, i->dtime);
+  }
+
+}
+
+void 
+Stroke::copy_using_different_brush(Surface* surface, Brush* b)
+{
+  // TODO:
+  for (std::vector<StrokeRecord>::iterator i = coords.begin(); i != coords.end(); i ++) {
+    b->stroke_to(surface, i->coords.x, i->coords.y, 
+                     i->coords.pressure, 
+                     i->coords.xtilt, i->coords.ytilt, i->dtime);
+  }
+
+}
diff -Naur gimp-2.8.14/app/paint/mypaintbrush-stroke.hpp gimp-2.8.14-new/app/paint/mypaintbrush-stroke.hpp
--- gimp-2.8.14/app/paint/mypaintbrush-stroke.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/mypaintbrush-stroke.hpp	2015-01-27 17:48:55.361751580 +0800
@@ -0,0 +1,35 @@
+#ifndef __MYPAINT_BRUSH_STROKE_HPP__
+#define __MYPAINT_BRUSH_STROKE_HPP__
+
+#include "mypaintbrush-brush.hpp"
+#include "mypaintbrush-surface.hpp"
+#include <vector>
+
+class Stroke {
+  struct StrokeRecord {
+    gdouble dtime;
+    GimpCoords coords;
+  };
+
+  static gint _serial_number;
+
+  Brush*                 brush;
+  gdouble                total_painting_time;
+  bool                   finished;
+  gint                   serial_number;
+  std::vector<StrokeRecord> coords;
+
+public:
+  Stroke();
+  ~Stroke();
+
+  void start(Brush* brush);
+  void record(gdouble dtime, 
+              const GimpCoords* coord);
+  void stop();
+  bool is_empty();
+  void render(Surface* surface);
+  void copy_using_different_brush(Surface* surface, Brush* b);
+};
+
+#endif /* __MYPAINT_BRUSH_STROKE_HPP__ */
diff -Naur gimp-2.8.14/app/paint/mypaintbrush-surface.hpp gimp-2.8.14-new/app/paint/mypaintbrush-surface.hpp
--- gimp-2.8.14/app/paint/mypaintbrush-surface.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint/mypaintbrush-surface.hpp	2015-01-27 17:48:55.361751580 +0800
@@ -0,0 +1,48 @@
+/* brushlib - The MyPaint Brush Library
+ * Copyright (C) 2008 Martin Renold <martinxyz@gmx.ch>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+ 
+#ifndef __MYPAINTBRUSH_SURFACE_HPP__
+#define __MYPAINTBRUSH_SURFACE_HPP__
+
+// surface interface required by brush.hpp
+class Surface {
+public:
+
+  virtual ~Surface() {}
+
+  virtual bool draw_dab (float x, float y, 
+                         float radius, 
+                         float color_r, float color_g, float color_b,
+                         float opaque, float hardness = 0.5,
+                         float alpha_eraser = 1.0,
+                         float aspect_ratio = 1.0, float angle = 0.0,
+                         float lock_alpha = 0.0, float colorize = 0.0,
+                         float texture_grain = 0.0, float texture_contrast = 1.0
+                         ) = 0;
+
+  virtual void get_color (float x, float y, 
+                          float radius, 
+                          float * color_r, float * color_g, float * color_b, float * color_a,
+                          float texture_grain = 0.0, float texture_contrast = 1.0
+                          ) = 0;
+
+  virtual void begin_session() = 0;
+
+  virtual void end_session() = 0;
+
+};
+
+#endif
diff -Naur gimp-2.8.14/app/paint/paint-types.h gimp-2.8.14-new/app/paint/paint-types.h
--- gimp-2.8.14/app/paint/paint-types.h	2015-01-27 17:28:36.799833815 +0800
+++ gimp-2.8.14-new/app/paint/paint-types.h	2015-01-27 17:48:55.362751580 +0800
@@ -45,6 +45,7 @@
 /*  paint options  */
 
 typedef struct _GimpPaintOptions            GimpPaintOptions;
+typedef struct _GimpMypaintOptions          GimpMypaintOptions;
 typedef struct _GimpSourceOptions           GimpSourceOptions;
 
 typedef struct _GimpAirbrushOptions         GimpAirbrushOptions;
@@ -61,6 +62,7 @@
 /*  paint undos  */
 
 typedef struct _GimpPaintCoreUndo GimpPaintCoreUndo;
+typedef struct _GimpMypaintCoreUndo GimpMypaintCoreUndo;
 typedef struct _GimpInkUndo       GimpInkUndo;
 
 
diff -Naur gimp-2.8.14/app/paint-funcs/Makefile.am gimp-2.8.14-new/app/paint-funcs/Makefile.am
--- gimp-2.8.14/app/paint-funcs/Makefile.am	2015-01-27 17:28:36.847833812 +0800
+++ gimp-2.8.14-new/app/paint-funcs/Makefile.am	2015-01-27 17:48:55.344751582 +0800
@@ -30,4 +30,5 @@
 	scale-region.c		\
 	scale-region.h		\
 	subsample-region.c	\
-	subsample-region.h
+	subsample-region.h	\
+	mypaint-brushmodes.hpp
diff -Naur gimp-2.8.14/app/paint-funcs/mypaint-brushmodes.hpp gimp-2.8.14-new/app/paint-funcs/mypaint-brushmodes.hpp
--- gimp-2.8.14/app/paint-funcs/mypaint-brushmodes.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/paint-funcs/mypaint-brushmodes.hpp	2015-01-27 17:48:55.345751582 +0800
@@ -0,0 +1,646 @@
+/* This file is part of MyPaint.
+ * Copyright (C) 2008-2011 by Martin Renold <martinxyz@gmx.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define REAL_CALC
+#include "base/pixel.hpp"
+
+struct BrushPixelIteratorForRunLength {
+  Pixel::real*   mask;
+  gint*          offsets;
+  Pixel::real*   colors;
+  Pixel::data_t* src;
+  Pixel::data_t* dest;
+  gint           src_bytes;
+  gint           dest_bytes;
+  
+  BrushPixelIteratorForRunLength(Pixel::real* mask_, 
+                                 gint* offsets_, 
+                                 Pixel::real* colors_,
+                                 Pixel::data_t* src_, 
+                                 Pixel::data_t* dest_, 
+                                 gint src_bytes_,
+                                 gint dest_bytes_) {
+    mask       = mask_;
+    offsets    = offsets_;
+    colors     = colors_;
+    src        = src_;
+    dest       = dest_;
+    src_bytes  = src_bytes_;
+    dest_bytes = dest_bytes_;
+  }
+  
+  bool is_row_end() { return !mask[0]; };
+  bool is_data_end() { return !offsets[0]; };
+  void next_pixel() { mask++; src+=src_bytes; dest += dest_bytes; };
+  void next_row() {
+    src  += offsets[0] * src_bytes;
+    dest += offsets[0] * dest_bytes;
+    offsets ++;
+    mask ++;
+  };
+  bool should_skipped() { return false; }
+  
+  Pixel::real  get_brush_alpha() { return mask[0]; }
+  Pixel::real* get_brush_color() { return colors; }
+};
+
+struct ColoredBrushmarkIterator {
+  typedef Pixel::real mask_t;
+  typedef Pixel::real color_t;
+  mask_t*              mask;
+  gint                 width;
+  gint                 height;
+  gint                 mask_stride;
+  mask_t*              row_guard;
+  mask_t*              data_guard;
+  color_t*             colors;
+  int x, y;
+  
+  ColoredBrushmarkIterator(mask_t* mask_,
+                           color_t* colors_,
+                           gint width_,
+                           gint height_,
+                           gint mask_stride_,
+                           gint /*unused*/
+                          ) 
+    : mask(mask_), colors(colors_), mask_stride(mask_stride_), 
+      width(width_), height(height_)
+  {
+    row_guard  = mask + width;
+    data_guard = mask_ + height * mask_stride;
+    colors     = colors_;
+    x = y = 0;
+  };
+  
+  void next_pixel() {
+    mask++;
+    x++;
+  };
+
+  void next_row() {
+    y ++; x = 0;
+    mask += mask_stride - width;
+    row_guard = mask + width;
+  };
+
+  bool is_row_end() { return mask == row_guard; };
+  bool is_data_end() { return (mask + mask_stride - width) == data_guard; };
+  
+  mask_t   get_brush_alpha() { return mask[0]; };
+  color_t* get_brush_color() { return colors; };
+  bool should_skipped() { return !mask[0]; }
+
+};
+
+struct PixmapBrushmarkIterator {
+  typedef Pixel::data_t mask_t;
+  typedef Pixel::data_t color_t;
+  mask_t*        mask;
+  gint           width;
+  gint           height;
+  gint           mask_stride;
+  gint           mask_bytes;
+  mask_t*        row_guard;
+  mask_t*        data_guard;
+  int x,y;
+  
+  PixmapBrushmarkIterator(mask_t* mask_,
+                          color_t* /*unused*/,
+                          gint width_,
+                          gint height_,
+                          gint mask_stride_,
+                          gint mask_bytes_
+                          ) 
+    : mask(mask_),
+      width(width_), height(height_),
+      mask_stride(mask_stride_), mask_bytes(mask_bytes_)
+  {
+    row_guard  = mask + width  * mask_bytes;
+    data_guard = mask + height * mask_stride;
+    x = y = 0;
+  };
+  
+  bool is_row_end() { return mask == row_guard; };
+  bool is_data_end() { return (mask + mask_stride - width) >= data_guard; };
+  
+  void next_pixel() {
+    mask   += mask_bytes;
+    x ++;
+  };
+
+  void next_row() {
+    y++; x = 0;
+    mask      += mask_stride - width * mask_bytes;
+    row_guard = mask + width * mask_bytes;
+  };
+
+  mask_t   get_brush_alpha() { return mask[3]; };
+  color_t* get_brush_color() { return mask; };
+  bool should_skipped() { return !mask[3]; }
+
+};
+
+template<typename ParentClass, typename Mask, typename Color>
+struct BrushPixelIteratorForPlainData : ParentClass {
+  typedef Mask mask_t;
+  typedef Color color_t;
+  Pixel::data_t* src;
+  Pixel::data_t* dest;
+  gint           src_stride;
+  gint           dest_stride;
+  gint           src_bytes;
+  gint           dest_bytes;
+  Pixel::data_t* dest_guard;
+  
+  BrushPixelIteratorForPlainData(mask_t*  mask_,
+                                 color_t* colors_,
+                                 Pixel::data_t* src_,
+                                 Pixel::data_t* dest_,
+                                 gint width_, gint height_, 
+                                 gint mask_stride_,
+                                 gint src_stride_,
+                                 gint dest_stride_,
+                                 gint mask_bytes_,
+                                 gint src_bytes_,
+                                 gint dest_bytes_) 
+    : ParentClass(mask_, colors_, width_, height_, mask_stride_, mask_bytes_)
+  {
+    src         = src_;
+    dest        = dest_;
+    src_stride  = src_stride_;
+    dest_stride = dest_stride_;
+    src_bytes   = src_bytes_;
+    dest_bytes  = dest_bytes_;
+    dest_guard  = dest + (((ParentClass*)this)->height - 1) * dest_stride + ((ParentClass*)this)->width * dest_bytes - 1;
+  }
+  
+  void next_pixel() {
+    ParentClass::next_pixel();
+    src  += src_bytes; 
+    dest += dest_bytes;
+  };
+
+  void next_row() {
+    ParentClass::next_row();
+    src  += src_stride - ((ParentClass*)this)->width * src_bytes;
+    dest += dest_stride - ((ParentClass*)this)->width * dest_bytes;
+  };
+
+
+};
+
+// parameters to those methods:
+//
+// rgba: A pointer to 16bit rgba data with premultiplied alpha.
+//       The range of each components is limited from 0 to 2^15.
+//
+// mask: Contains the dab shape, that is, the intensity of the dab at
+//       each pixel. Usually rendering is done for one tile at a
+//       time. The mask is LRE encoded to jump quickly over regions
+//       that are not affected by the dab.
+//
+// opacity: overall strenght of the blending mode. Has the same
+//          influence on the dab as the values inside the mask.
+
+
+// We are manipulating pixels with premultiplied alpha directly.
+// This is an "over" operation (opa = topAlpha).
+// In the formula below, topColor is assumed to be premultiplied.
+//
+//               opa_a      <   opa_b      >
+// resultAlpha = topAlpha + (1.0 - topAlpha) * bottomAlpha
+// resultColor = topColor + (1.0 - topAlpha) * bottomColor
+//
+template<typename Iter>
+void draw_dab_pixels_BlendMode_Normal (Iter iter,
+                                       Pixel::real   opacity) 
+{
+  switch (iter.src_bytes) {
+  case 1:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+        if (iter.should_skipped())
+          continue;
+        pixel_t opa_a = pix( eval( pix(iter.get_brush_alpha()) * pix(opacity) ) ); // topAlpha
+        pixel_t opa_b = pix( eval (pix(1.0f) - opa_a ) ); // bottomAlpha
+        iter.dest[0] = r2d(eval( opa_a*pix(iter.get_brush_color()[0]) + opa_b*pix(iter.src[0]) ));
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+    break;
+  case 3:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+        if (iter.should_skipped())
+          continue;
+        pixel_t opa_a = pix( eval( pix(iter.get_brush_alpha()) * pix(opacity) ) ); // topAlpha
+        pixel_t opa_b = pix( eval (pix(1.0f) - opa_a ) ); // bottomAlpha
+        iter.dest[0] = r2d(eval( opa_a*pix(iter.get_brush_color()[0]) + opa_b*pix(iter.src[0]) ));
+        iter.dest[1] = r2d(eval( opa_a*pix(iter.get_brush_color()[1]) + opa_b*pix(iter.src[1]) ));
+        iter.dest[2] = r2d(eval( opa_a*pix(iter.get_brush_color()[2]) + opa_b*pix(iter.src[2]) ));
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+    break;
+  case 4:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+        if (iter.should_skipped())
+          continue;
+
+        pixel_t brush_a = pix( eval( pix(iter.get_brush_alpha()) * pix(opacity) ) );
+        pixel_t base_a  = pix(iter.src[3]);
+	      result_t alpha  = eval( brush_a + (pix(1.0f) - brush_a) * base_a );
+        iter.dest[3] = r2d(alpha);
+        if (alpha) {
+          pixel_t dest_a = pix(alpha);
+          iter.dest[0] = r2d(eval( (brush_a * pix(iter.get_brush_color()[0]) + 
+                                   (pix(1.0f) - brush_a) * base_a * pix(iter.src[0])) 
+                                   / dest_a ));
+          iter.dest[1] = r2d(eval( (brush_a * pix(iter.get_brush_color()[1]) + 
+                                   (pix(1.0f) - brush_a) * base_a * pix(iter.src[1])) 
+                                   / dest_a ));
+          iter.dest[2] = r2d(eval( (brush_a * pix(iter.get_brush_color()[2]) + 
+                                   (pix(1.0f) - brush_a) * base_a * pix(iter.src[2])) 
+                                   / dest_a ));
+        } else {
+          iter.dest[0] = iter.get_brush_color()[0];
+          iter.dest[1] = iter.get_brush_color()[1];
+          iter.dest[2] = iter.get_brush_color()[2];
+        }
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+    break;
+  default:
+    g_print("Unsupported layer type: %d.\n", iter.src_bytes);
+  }
+};
+
+// This blend mode is used for smudging and erasing.  Smudging
+// allows to "drag" around transparency as if it was a color.  When
+// smuding over a region that is 60% opaque the result will stay 60%
+// opaque (color_a=0.6).  For normal erasing color_a is set to 0.0
+// and color_r/g/b will be ignored. This function can also do normal
+// blending (color_a=1.0).
+//
+template<typename Iter>
+void draw_dab_pixels_BlendMode_Normal_and_Eraser (Iter iter,
+                                                  Pixel::real   color_a,
+                                                  Pixel::real   opacity,
+                                                  Pixel::real   background_r = 1.0f,
+                                                  Pixel::real   background_g = 1.0f,
+                                                  Pixel::real   background_b = 1.0f) {
+//  g_print("BlendMode_Normal_and_Eraser(color_a=%d)\n", color_a);
+  Pixel::real bg_color[3];
+  bg_color[0] = background_r;
+  bg_color[1] = background_g;
+  bg_color[2] = background_b;
+
+  switch (iter.src_bytes) {
+  case 1:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+
+        if (iter.should_skipped())
+          continue;
+
+        pixel_t brush_a     = pix( eval( pix(iter.get_brush_alpha()) * pix(opacity) ) ); // topAlpha
+        pixel_t inv_brush_a = pix( eval (f2p(1.0) - brush_a ) ); // bottomAlpha
+
+        iter.dest[0] = r2d(eval( brush_a*((pix(1.0f) - pix(color_a))*pix(bg_color[0]) 
+                                          + pix(color_a)*pix(iter.get_brush_color()[0])) 
+                                 + inv_brush_a*pix(iter.src[0]) ));
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+    break;  
+  case 3:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+
+        if (iter.should_skipped())
+          continue;
+
+        pixel_t brush_a     = pix( eval( pix(iter.get_brush_alpha()) * pix(opacity) ) ); // topAlpha
+        pixel_t inv_brush_a = pix( eval (f2p(1.0) - brush_a ) ); // bottomAlpha
+
+        iter.dest[0] = r2d(eval( brush_a*((pix(1.0f) - pix(color_a))*pix(bg_color[0]) 
+                                          + pix(color_a)*pix(iter.get_brush_color()[0])) 
+                                 + inv_brush_a*pix(iter.src[0]) ));
+        iter.dest[1] = r2d(eval( brush_a*((pix(1.0f) - pix(color_a))*pix(bg_color[1]) 
+                                          + pix(color_a)*pix(iter.get_brush_color()[1])) 
+                                 + inv_brush_a*pix(iter.src[1]) ));
+        iter.dest[2] = r2d(eval( brush_a*((pix(1.0f) - pix(color_a))*pix(bg_color[2]) 
+                                          + pix(color_a)*pix(iter.get_brush_color()[2])) 
+                                 + inv_brush_a*pix(iter.src[2]) ));
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+    break;
+  case 4:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+
+        if (iter.should_skipped())
+          continue;
+
+        pixel_t brush_a = pix( eval( pix(iter.get_brush_alpha()) * pix(opacity) ) );
+        pixel_t base_a  = pix(iter.src[3]);
+	      result_t alpha = eval( brush_a * pix(color_a) + (pix(1.0f) - brush_a) * base_a );
+        iter.dest[3] = r2d(alpha);
+        
+        if (alpha) {
+          pixel_t inv_brush_a = pix( eval(pix(1.0f) - brush_a));
+          pixel_t dest_a = pix(alpha);
+          iter.dest[0] = r2d(eval( (inv_brush_a*base_a*pix(iter.src[0]) + brush_a*pix(color_a)*pix(iter.get_brush_color()[0])) / dest_a ));
+          iter.dest[1] = r2d(eval( (inv_brush_a*base_a*pix(iter.src[1]) + brush_a*pix(color_a)*pix(iter.get_brush_color()[1])) / dest_a ));
+          iter.dest[2] = r2d(eval( (inv_brush_a*base_a*pix(iter.src[2]) + brush_a*pix(color_a)*pix(iter.get_brush_color()[2])) / dest_a ));
+        } else {
+          iter.dest[0] = iter.get_brush_color()[0];
+          iter.dest[1] = iter.get_brush_color()[1];
+          iter.dest[2] = iter.get_brush_color()[2];
+        }
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+    break;
+  default:
+    g_print("Unsupported layer type.\n");
+  }
+};
+
+// This is BlendMode_Normal with locked alpha channel.
+//
+template<typename Iter>
+void draw_dab_pixels_BlendMode_LockAlpha (Iter          iter,
+                                          Pixel::real   opacity)
+{
+  switch (iter.src_bytes) {
+  case 1:
+  case 3:
+    draw_dab_pixels_BlendMode_Normal(iter, opacity);
+    break;
+  case 4:
+
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+
+        if (iter.should_skipped())
+          continue;
+
+        pixel_t brush_a = pix( eval( pix(iter.get_brush_alpha()) * pix(opacity) ) ); // topAlpha
+        pixel_t inv_brush_a = pix( eval( f2p(1.0) - brush_a) ); // bottomAlpha
+        pixel_t alpha = pix( iter.src[3] );
+        pixel_t dest_a = pix( iter.src[3] );
+        pixel_t base_a = dest_a;
+        
+        iter.dest[0] = r2d(eval( (brush_a*alpha*pix(iter.get_brush_color()[0]) + inv_brush_a*base_a*pix(iter.src[0])) / dest_a));
+        iter.dest[1] = r2d(eval( (brush_a*alpha*pix(iter.get_brush_color()[1]) + inv_brush_a*base_a*pix(iter.src[1])) / dest_a));
+        iter.dest[2] = r2d(eval( (brush_a*alpha*pix(iter.get_brush_color()[2]) + inv_brush_a*base_a*pix(iter.src[2])) / dest_a));
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+  break;
+  default:
+    g_print("Unsupported layer type.\n");
+  }
+};
+
+
+// Sum up the color/alpha components inside the masked region.
+// Called by get_color().
+//
+template<typename Iter>
+void get_color_pixels_accumulate (/*Pixel::real  * mask,
+                                  gint          *offsets,
+                                  Pixel::data_t * rgba,*/
+                                  Iter iter,
+                                  float * sum_weight,
+                                  float * sum_r,
+                                  float * sum_g,
+                                  float * sum_b,
+                                  float * sum_a/*,
+                                  gint bytes*/
+                                  ) {
+
+
+  // The sum of a 64x64 tile fits into a 32 bit integer, but the sum
+  // of an arbitrary number of tiles may not fit. We assume that we
+  // are processing a single tile at a time, so we can use integers.
+  // But for the result we need floats.
+
+  internal_t weight = 0;
+  internal_t r = 0;
+  internal_t g = 0;
+  internal_t b = 0;
+  internal_t a = 0;
+
+  switch (iter.src_bytes) {
+  case 1:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+
+        if (iter.should_skipped())
+          continue;
+
+        pixel_t opa = pix (iter.get_brush_alpha());
+        weight += r2i(eval(opa));
+        r      += r2i(eval (opa * pix(iter.src[0]) * pix(1.0f)));
+        a      += r2i(eval(opa));
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+      g = b = r;
+    break;
+  case 3:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+
+        if (iter.should_skipped())
+          continue;
+
+        pixel_t opa = pix (iter.get_brush_alpha());
+        weight += r2i(eval(opa));
+        r      += r2i(eval (opa * pix(iter.src[0]) * pix(1.0f)));
+        g      += r2i(eval (opa * pix(iter.src[1]) * pix(1.0f)));
+        b      += r2i(eval (opa * pix(iter.src[2]) * pix(1.0f)));
+        a      += r2i(eval(opa));
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+    break;
+  case 4:
+    while (1) {
+      for (; !iter.is_row_end(); iter.next_pixel()) {
+
+        if (iter.should_skipped())
+          continue;
+
+        pixel_t opa = pix (iter.get_brush_alpha());
+        weight += r2i(eval(opa));
+        r      += r2i(eval (opa * pix(iter.src[0]) * pix(iter.src[3])));
+        g      += r2i(eval (opa * pix(iter.src[1]) * pix(iter.src[3])));
+        b      += r2i(eval (opa * pix(iter.src[2]) * pix(iter.src[3])));
+        a      += r2i(eval (opa * pix(iter.src[3])));
+      }
+      if (iter.is_data_end()) break;
+      iter.next_row();
+    }
+    break;
+  default:
+    g_print("Unsupported layer type.\n");
+  }
+
+  // convert integer to float outside the performance critical loop
+  *sum_weight += weight;
+  *sum_r += r;
+  *sum_g += g;
+  *sum_b += b;
+  *sum_a += a;
+};
+
+#if 0
+// Colorize: apply the source hue and saturation, retaining the target
+// brightness. Same thing as in the PDF spec addendum but with different Luma
+// coefficients. Colorize should be used at either 1.0 or 0.0, values in
+// between probably aren't very useful. This blend mode retains the target
+// alpha, and any pure whites and blacks in the target layer.
+
+#define MAX3(a, b, c) ((a)>(b)?MAX((a),(c)):MAX((b),(c)))
+#define MIN3(a, b, c) ((a)<(b)?MIN((a),(c)):MIN((b),(c)))
+
+/*
+// From ITU Rec. BT.601 (SDTV)
+static const float LUMA_RED_COEFF   = 0.3;
+static const float LUMA_GREEN_COEFF = 0.59;
+static const float LUMA_BLUE_COEFF  = 0.11;
+*/
+
+// From ITU Rec. BT.709 (HDTV and sRGB)
+static const uint16_t LUMA_RED_COEFF = 0.2126 * (1<<15);
+static const uint16_t LUMA_GREEN_COEFF = 0.7152 * (1<<15);
+static const uint16_t LUMA_BLUE_COEFF = 0.0722 * (1<<15);
+
+// See also http://en.wikipedia.org/wiki/YCbCr
+
+
+/* Returns the sRGB luminance of an RGB triple, expressed as scaled ints. */
+
+#define LUMA(r,g,b) \
+   ((r)*LUMA_RED_COEFF + (g)*LUMA_GREEN_COEFF + (b)*LUMA_BLUE_COEFF)
+
+
+/*
+ * Sets the output RGB triple's luminance to that of the input, retaining its
+ * colour. Inputs and outputs are scaled ints having factor 2**-15, and must
+ * not store premultiplied alpha.
+ */
+
+inline static void
+set_rgb16_lum_from_rgb16(const uint16_t topr,
+                         const uint16_t topg,
+                         const uint16_t topb,
+                         uint16_t *botr,
+                         uint16_t *botg,
+                         uint16_t *botb)
+{
+    // Spec: SetLum()
+    // Colours potentially can go out of band to both sides, hence the
+    // temporary representation inflation.
+    const uint16_t botlum = LUMA(*botr, *botg, *botb) / (1<<15);
+    const uint16_t toplum = LUMA(topr, topg, topb) / (1<<15);
+    const int16_t diff = botlum - toplum;
+    int32_t r = topr + diff;
+    int32_t g = topg + diff;
+    int32_t b = topb + diff;
+
+    // Spec: ClipColor()
+    // Clip out of band values
+    int32_t lum = LUMA(r, g, b) / (1<<15);
+    int32_t cmin = MIN3(r, g, b);
+    int32_t cmax = MAX3(r, g, b);
+    if (cmin < 0) {
+        r = lum + (((r - lum) * lum) / (lum - cmin));
+        g = lum + (((g - lum) * lum) / (lum - cmin));
+        b = lum + (((b - lum) * lum) / (lum - cmin));
+    }
+    if (cmax > (1<<15)) {
+        r = lum + (((r - lum) * ((1<<15)-lum)) / (cmax - lum));
+        g = lum + (((g - lum) * ((1<<15)-lum)) / (cmax - lum));
+        b = lum + (((b - lum) * ((1<<15)-lum)) / (cmax - lum));
+    }
+#ifdef HEAVY_DEBUG
+    assert((0 <= r) && (r <= (1<<15)));
+    assert((0 <= g) && (g <= (1<<15)));
+    assert((0 <= b) && (b <= (1<<15)));
+#endif
+
+    *botr = r;
+    *botg = g;
+    *botb = b;
+}
+
+
+// The method is an implementation of that described in the official Adobe "PDF
+// Blend Modes: Addendum" document, dated January 23, 2006; specifically it's
+// the "Color" nonseparable blend mode. We do however use different
+// coefficients for the Luma value.
+
+void
+draw_dab_pixels_BlendMode_Color (uint16_t *mask,
+                                 uint16_t *rgba, // b=bottom, premult
+                                 uint16_t color_r,  // }
+                                 uint16_t color_g,  // }-- a=top, !premult
+                                 uint16_t color_b,  // }
+                                 uint16_t opacity)
+{
+  while (1) {
+    for (; mask[0]; mask++, rgba+=4) {
+      // De-premult
+      uint16_t r, g, b;
+      const uint16_t a = rgba[3];
+      r = g = b = 0;
+      if (rgba[3] != 0) {
+        r = ((1<<15)*((uint32_t)rgba[0])) / a;
+        g = ((1<<15)*((uint32_t)rgba[1])) / a;
+        b = ((1<<15)*((uint32_t)rgba[2])) / a;
+      }
+
+      // Apply luminance
+      set_rgb16_lum_from_rgb16(color_r, color_g, color_b, &r, &g, &b);
+
+      // Re-premult
+      r = ((uint32_t) r) * a / (1<<15);
+      g = ((uint32_t) g) * a / (1<<15);
+      b = ((uint32_t) b) * a / (1<<15);
+
+      // And combine as normal.
+      uint32_t opa_a = mask[0] * opacity / (1<<15); // topAlpha
+      uint32_t opa_b = (1<<15) - opa_a; // bottomAlpha
+      rgba[0] = (opa_a*r + opa_b*rgba[0])/(1<<15);
+      rgba[1] = (opa_a*g + opa_b*rgba[1])/(1<<15);
+      rgba[2] = (opa_a*b + opa_b*rgba[2])/(1<<15);
+    }
+    if (!mask[1]) break;
+    rgba += mask[1];
+    mask += 2;
+  }
+};
+#endif
+
diff -Naur gimp-2.8.14/app/paint-funcs/paint-funcs.c gimp-2.8.14-new/app/paint-funcs/paint-funcs.c
--- gimp-2.8.14/app/paint-funcs/paint-funcs.c	2015-01-27 17:28:36.845833812 +0800
+++ gimp-2.8.14-new/app/paint-funcs/paint-funcs.c	2015-01-27 17:48:55.347751581 +0800
@@ -54,6 +54,7 @@
                                           alpha channel  */
   const guint   increase_opacity : 1; /*  layer mode can increase opacity */
   const guint   decrease_opacity : 1; /*  layer mode can decrease opacity */
+  const guint   reverse_source   : 1; /*  if true, src1 and src2 is swapped */
 };
 
 static const LayerMode layer_modes[] =
@@ -61,32 +62,36 @@
    * corresponding values in GimpLayerModeEffects.
    */
 {
-  { TRUE,  TRUE,  FALSE, },  /*  GIMP_NORMAL_MODE        */
-  { TRUE,  TRUE,  FALSE, },  /*  GIMP_DISSOLVE_MODE      */
-  { TRUE,  TRUE,  FALSE, },  /*  GIMP_BEHIND_MODE        */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_MULTIPLY_MODE      */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_SCREEN_MODE        */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_OVERLAY_MODE       */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_DIFFERENCE_MODE    */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_ADDITION_MODE      */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_SUBTRACT_MODE      */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_DARKEN_ONLY_MODE   */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_LIGHTEN_ONLY_MODE  */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_HUE_MODE           */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_SATURATION_MODE    */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_COLOR_MODE         */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_VALUE_MODE         */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_DIVIDE_MODE        */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_DODGE_MODE         */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_BURN_MODE          */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_HARDLIGHT_MODE     */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_SOFTLIGHT_MODE     */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_GRAIN_EXTRACT_MODE */
-  { FALSE, FALSE, FALSE, },  /*  GIMP_GRAIN_MERGE_MODE   */
-  { TRUE,  FALSE, TRUE,  },  /*  GIMP_COLOR_ERASE_MODE   */
-  { TRUE,  FALSE, TRUE,  },  /*  GIMP_ERASE_MODE         */
-  { TRUE,  TRUE,  TRUE,  },  /*  GIMP_REPLACE_MODE       */
-  { TRUE,  TRUE,  FALSE, }   /*  GIMP_ANTI_ERASE_MODE    */
+  { TRUE,  TRUE,  FALSE, FALSE, },  /*  GIMP_NORMAL_MODE        */
+  { TRUE,  TRUE,  FALSE, FALSE, },  /*  GIMP_DISSOLVE_MODE      */
+  { TRUE,  TRUE,  FALSE, FALSE, },  /*  GIMP_BEHIND_MODE        */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_MULTIPLY_MODE      */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_SCREEN_MODE        */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_OVERLAY_MODE       */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_DIFFERENCE_MODE    */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_ADDITION_MODE      */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_SUBTRACT_MODE      */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_DARKEN_ONLY_MODE   */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_LIGHTEN_ONLY_MODE  */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_HUE_MODE           */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_SATURATION_MODE    */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_COLOR_MODE         */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_VALUE_MODE         */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_DIVIDE_MODE        */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_DODGE_MODE         */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_BURN_MODE          */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_HARDLIGHT_MODE     */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_SOFTLIGHT_MODE     */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_GRAIN_EXTRACT_MODE */
+  { FALSE, FALSE, FALSE, FALSE, },  /*  GIMP_GRAIN_MERGE_MODE   */
+  { TRUE,  FALSE, TRUE,  FALSE, },  /*  GIMP_COLOR_ERASE_MODE   */
+  { TRUE,  FALSE, TRUE,  FALSE, },  /*  GIMP_ERASE_MODE         */
+  { TRUE,  TRUE,  TRUE,  FALSE, },  /*  GIMP_REPLACE_MODE       */
+  { TRUE,  TRUE,  FALSE, FALSE, },  /*  GIMP_ANTI_ERASE_MODE    */
+  { TRUE,  TRUE,  TRUE,  FALSE, },  /*  GIMP_SRC_IN_MODE        */
+  { TRUE,  TRUE,  TRUE,  TRUE,  },  /*  GIMP_DST_IN_MODE        */
+  { TRUE,  TRUE,  TRUE,  FALSE, },  /*  GIMP_SRC_OUT_MODE       */
+  { TRUE,  TRUE,  TRUE,  TRUE,  }   /*  GIMP_DST_OUT_MODE       */
 };
 
 
@@ -1947,16 +1952,23 @@
               guchar      *color,
               guchar       blend)
 {
-  const guchar *s = src->data;
-  guchar       *d = dest->data;
-  gint          h = src->h;
+  gpointer pr;
 
-  while (h --)
+  for (pr = pixel_regions_register (2, src, dest);
+       pr != NULL;
+       pr = pixel_regions_process (pr))
     {
-      blend_pixels (s, d, color, blend, src->w, src->bytes);
+      const guchar *s = src->data;
+      guchar       *d  = dest->data;
+      gint          h  = src->h;
 
-      s += src->rowstride;
-      d += dest->rowstride;
+      while (h --)
+        {
+          shade_pixels (s, d, color, blend, src->w, src->bytes);
+
+          s += src->rowstride;
+          d += dest->rowstride;
+        }
     }
 }
 
@@ -4108,17 +4120,24 @@
   gboolean              transparency_quickskip_possible;
   TileRowHint           hint;
 
-  /* use src2->bytes + 1 since DISSOLVE always needs a buffer with alpha */
-  buf = g_alloca (MAX (MAX (src1->w * src1->bytes,
-                            src2->w * (src2->bytes + 1)),
-                       dest->w * dest->bytes));
-
   opacity    = st->opacity;
   mode       = st->mode;
   affect     = st->affect;
   type       = st->type;
   data       = st->data;
 
+  if (layer_modes[mode].reverse_source) {
+	PixelRegion* tmp;
+	tmp  = src1;
+	src1 = src2;
+	src2 = tmp;
+  }
+
+  /* use src2->bytes + 1 since DISSOLVE always needs a buffer with alpha */
+  buf = g_alloca (MAX (MAX (src1->w * src1->bytes,
+                            src2->w * (src2->bytes + 1)),
+                       dest->w * dest->bytes));
+
   opacity_quickskip_possible = (st->opacity_quickskip_possible &&
                                 src2->tiles);
   transparency_quickskip_possible = (st->transparency_quickskip_possible &&
diff -Naur gimp-2.8.14/app/paint-funcs/paint-funcs-generic.h gimp-2.8.14-new/app/paint-funcs/paint-funcs-generic.h
--- gimp-2.8.14/app/paint-funcs/paint-funcs-generic.h	2015-01-27 17:28:36.846833812 +0800
+++ gimp-2.8.14-new/app/paint-funcs/paint-funcs-generic.h	2015-01-27 17:48:55.346751581 +0800
@@ -301,24 +301,56 @@
               const guchar *col,
               guchar        blend,
               guint         w,
-              guint         bytes,
-              gboolean      has_alpha)
+              guint         bytes)
 {
-  const guchar blend2 = (255 - blend);
-  const guint  alpha = (has_alpha) ? bytes - 1 : bytes;
-
-  while (w--)
+  if (HAS_ALPHA (bytes))
     {
-      guint b;
+      const guint blend1 = 255 - blend;
+      const guint blend2 = blend + 1;
+      const guint c      = bytes - 1;
+      const gint  a2 = blend2 * col[c];
+      gint  cola[MAX_CHANNELS];
+      guint       b;
+	  
+      for (b = 0; b < c; b++)
+	cola[b] = col[b] * a2;
+
+      while (w--)
+        {
+          const gint  a1 = blend1 * src[c];
+          const gint  a  = a1 + a2;
+
+          if (!a)
+            {
+              for (b = 0; b < bytes; b++)
+                dest[b] = 0;
+            }
+          else
+            {
+              for (b = 0; b < c; b++)
+                dest[b] =
+                  src[b] + (src[b] * a1 + cola[b] - a * src[b]) / a;
 
-      for (b = 0; b < alpha; b++)
-        dest[b] = (src[b] * blend2 + col[b] * blend) / 255;
+              dest[c] = a >> 8;
+            }
 
-      if (has_alpha)
-        dest[alpha] = src[alpha];  /* alpha channel */
+          src += bytes;
+          dest += bytes;
+        }
+    }
+  else
+    {
+      const guchar blend1 = 255 - blend;
 
-      src += bytes;
-      dest += bytes;
+      while (w--)
+        {
+          guint b;
+          for (b = 0; b < bytes; b++)
+            dest[b] =
+              (src[b] * blend1 + col[b] * blend) / 255;
+          src += bytes;
+          dest += bytes;
+        }
     }
 }
 
diff -Naur gimp-2.8.14/app/paint-funcs/paint-funcs.h gimp-2.8.14-new/app/paint-funcs/paint-funcs.h
--- gimp-2.8.14/app/paint-funcs/paint-funcs.h	2015-01-27 17:28:36.846833812 +0800
+++ gimp-2.8.14-new/app/paint-funcs/paint-funcs.h	2015-01-27 17:48:55.347751581 +0800
@@ -57,8 +57,7 @@
                              const guchar *color,
                              guchar        rblend,
                              guint         w,
-                             guint         bytes,
-                             gboolean      has_alpha);
+                             guint         bytes);
 
 void  extract_alpha_pixels  (const guchar *src,
                              const guchar *mask,
diff -Naur gimp-2.8.14/app/pdb/internal-procs.c gimp-2.8.14-new/app/pdb/internal-procs.c
--- gimp-2.8.14/app/pdb/internal-procs.c	2015-01-27 17:28:36.593833829 +0800
+++ gimp-2.8.14-new/app/pdb/internal-procs.c	2015-01-27 17:48:55.362751580 +0800
@@ -28,7 +28,7 @@
 #include "internal-procs.h"
 
 
-/* 663 procedures registered total */
+/* 666 procedures registered total */
 
 void
 internal_procs_init (GimpPDB *pdb)
@@ -85,4 +85,5 @@
   register_undo_procs (pdb);
   register_unit_procs (pdb);
   register_vectors_procs (pdb);
+  register_mypaint_brush_select_procs (pdb);
 }
diff -Naur gimp-2.8.14/app/pdb/internal-procs.h gimp-2.8.14-new/app/pdb/internal-procs.h
--- gimp-2.8.14/app/pdb/internal-procs.h	2015-01-27 17:28:36.590833829 +0800
+++ gimp-2.8.14-new/app/pdb/internal-procs.h	2015-01-27 17:48:55.363751580 +0800
@@ -20,59 +20,60 @@
 #ifndef __INTERNAL_PROCS_H__
 #define __INTERNAL_PROCS_H__
 
-void   internal_procs_init               (GimpPDB *pdb);
+void   internal_procs_init                 (GimpPDB *pdb);
 
 /* Forward declarations for registering PDB procs */
 
-void   register_brush_procs              (GimpPDB *pdb);
-void   register_brush_select_procs       (GimpPDB *pdb);
-void   register_brushes_procs            (GimpPDB *pdb);
-void   register_buffer_procs             (GimpPDB *pdb);
-void   register_channel_procs            (GimpPDB *pdb);
-void   register_color_procs              (GimpPDB *pdb);
-void   register_context_procs            (GimpPDB *pdb);
-void   register_convert_procs            (GimpPDB *pdb);
-void   register_display_procs            (GimpPDB *pdb);
-void   register_drawable_procs           (GimpPDB *pdb);
-void   register_drawable_transform_procs (GimpPDB *pdb);
-void   register_dynamics_procs           (GimpPDB *pdb);
-void   register_edit_procs               (GimpPDB *pdb);
-void   register_fileops_procs            (GimpPDB *pdb);
-void   register_floating_sel_procs       (GimpPDB *pdb);
-void   register_font_select_procs        (GimpPDB *pdb);
-void   register_fonts_procs              (GimpPDB *pdb);
-void   register_gimp_procs               (GimpPDB *pdb);
-void   register_gimprc_procs             (GimpPDB *pdb);
-void   register_gradient_procs           (GimpPDB *pdb);
-void   register_gradient_select_procs    (GimpPDB *pdb);
-void   register_gradients_procs          (GimpPDB *pdb);
-void   register_grid_procs               (GimpPDB *pdb);
-void   register_guides_procs             (GimpPDB *pdb);
-void   register_help_procs               (GimpPDB *pdb);
-void   register_image_procs              (GimpPDB *pdb);
-void   register_image_select_procs       (GimpPDB *pdb);
-void   register_item_procs               (GimpPDB *pdb);
-void   register_item_transform_procs     (GimpPDB *pdb);
-void   register_layer_procs              (GimpPDB *pdb);
-void   register_message_procs            (GimpPDB *pdb);
-void   register_paint_tools_procs        (GimpPDB *pdb);
-void   register_palette_procs            (GimpPDB *pdb);
-void   register_palette_select_procs     (GimpPDB *pdb);
-void   register_palettes_procs           (GimpPDB *pdb);
-void   register_paths_procs              (GimpPDB *pdb);
-void   register_pattern_procs            (GimpPDB *pdb);
-void   register_pattern_select_procs     (GimpPDB *pdb);
-void   register_patterns_procs           (GimpPDB *pdb);
-void   register_plug_in_procs            (GimpPDB *pdb);
-void   register_procedural_db_procs      (GimpPDB *pdb);
-void   register_progress_procs           (GimpPDB *pdb);
-void   register_selection_procs          (GimpPDB *pdb);
-void   register_selection_tools_procs    (GimpPDB *pdb);
-void   register_text_layer_procs         (GimpPDB *pdb);
-void   register_text_tool_procs          (GimpPDB *pdb);
-void   register_transform_tools_procs    (GimpPDB *pdb);
-void   register_undo_procs               (GimpPDB *pdb);
-void   register_unit_procs               (GimpPDB *pdb);
-void   register_vectors_procs            (GimpPDB *pdb);
+void   register_brush_procs                (GimpPDB *pdb);
+void   register_brush_select_procs         (GimpPDB *pdb);
+void   register_brushes_procs              (GimpPDB *pdb);
+void   register_buffer_procs               (GimpPDB *pdb);
+void   register_channel_procs              (GimpPDB *pdb);
+void   register_color_procs                (GimpPDB *pdb);
+void   register_context_procs              (GimpPDB *pdb);
+void   register_convert_procs              (GimpPDB *pdb);
+void   register_display_procs              (GimpPDB *pdb);
+void   register_drawable_procs             (GimpPDB *pdb);
+void   register_drawable_transform_procs   (GimpPDB *pdb);
+void   register_dynamics_procs             (GimpPDB *pdb);
+void   register_edit_procs                 (GimpPDB *pdb);
+void   register_fileops_procs              (GimpPDB *pdb);
+void   register_floating_sel_procs         (GimpPDB *pdb);
+void   register_font_select_procs          (GimpPDB *pdb);
+void   register_fonts_procs                (GimpPDB *pdb);
+void   register_gimp_procs                 (GimpPDB *pdb);
+void   register_gimprc_procs               (GimpPDB *pdb);
+void   register_gradient_procs             (GimpPDB *pdb);
+void   register_gradient_select_procs      (GimpPDB *pdb);
+void   register_gradients_procs            (GimpPDB *pdb);
+void   register_grid_procs                 (GimpPDB *pdb);
+void   register_guides_procs               (GimpPDB *pdb);
+void   register_help_procs                 (GimpPDB *pdb);
+void   register_image_procs                (GimpPDB *pdb);
+void   register_image_select_procs         (GimpPDB *pdb);
+void   register_item_procs                 (GimpPDB *pdb);
+void   register_item_transform_procs       (GimpPDB *pdb);
+void   register_layer_procs                (GimpPDB *pdb);
+void   register_message_procs              (GimpPDB *pdb);
+void   register_paint_tools_procs          (GimpPDB *pdb);
+void   register_palette_procs              (GimpPDB *pdb);
+void   register_palette_select_procs       (GimpPDB *pdb);
+void   register_palettes_procs             (GimpPDB *pdb);
+void   register_paths_procs                (GimpPDB *pdb);
+void   register_pattern_procs              (GimpPDB *pdb);
+void   register_pattern_select_procs       (GimpPDB *pdb);
+void   register_patterns_procs             (GimpPDB *pdb);
+void   register_plug_in_procs              (GimpPDB *pdb);
+void   register_procedural_db_procs        (GimpPDB *pdb);
+void   register_progress_procs             (GimpPDB *pdb);
+void   register_selection_procs            (GimpPDB *pdb);
+void   register_selection_tools_procs      (GimpPDB *pdb);
+void   register_text_layer_procs           (GimpPDB *pdb);
+void   register_text_tool_procs            (GimpPDB *pdb);
+void   register_transform_tools_procs      (GimpPDB *pdb);
+void   register_undo_procs                 (GimpPDB *pdb);
+void   register_unit_procs                 (GimpPDB *pdb);
+void   register_vectors_procs              (GimpPDB *pdb);
+void   register_mypaint_brush_select_procs (GimpPDB *pdb);
 
 #endif /* __INTERNAL_PROCS_H__ */
diff -Naur gimp-2.8.14/app/pdb/Makefile.am gimp-2.8.14-new/app/pdb/Makefile.am
--- gimp-2.8.14/app/pdb/Makefile.am	2015-01-27 17:28:36.594833829 +0800
+++ gimp-2.8.14-new/app/pdb/Makefile.am	2015-01-27 17:48:55.362751580 +0800
@@ -38,6 +38,7 @@
 	internal-procs.h		\
 	brush-cmds.c			\
 	brush-select-cmds.c		\
+	mypaint-brush-select-cmds.c	\
 	brushes-cmds.c			\
 	buffer-cmds.c			\
 	channel-cmds.c			\
diff -Naur gimp-2.8.14/app/pdb/mypaint-brush-select-cmds.c gimp-2.8.14-new/app/pdb/mypaint-brush-select-cmds.c
--- gimp-2.8.14/app/pdb/mypaint-brush-select-cmds.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/pdb/mypaint-brush-select-cmds.c	2015-01-27 17:48:55.363751580 +0800
@@ -0,0 +1,219 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* NOTE: This file is auto-generated by pdbgen.pl. */
+
+#include "config.h"
+
+#include <gegl.h>
+
+#include "pdb-types.h"
+
+#include "core/gimp.h"
+#include "core/gimpdatafactory.h"
+#include "core/gimpparamspecs.h"
+
+#include "gimppdb.h"
+#include "gimpprocedure.h"
+#include "internal-procs.h"
+
+
+static GValueArray *
+mypaint_brushes_popup_invoker (GimpProcedure      *procedure,
+                               Gimp               *gimp,
+                               GimpContext        *context,
+                               GimpProgress       *progress,
+                               const GValueArray  *args,
+                               GError            **error)
+{
+  gboolean success = TRUE;
+  const gchar *mypaint_brush_callback;
+  const gchar *popup_title;
+  const gchar *initial_brush;
+
+  mypaint_brush_callback = g_value_get_string (&args->values[0]);
+  popup_title = g_value_get_string (&args->values[1]);
+  initial_brush = g_value_get_string (&args->values[2]);
+
+  if (success)
+    {
+      if (gimp->no_interface ||
+          ! gimp_pdb_lookup_procedure (gimp->pdb, mypaint_brush_callback) ||
+          ! gimp_pdb_dialog_new (gimp, context, progress,
+                                 gimp_data_factory_get_container (gimp->mypaint_brush_factory),
+                                 popup_title, mypaint_brush_callback, initial_brush,
+                                 NULL))
+        success = FALSE;
+    }
+
+  return gimp_procedure_get_return_values (procedure, success,
+                                           error ? *error : NULL);
+}
+
+static GValueArray *
+mypaint_brushes_close_popup_invoker (GimpProcedure      *procedure,
+                                     Gimp               *gimp,
+                                     GimpContext        *context,
+                                     GimpProgress       *progress,
+                                     const GValueArray  *args,
+                                     GError            **error)
+{
+  gboolean success = TRUE;
+  const gchar *mypaint_brush_callback;
+
+  mypaint_brush_callback = g_value_get_string (&args->values[0]);
+
+  if (success)
+    {
+      if (gimp->no_interface ||
+          ! gimp_pdb_lookup_procedure (gimp->pdb, mypaint_brush_callback) ||
+          ! gimp_pdb_dialog_close (gimp, gimp_data_factory_get_container (gimp->mypaint_brush_factory),
+                                   mypaint_brush_callback))
+        success = FALSE;
+    }
+
+  return gimp_procedure_get_return_values (procedure, success,
+                                           error ? *error : NULL);
+}
+
+static GValueArray *
+mypaint_brushes_set_popup_invoker (GimpProcedure      *procedure,
+                                   Gimp               *gimp,
+                                   GimpContext        *context,
+                                   GimpProgress       *progress,
+                                   const GValueArray  *args,
+                                   GError            **error)
+{
+  gboolean success = TRUE;
+  const gchar *mypaint_brush_callback;
+  const gchar *mypaint_brush_name;
+
+  mypaint_brush_callback = g_value_get_string (&args->values[0]);
+  mypaint_brush_name = g_value_get_string (&args->values[1]);
+
+  if (success)
+    {
+      if (gimp->no_interface ||
+          ! gimp_pdb_lookup_procedure (gimp->pdb, mypaint_brush_callback) ||
+          ! gimp_pdb_dialog_set (gimp, gimp_data_factory_get_container (gimp->mypaint_brush_factory),
+                                 mypaint_brush_callback, mypaint_brush_name,
+                                 NULL))
+        success = FALSE;
+    }
+
+  return gimp_procedure_get_return_values (procedure, success,
+                                           error ? *error : NULL);
+}
+
+void
+register_mypaint_brush_select_procs (GimpPDB *pdb)
+{
+  GimpProcedure *procedure;
+
+  /*
+   * gimp-mypaint-brushes-popup
+   */
+  procedure = gimp_procedure_new (mypaint_brushes_popup_invoker);
+  gimp_object_set_static_name (GIMP_OBJECT (procedure),
+                               "gimp-mypaint-brushes-popup");
+  gimp_procedure_set_static_strings (procedure,
+                                     "gimp-mypaint-brushes-popup",
+                                     "Invokes the Gimp mypaint brush selection.",
+                                     "This procedure opens the mypaint brush selection dialog.",
+                                     "Andy Thomas",
+                                     "Andy Thomas",
+                                     "2012",
+                                     NULL);
+  gimp_procedure_add_argument (procedure,
+                               gimp_param_spec_string ("mypaint-brush-callback",
+                                                       "mypaint brush callback",
+                                                       "The callback PDB proc to call when mypaint brush selection is made",
+                                                       FALSE, FALSE, TRUE,
+                                                       NULL,
+                                                       GIMP_PARAM_READWRITE));
+  gimp_procedure_add_argument (procedure,
+                               gimp_param_spec_string ("popup-title",
+                                                       "popup title",
+                                                       "Title of the mypaint brush selection dialog",
+                                                       FALSE, FALSE, FALSE,
+                                                       NULL,
+                                                       GIMP_PARAM_READWRITE));
+  gimp_procedure_add_argument (procedure,
+                               gimp_param_spec_string ("initial-brush",
+                                                       "initial brush",
+                                                       "The name of the mypaint brush to set as the first selected",
+                                                       FALSE, TRUE, FALSE,
+                                                       NULL,
+                                                       GIMP_PARAM_READWRITE));
+  gimp_pdb_register_procedure (pdb, procedure);
+  g_object_unref (procedure);
+
+  /*
+   * gimp-mypaint-brushes-close-popup
+   */
+  procedure = gimp_procedure_new (mypaint_brushes_close_popup_invoker);
+  gimp_object_set_static_name (GIMP_OBJECT (procedure),
+                               "gimp-mypaint-brushes-close-popup");
+  gimp_procedure_set_static_strings (procedure,
+                                     "gimp-mypaint-brushes-close-popup",
+                                     "Close the mypaint brush selection dialog.",
+                                     "This procedure closes an opened brush selection dialog.",
+                                     "Andy Thomas",
+                                     "Andy Thomas",
+                                     "2012",
+                                     NULL);
+  gimp_procedure_add_argument (procedure,
+                               gimp_param_spec_string ("mypaint-brush-callback",
+                                                       "mypaint brush callback",
+                                                       "The name of the callback registered for this pop-up",
+                                                       FALSE, FALSE, TRUE,
+                                                       NULL,
+                                                       GIMP_PARAM_READWRITE));
+  gimp_pdb_register_procedure (pdb, procedure);
+  g_object_unref (procedure);
+
+  /*
+   * gimp-mypaint-brushes-set-popup
+   */
+  procedure = gimp_procedure_new (mypaint_brushes_set_popup_invoker);
+  gimp_object_set_static_name (GIMP_OBJECT (procedure),
+                               "gimp-mypaint-brushes-set-popup");
+  gimp_procedure_set_static_strings (procedure,
+                                     "gimp-mypaint-brushes-set-popup",
+                                     "Sets the current mypaint brush in a mypaint brush selection dialog.",
+                                     "Sets the current mypaint brush in a mypaint brush selection dialog.",
+                                     "Andy Thomas",
+                                     "Andy Thomas",
+                                     "2012",
+                                     NULL);
+  gimp_procedure_add_argument (procedure,
+                               gimp_param_spec_string ("mypaint-brush-callback",
+                                                       "mypaint brush callback",
+                                                       "The name of the callback registered for this pop-up",
+                                                       FALSE, FALSE, TRUE,
+                                                       NULL,
+                                                       GIMP_PARAM_READWRITE));
+  gimp_procedure_add_argument (procedure,
+                               gimp_param_spec_string ("mypaint-brush-name",
+                                                       "mypaint brush name",
+                                                       "The name of the brush to set as selected",
+                                                       FALSE, FALSE, FALSE,
+                                                       NULL,
+                                                       GIMP_PARAM_READWRITE));
+  gimp_pdb_register_procedure (pdb, procedure);
+  g_object_unref (procedure);
+}
diff -Naur gimp-2.8.14/app/tools/gimpairbrushtool.c gimp-2.8.14-new/app/tools/gimpairbrushtool.c
--- gimp-2.8.14/app/tools/gimpairbrushtool.c	2015-01-27 17:28:36.905833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpairbrushtool.c	2015-01-27 17:48:55.364751580 +0800
@@ -29,13 +29,16 @@
 #include "widgets/gimppropwidgets.h"
 
 #include "gimpairbrushtool.h"
+#include "gimptooloptions-gui.h" /* GimpToolOptionsTableIncrement */
 #include "gimppaintoptions-gui.h"
 #include "gimptoolcontrol.h"
 
 #include "gimp-intl.h"
 
 
-static GtkWidget * gimp_airbrush_options_gui (GimpToolOptions *tool_options);
+static GtkWidget * gimp_airbrush_options_gui (GimpToolOptions  *tool_options);
+static GtkWidget * gimp_airbrush_options_gui_horizontal (GimpToolOptions  *tool_options);
+static GtkWidget * gimp_airbrush_options_gui_full (GimpToolOptions  *tool_options, gboolean horizontal);
 
 
 G_DEFINE_TYPE (GimpAirbrushTool, gimp_airbrush_tool, GIMP_TYPE_PAINTBRUSH_TOOL)
@@ -48,6 +51,7 @@
   (* callback) (GIMP_TYPE_AIRBRUSH_TOOL,
                 GIMP_TYPE_AIRBRUSH_OPTIONS,
                 gimp_airbrush_options_gui,
+                gimp_airbrush_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK |
                 GIMP_CONTEXT_GRADIENT_MASK,
                 "gimp-airbrush-tool",
@@ -78,10 +82,26 @@
 static GtkWidget *
 gimp_airbrush_options_gui (GimpToolOptions *tool_options)
 {
+  return gimp_airbrush_options_gui_full (tool_options, FALSE);
+}
+
+static GtkWidget *
+gimp_airbrush_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_airbrush_options_gui_full (tool_options, TRUE);
+}
+
+static GtkWidget *
+gimp_airbrush_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
+{
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_paint_options_gui (tool_options);
-  GtkWidget *button;
+  GList     *children;
+
+  GtkWidget *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
+//  GtkWidget *table;
   GtkWidget *scale;
+  GtkWidget *button;
+  GimpToolOptionsTableIncrement inc = gimp_tool_options_table_increment (horizontal);
 
   button = gimp_prop_check_button_new (config, "motion-only", _("Motion only"));
   gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
@@ -99,5 +119,32 @@
   gtk_box_pack_start (GTK_BOX (vbox), scale, FALSE, FALSE, 0);
   gtk_widget_show (scale);
 
+  children = gtk_container_get_children (GTK_CONTAINER (vbox));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
+#if 0
+  gtk_box_pack_start (GTK_BOX (vbox), table, FALSE, FALSE, 0);
+  gtk_widget_show (table);
+
+  table = gimp_tool_options_table (2, horizontal);
+  gtk_table_set_col_spacing (GTK_TABLE (table), 0, 2);
+
+  gimp_tool_options_scale_entry_new (config, "rate",
+                                     GTK_TABLE (table), 
+                                     gimp_tool_options_table_increment_get_col (&inc), 
+                                     gimp_tool_options_table_increment_get_row (&inc),
+                                     _("Rate:"),
+                                     1.0, 1.0, 1,
+                                     FALSE, 0.0, 0.0, FALSE, horizontal);
+  gimp_tool_options_table_increment_next (&inc);
+
+  gimp_tool_options_scale_entry_new (config, "flow",
+                                     GTK_TABLE (table),
+                                     gimp_tool_options_table_increment_get_col (&inc), 
+                                     gimp_tool_options_table_increment_get_row (&inc),
+                                     _("Flow:"),
+                                     1.0, 1.0, 1,
+                                     FALSE, 0.0, 0.0, FALSE, horizontal);
+#endif
   return vbox;
 }
diff -Naur gimp-2.8.14/app/tools/gimpaligntool.c gimp-2.8.14-new/app/tools/gimpaligntool.c
--- gimp-2.8.14/app/tools/gimpaligntool.c	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpaligntool.c	2015-01-27 17:48:55.365751580 +0800
@@ -119,6 +119,7 @@
   (* callback) (GIMP_TYPE_ALIGN_TOOL,
                 GIMP_TYPE_ALIGN_OPTIONS,
                 gimp_align_options_gui,
+                NULL,
                 0,
                 "gimp-align-tool",
                 _("Align"),
diff -Naur gimp-2.8.14/app/tools/gimpblendoptions.c gimp-2.8.14-new/app/tools/gimpblendoptions.c
--- gimp-2.8.14/app/tools/gimpblendoptions.c	2015-01-27 17:28:36.902833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpblendoptions.c	2015-01-27 17:48:55.365751580 +0800
@@ -25,12 +25,14 @@
 #include "tools-types.h"
 
 #include "core/gimpdatafactory.h"
+#include "core/gimptoolinfo.h"
 
 #include "widgets/gimppropwidgets.h"
 #include "widgets/gimpviewablebox.h"
 
 #include "gimpblendoptions.h"
 #include "gimppaintoptions-gui.h"
+#include "gimptooloptions-gui.h"
 
 #include "gimp-intl.h"
 
@@ -61,6 +63,8 @@
                                                   GParamSpec       *pspec,
                                                   GtkWidget        *repeat_combo);
 
+static GtkWidget * gimp_blend_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal);
+static void supersample_options_create_view (GtkWidget *button, GtkWidget **result, GObject *config);
 
 G_DEFINE_TYPE (GimpBlendOptions, gimp_blend_options, GIMP_TYPE_PAINT_OPTIONS)
 
@@ -197,14 +201,28 @@
 GtkWidget *
 gimp_blend_options_gui (GimpToolOptions *tool_options)
 {
+  return gimp_blend_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_blend_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_blend_options_gui_full (tool_options, TRUE);
+}
+
+static GtkWidget *
+gimp_blend_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
+{
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_paint_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget *table;
   GtkWidget *vbox2;
   GtkWidget *frame;
   GtkWidget *scale;
   GtkWidget *combo;
   GtkWidget *button;
+  GType      tool_type = tool_options->tool_info->tool_type;
+  GimpToolOptionsTableIncrement inc = gimp_tool_options_table_increment (horizontal);  
 
   /*  the gradient  */
   button = gimp_prop_gradient_box_new (NULL, GIMP_CONTEXT (tool_options),
@@ -216,27 +234,43 @@
   gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
   gtk_widget_show (button);
 
-  table = gtk_table_new (3, 2, FALSE);
+  table = gimp_tool_options_table (2, horizontal);
   gtk_table_set_col_spacings (GTK_TABLE (table), 2);
   gtk_table_set_row_spacings (GTK_TABLE (table), 2);
   gtk_box_pack_start (GTK_BOX (vbox), table, FALSE, FALSE, 0);
   gtk_widget_show (table);
+  
+  gimp_tool_options_table_increment_next (&inc);
+  gimp_tool_options_table_increment_next (&inc);
+
+  gimp_table_attach_aligned (GTK_TABLE (table),
+                             gimp_tool_options_table_increment_get_col (&inc),
+                             gimp_tool_options_table_increment_get_row (&inc),
+                             _("Gradient:"), 0.0, 0.5,
+                             button, 2, TRUE);
+  gimp_tool_options_table_increment_next (&inc);
 
   /*  the gradient type menu  */
   combo = gimp_prop_enum_combo_box_new (config, "gradient-type", 0, 0);
   g_object_set (combo, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
   gimp_enum_combo_box_set_stock_prefix (GIMP_ENUM_COMBO_BOX (combo),
                                         "gimp-gradient");
-  gimp_table_attach_aligned (GTK_TABLE (table), 0, 0,
+  gimp_table_attach_aligned (GTK_TABLE (table),
+                             gimp_tool_options_table_increment_get_col (&inc),
+                             gimp_tool_options_table_increment_get_row (&inc),
                              _("Shape:"), 0.0, 0.5,
                              combo, 2, FALSE);
+  gimp_tool_options_table_increment_next (&inc);
 
   /*  the repeat option  */
   combo = gimp_prop_enum_combo_box_new (config, "gradient-repeat", 0, 0);
   g_object_set (combo, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
-  gimp_table_attach_aligned (GTK_TABLE (table), 0, 1,
+  gimp_table_attach_aligned (GTK_TABLE (table),
+                             gimp_tool_options_table_increment_get_col (&inc),
+                             gimp_tool_options_table_increment_get_row (&inc),
                              _("Repeat:"), 0.0, 0.5,
                              combo, 2, FALSE);
+  gimp_tool_options_table_increment_next (&inc);
 
   g_signal_connect (config, "notify::gradient-type",
                     G_CALLBACK (blend_options_gradient_type_notify),
@@ -260,9 +294,34 @@
   frame = gimp_prop_expanding_frame_new (config, "supersample",
                                          _("Adaptive supersampling"),
                                          vbox2, NULL);
+  frame = 
+    gimp_tool_options_toggle_gui_with_popup (config, tool_type,
+                                             "supersample", 
+                                             _("Adaptive"), _("Adaptive supersampling"),
+                                             horizontal, supersample_options_create_view);
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
   gtk_widget_show (frame);
 
+  if (horizontal)
+    {
+      GList *children;
+      children = gtk_container_get_children (GTK_CONTAINER (vbox));
+      gimp_tool_options_setup_popup_layout (children, FALSE);
+    }
+
+  return vbox;
+}
+
+static void
+supersample_options_create_view (GtkWidget *button, GtkWidget **result, GObject *config)
+{
+  GimpToolOptionsTableIncrement inc = gimp_tool_options_table_increment (FALSE);
+//  GtkWidget *table = gtk_table_new (3, 3, FALSE);
+  GList     *children;
+  GtkWidget *vbox2 = gtk_vbox_new (FALSE, 2);
+  GtkWidget *scale;
+
+
   /*  max depth scale  */
   scale = gimp_prop_spin_scale_new (config, "supersample-depth",
                                     _("Max depth"),
@@ -277,7 +336,10 @@
   gtk_box_pack_start (GTK_BOX (vbox2), scale, FALSE, FALSE, 0);
   gtk_widget_show (scale);
 
-  return vbox;
+  children = gtk_container_get_children (GTK_CONTAINER (vbox2));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
+  *result = vbox2;
 }
 
 static void
diff -Naur gimp-2.8.14/app/tools/gimpblendoptions.h gimp-2.8.14-new/app/tools/gimpblendoptions.h
--- gimp-2.8.14/app/tools/gimpblendoptions.h	2015-01-27 17:28:36.899833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpblendoptions.h	2015-01-27 17:48:55.366751580 +0800
@@ -50,7 +50,8 @@
 
 GType       gimp_blend_options_get_type (void) G_GNUC_CONST;
 
-GtkWidget * gimp_blend_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_blend_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_blend_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_BLEND_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpblendtool.c gimp-2.8.14-new/app/tools/gimpblendtool.c
--- gimp-2.8.14/app/tools/gimpblendtool.c	2015-01-27 17:28:36.892833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpblendtool.c	2015-01-27 17:48:55.366751580 +0800
@@ -100,6 +100,7 @@
   (* callback) (GIMP_TYPE_BLEND_TOOL,
                 GIMP_TYPE_BLEND_OPTIONS,
                 gimp_blend_options_gui,
+                gimp_blend_options_gui_horizontal,
                 GIMP_CONTEXT_FOREGROUND_MASK |
                 GIMP_CONTEXT_BACKGROUND_MASK |
                 GIMP_CONTEXT_OPACITY_MASK    |
diff -Naur gimp-2.8.14/app/tools/gimpbrightnesscontrasttool.c gimp-2.8.14-new/app/tools/gimpbrightnesscontrasttool.c
--- gimp-2.8.14/app/tools/gimpbrightnesscontrasttool.c	2015-01-27 17:28:36.890833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpbrightnesscontrasttool.c	2015-01-27 17:48:55.366751580 +0800
@@ -105,7 +105,7 @@
                                         gpointer                  data)
 {
   (* callback) (GIMP_TYPE_BRIGHTNESS_CONTRAST_TOOL,
-                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL,
+                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL, NULL,
                 0,
                 "gimp-brightness-contrast-tool",
                 _("Brightness-Contrast"),
diff -Naur gimp-2.8.14/app/tools/gimpbrushoptions-gui.c gimp-2.8.14-new/app/tools/gimpbrushoptions-gui.c
--- gimp-2.8.14/app/tools/gimpbrushoptions-gui.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpbrushoptions-gui.c	2015-01-27 17:48:55.367751580 +0800
@@ -0,0 +1,772 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <glib-object.h>
+#include <glib/gprintf.h>
+#include <gtk/gtk.h>
+
+#include "tools-types.h"
+
+#include "base/temp-buf.h"
+
+#include "libgimpmath/gimpmath.h"
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "core/gimp.h"
+#include "core/gimpcontainer.h"
+#include "core/gimpcontext.h"
+#include "core/gimptooloptions.h"
+#include "core/gimpdatafactory.h"
+#include "core/gimpbrush.h"
+#include "core/gimpbrushgenerated.h"
+
+#include "widgets/gimpview.h"
+#include "widgets/gimpviewrenderer.h"
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimpcontainereditor.h"
+#include "widgets/gimpcontainerview.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpcontainerbox.h"
+
+#include "gimptooloptions-gui.h"
+#include "gimpbrushoptions-gui.h"
+
+#include "gimp-intl.h"
+
+
+#define BRUSH_VIEW_SIZE 256
+
+static void spacing_changed (GimpBrush *brush, gpointer   data);
+static void spacing_update (GtkAdjustment *adjustment, gpointer data);
+static void update_brush (GtkAdjustment *adjustment, gpointer data);
+static void update_brush_shape (GtkWidget *widget, gpointer  *data);
+static void notify_brush (GimpBrushGenerated *brush, GParamSpec *pspec, gpointer data);
+static void brush_changed (GimpContext *context, GimpData *brush_data, gpointer data);
+
+/*  private functions  */
+typedef struct _BrushDialogPrivate BrushDialogPrivate;
+struct _BrushDialogPrivate
+{
+  GHashTable  *adj_hash;
+  GtkAdjustment *adj;
+  GtkWidget     *shape_group;
+  GtkWidget     *preview;
+  GtkWidget     *brush_frame;
+  GimpContainer *container;
+  GimpContext   *context;
+  gint           spacing_changed_handler_id;
+};
+
+static BrushDialogPrivate *
+brush_dialog_private_new (void)
+{
+  BrushDialogPrivate *p = g_new0 (BrushDialogPrivate, 1);
+  p->adj_hash = g_hash_table_new (g_str_hash, g_str_equal);
+  return p;
+}
+
+static void 
+brush_dialog_private_set_adjustment (BrushDialogPrivate *p, GtkAdjustment *adj)
+{
+  p->adj = adj;
+}
+
+static void 
+brush_dialog_private_set_shape_group (BrushDialogPrivate *p, GtkWidget *shape_group)
+{
+  p->shape_group = shape_group;
+}
+
+static void 
+brush_dialog_private_set_preview (BrushDialogPrivate *p, GtkWidget *preview)
+{
+  p->preview = preview;
+}
+
+static void 
+brush_dialog_private_set_container (BrushDialogPrivate *p, GimpContainer *container)
+{
+  p->container = container;
+  g_object_ref (G_OBJECT (p->container));
+}
+
+static void 
+brush_dialog_private_set_context (BrushDialogPrivate *p, GimpContext *context)
+{
+  p->context = context;
+  g_object_ref (G_OBJECT (p->context));
+}
+
+static void
+brush_dialog_private_destroy (gpointer data)
+{
+  BrushDialogPrivate *p = (BrushDialogPrivate*)data;
+
+  if (p->spacing_changed_handler_id)
+    {
+      gimp_container_remove_handler (p->container,
+                                     p->spacing_changed_handler_id);
+      p->spacing_changed_handler_id = 0;
+    }
+
+  p->shape_group = NULL;
+  p->adj         = NULL;
+  p->preview     = NULL;
+  
+  if (p->container)
+    {
+      g_object_unref (G_OBJECT (p->container));
+      p->container = NULL;
+    }
+
+  if (p->context)
+    {
+      g_object_unref (G_OBJECT (p->context));
+      p->context = NULL;
+    }
+    
+  if (p->adj_hash)
+    {
+      g_hash_table_unref (p->adj_hash);
+    }
+
+  if (p)
+    g_free (p);
+}
+
+static void
+brush_changed (GimpContext    *context,
+               GimpData       *brush_data,
+               gpointer        data)
+{
+  BrushDialogPrivate      *p            = (BrushDialogPrivate*)data;
+  GimpBrush               *brush        = GIMP_BRUSH (brush_data);
+  GimpBrushGeneratedShape  shape        = GIMP_BRUSH_GENERATED_CIRCLE;
+  gdouble                  radius       = 0.0;
+  gint                     spikes       = 2;
+  gdouble                  hardness     = 0.0;
+  gdouble                  ratio        = 0.0;
+  gdouble                  angle        = 0.0;
+  gdouble                  spacing      = 0.0;
+  gboolean                 editable;
+
+  g_return_if_fail (p);
+
+  if (brush) /* BUG: old brush must be used, but "brush" is new brush object ... */
+    g_signal_handlers_disconnect_by_func (brush, notify_brush, p);
+
+  if (brush)
+    g_signal_connect (brush, "notify",
+                      G_CALLBACK (notify_brush),
+                      p);
+
+  if (p->preview)
+    gimp_view_set_viewable (GIMP_VIEW (p->preview), GIMP_VIEWABLE (brush_data));
+    
+  if (brush_data && GIMP_IS_BRUSH_GENERATED (brush_data))
+    {
+      GimpBrushGenerated *brush_generated = GIMP_BRUSH_GENERATED (brush);
+
+      shape    = gimp_brush_generated_get_shape        (brush_generated);
+      radius   = gimp_brush_generated_get_radius       (brush_generated);
+      spikes   = gimp_brush_generated_get_spikes       (brush_generated);
+      hardness = gimp_brush_generated_get_hardness     (brush_generated);
+      ratio    = gimp_brush_generated_get_aspect_ratio (brush_generated);
+      angle    = gimp_brush_generated_get_angle        (brush_generated);
+    }
+
+  spacing  = gimp_brush_get_spacing                (GIMP_BRUSH (brush));
+
+  editable = brush_data && gimp_data_is_writable (brush_data);
+  gtk_widget_set_sensitive (p->brush_frame, editable);
+
+  gimp_int_radio_group_set_active (GTK_RADIO_BUTTON (p->shape_group),
+                                   shape);
+  gtk_adjustment_set_value (GTK_ADJUSTMENT (g_hash_table_lookup (p->adj_hash, "radius")), radius);
+  gtk_adjustment_set_value (GTK_ADJUSTMENT (g_hash_table_lookup (p->adj_hash, "spikes")), spikes);
+  gtk_adjustment_set_value (GTK_ADJUSTMENT (g_hash_table_lookup (p->adj_hash, "hardness")), hardness);
+  gtk_adjustment_set_value (GTK_ADJUSTMENT (g_hash_table_lookup (p->adj_hash, "aspect-ratio")), ratio);
+  gtk_adjustment_set_value (GTK_ADJUSTMENT (g_hash_table_lookup (p->adj_hash, "angle")),        angle);
+  gtk_adjustment_set_value (GTK_ADJUSTMENT (g_hash_table_lookup (p->adj_hash, "spacing")),      spacing);
+
+  if (brush && p->context)
+    {
+      gdouble value = MAX (brush->mask->width, brush->mask->height);
+      g_object_set (p->context, "brush-size", value, NULL);
+    }
+}
+
+static void
+spacing_changed (GimpBrush *brush,
+                 gpointer   data)
+{
+  BrushDialogPrivate  *p      = (BrushDialogPrivate*)data;
+  GimpContext         *context;
+
+  context = p->context;
+  g_print ("spacing_changed\n");
+  
+  g_return_if_fail (G_IS_OBJECT (p->adj));
+  g_return_if_fail (G_IS_OBJECT (context));
+  g_return_if_fail (GIMP_IS_BRUSH (brush));
+
+
+  if (brush == gimp_context_get_brush (context))
+    {
+      g_signal_handlers_block_matched (G_OBJECT (p->adj),
+                                       G_SIGNAL_MATCH_DETAIL,
+                                       0, g_quark_from_static_string ("value-changed"), NULL, NULL, NULL);
+      gtk_adjustment_set_value (p->adj,
+                                gimp_brush_get_spacing (brush));
+
+      g_signal_handlers_unblock_matched (G_OBJECT (p->adj),
+                                         G_SIGNAL_MATCH_DETAIL,
+                                         0, g_quark_from_static_string ("value-changed"), NULL, NULL, NULL);
+    }
+}
+
+
+
+static void
+spacing_update (GtkAdjustment *adjustment,
+                gpointer       data)
+{
+  BrushDialogPrivate  *p      = (BrushDialogPrivate*)data;
+  GimpContext         *context;
+  GimpBrush           *brush;
+  
+  g_print ("spacing_update\n");
+
+  context = p->context;
+
+  g_return_if_fail (G_IS_OBJECT (p->adj));
+  g_return_if_fail (G_IS_OBJECT (context));
+
+  brush = gimp_context_get_brush (context);
+  g_return_if_fail (GIMP_IS_BRUSH (brush));
+  
+  if (brush)
+    {
+      g_signal_handlers_block_matched (brush,
+                                       G_SIGNAL_MATCH_DETAIL,
+                                       0, g_quark_from_static_string ("spacing-changed"), NULL, NULL, NULL);
+    
+      gimp_brush_set_spacing (brush, gtk_adjustment_get_value (adjustment));
+
+      g_signal_handlers_unblock_matched (brush,
+                                         G_SIGNAL_MATCH_DETAIL,
+                                         0, g_quark_from_static_string ("spacing-changed"), NULL, NULL, NULL);
+    }
+
+}
+
+static void
+update_brush (GtkAdjustment *adjustment,
+              gpointer       data)
+{
+  gdouble              d_value_brush;
+  gdouble              d_value_adj;
+  gint                 i_value_brush;
+  gint                 i_value_adj;
+  BrushDialogPrivate  *p      = (BrushDialogPrivate*)data;
+  GimpBrush           *brush;
+  GimpBrushGenerated  *brush_generated;
+  gchar               *prop_name;
+  GtkAdjustment       *adj;
+
+  g_return_if_fail (G_IS_OBJECT (p->adj));
+  g_return_if_fail (G_IS_OBJECT (p->context));
+
+  brush = gimp_context_get_brush (p->context);
+
+  if (! GIMP_IS_BRUSH_GENERATED (brush))
+    return;
+
+  brush_generated = GIMP_BRUSH_GENERATED (brush);
+
+  prop_name = (gchar*)g_object_get_data (G_OBJECT (adjustment), "prop_name");
+  g_return_if_fail (prop_name != NULL);
+
+  adj = GTK_ADJUSTMENT (g_hash_table_lookup (p->adj_hash, prop_name));
+  g_return_if_fail (adj != NULL);
+  
+  if (strcmp (prop_name , "spikes") == 0)
+    {
+      g_object_get (G_OBJECT (brush_generated), prop_name, &i_value_brush, NULL);
+      i_value_adj = ROUND (gtk_adjustment_get_value (adj));
+      if (i_value_brush != i_value_adj)
+        {
+          g_signal_handlers_block_by_func (brush, notify_brush, p);
+
+          gimp_data_freeze (GIMP_DATA (brush));
+          g_object_freeze_notify (G_OBJECT (brush));
+          g_object_set (G_OBJECT (brush), prop_name, i_value_adj, NULL);
+          g_object_thaw_notify (G_OBJECT (brush));
+          gimp_data_thaw (GIMP_DATA (brush));
+
+          g_signal_handlers_unblock_by_func (brush, notify_brush, p);
+        }
+    }
+  else
+    {
+      g_object_get (G_OBJECT (brush_generated), prop_name, &d_value_brush, NULL);
+      d_value_adj = gtk_adjustment_get_value (adj);
+      if (d_value_brush != d_value_adj)
+        {
+          g_signal_handlers_block_by_func (brush, notify_brush, p);
+
+          gimp_data_freeze (GIMP_DATA (brush));
+          g_object_freeze_notify (G_OBJECT (brush));
+          g_object_set (G_OBJECT (brush), prop_name, d_value_adj, NULL);
+          g_object_thaw_notify (G_OBJECT (brush));
+          gimp_data_thaw (GIMP_DATA (brush));
+
+          g_signal_handlers_unblock_by_func (brush, notify_brush, p);
+        }
+        
+      if (strcmp (prop_name, "radius") == 0)
+        {
+          gdouble value = MAX (brush->mask->width, brush->mask->height);
+          g_object_set (p->context, "brush-size", value, NULL);
+        }
+    }
+
+}
+
+static void
+update_brush_shape (GtkWidget *widget,
+                    gpointer  *data)
+{
+  GimpBrush *brush;
+  GimpBrushGenerated *brush_generated = NULL;
+  BrushDialogPrivate  *p      = (BrushDialogPrivate*)data;
+
+  g_return_if_fail (G_IS_OBJECT (p->context));
+  brush = gimp_context_get_brush (p->context);
+
+  if (! GIMP_IS_BRUSH_GENERATED (brush))
+    return;
+
+  brush_generated = GIMP_BRUSH_GENERATED (brush);
+
+  if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
+    {
+      GimpBrushGeneratedShape shape;
+
+      shape = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (widget),
+                                                  "gimp-item-data"));
+
+      if (gimp_brush_generated_get_shape (brush_generated) != shape)
+        gimp_brush_generated_set_shape (brush_generated, shape);
+    }
+}
+
+static void
+notify_brush (GimpBrushGenerated *brush,
+              GParamSpec         *pspec,
+              gpointer            data)
+{
+  GtkAdjustment *adj     = NULL;
+  gdouble        d_value = 0.0;
+  gint           i_value = 0;
+  
+  BrushDialogPrivate  *p      = (BrushDialogPrivate*)data;
+  
+  g_print ("notify_brush: %s\n", pspec->name);
+
+  if (! strcmp (pspec->name, "shape"))
+    {
+      g_signal_handlers_block_by_func (p->shape_group,
+                                       update_brush_shape,
+                                       p);
+
+      gimp_int_radio_group_set_active (GTK_RADIO_BUTTON (p->shape_group),
+                                       brush->shape);
+
+      g_signal_handlers_unblock_by_func (p->shape_group,
+                                         update_brush_shape,
+                                         p);
+/*
+      adj   = editor->radius_data;
+      value = brush->radius;
+*/
+    }
+  else
+    {
+      adj = g_hash_table_lookup (p->adj_hash, pspec->name);
+      g_return_if_fail (adj != NULL);
+
+      if (strcmp (pspec->name , "spikes") == 0)
+        {
+          g_object_get (G_OBJECT (brush), pspec->name, &i_value, NULL);
+          d_value = i_value;
+        }
+      else
+        {
+          g_object_get (G_OBJECT (brush), pspec->name, &d_value, NULL);
+        }
+
+      g_signal_handlers_block_by_func (adj, update_brush, p);
+      gtk_adjustment_set_value (adj, d_value);
+      g_signal_handlers_unblock_by_func (adj, update_brush, p);
+    }
+}
+
+static void
+destroy_brush_popup_dialog (GtkWidget *widget, gpointer data)
+{
+  BrushDialogPrivate            *p = (BrushDialogPrivate*)data;
+  
+  if (p->spacing_changed_handler_id)
+    {
+      gimp_container_remove_handler (p->container,
+                                     p->spacing_changed_handler_id);
+      p->spacing_changed_handler_id = 0;
+    }
+  
+  p->shape_group = NULL;
+  p->adj         = NULL;
+  p->preview     = NULL;
+  
+  if (p->container)
+    {
+      g_object_unref (G_OBJECT (p->container));
+      p->container = NULL;
+    }
+
+  if (p->context)
+    {
+      GimpBrush *brush = gimp_context_get_brush (p->context);
+      if (brush) /* BUG: old brush must be used, but "brush" is new brush object ... */
+        g_signal_handlers_disconnect_by_func (brush, notify_brush, p);
+      g_signal_handlers_disconnect_by_func (p->context,
+                                            G_CALLBACK (brush_changed), p);
+      g_object_unref (G_OBJECT (p->context));
+      p->context = NULL;
+    }
+
+  g_hash_table_remove_all (p->adj_hash);
+}
+
+static void
+create_brush_popup_dialog (GtkWidget  *button,
+                           GtkWidget **result,
+                           GObject    *config,
+                           gpointer    data)
+{
+  GimpContainer                 *container;
+  GimpContext                   *context;
+  GimpContainerEditor           *editor;
+  GimpBrush                     *brush;
+  GtkWidget                     *vbox;
+  GtkWidget                     *frame;
+  GtkWidget                     *box;
+  GtkWidget                     *table;
+  GtkWidget                     *preview;
+  GtkWidget                     *frame2;
+  GimpViewType                   view_type = GIMP_VIEW_TYPE_GRID;
+  GimpViewSize                   view_size = GIMP_VIEW_SIZE_SMALL;
+  gint                           view_border_width = 1;
+  gint                           default_view_size = GIMP_VIEW_SIZE_SMALL;
+  GimpToolOptionsTableIncrement  inc = gimp_tool_options_table_increment (FALSE);
+  GList                         *children;
+  BrushDialogPrivate            *p = (BrushDialogPrivate*)data;
+  GtkAdjustment                 *adj = NULL;
+  
+  context   = GIMP_CONTEXT (config);
+  container = gimp_data_factory_get_container (context->gimp->brush_factory);
+  brush     = gimp_context_get_brush (context);
+  
+  g_return_if_fail (GIMP_IS_CONTAINER (container));
+  g_return_if_fail (GIMP_IS_CONTEXT (context));
+  g_return_if_fail (view_size >  0 &&
+                    view_size <= GIMP_VIEWABLE_MAX_BUTTON_SIZE);
+  g_return_if_fail (view_border_width >= 0 &&
+                    view_border_width <= GIMP_VIEW_MAX_BORDER_WIDTH);
+
+  *result    = gtk_hbox_new (FALSE, 1);
+  gtk_widget_show (*result);
+  
+  editor = GIMP_CONTAINER_EDITOR (
+    g_object_new (GIMP_TYPE_CONTAINER_EDITOR,
+      "view-type", view_type,
+      "container", container,
+      "context",   context,
+      "view-size", view_size,
+      "view-border-width", view_border_width,
+      NULL));
+  gimp_container_view_set_reorderable (GIMP_CONTAINER_VIEW (editor->view),
+                                       FALSE);
+
+  gimp_container_box_set_size_request (GIMP_CONTAINER_BOX (editor->view),
+                                       6  * (default_view_size +
+                                             2 * view_border_width),
+                                       10 * (default_view_size +
+                                             2 * view_border_width));
+
+  gtk_box_pack_start (GTK_BOX (*result), GTK_WIDGET (editor), TRUE, TRUE, 0);      
+  gtk_widget_show (GTK_WIDGET (editor));
+  
+  vbox = gtk_vbox_new (FALSE, 0);
+  gtk_box_pack_start (GTK_BOX (*result), vbox, TRUE, TRUE, 0);      
+  gtk_widget_show (vbox);
+  
+  frame2 = gimp_frame_new (_("Tool Options"));
+  gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_IN);
+  gtk_box_pack_start (GTK_BOX (vbox), frame2, TRUE, TRUE, 0);
+  gtk_widget_show (frame2);
+  
+  table = gtk_table_new (6, 3, FALSE);
+  gtk_container_add (GTK_CONTAINER (frame2), table);
+  gtk_widget_show (table);
+  
+  gimp_tool_options_scale_entry_new (config, "brush-size",
+                                     GTK_TABLE (table),
+                                     gimp_tool_options_table_increment_get_col (&inc),
+                                     gimp_tool_options_table_increment_get_row (&inc),
+                                     _("Size:"),
+                                     0.01, 0.1, 2,
+                                     FALSE, 0.0, 0.0, TRUE, FALSE);
+  gimp_tool_options_table_increment_next (&inc);
+
+  gimp_tool_options_scale_entry_new (config, "brush-aspect-ratio",
+                                     GTK_TABLE (table),
+                                     gimp_tool_options_table_increment_get_col (&inc),
+                                     gimp_tool_options_table_increment_get_row (&inc),
+                                     _("Aspect ratio:"),
+                                     0.01, 0.1, 2,
+                                     FALSE, 0.0, 0.0, TRUE, FALSE);
+  gimp_tool_options_table_increment_next (&inc);
+
+  gimp_tool_options_scale_entry_new (config, "brush-angle",
+                                     GTK_TABLE (table),
+                                     gimp_tool_options_table_increment_get_col (&inc),
+                                     gimp_tool_options_table_increment_get_row (&inc),
+                                     _("Angle:"),
+                                     1.0, 5.0, 2,
+                                     FALSE, 0.0, 0.0, FALSE, FALSE);
+  gimp_tool_options_table_increment_next (&inc);  
+
+  adj = GTK_ADJUSTMENT (gimp_scale_entry_new (GTK_TABLE (table),
+                                              gimp_tool_options_table_increment_get_col (&inc),
+                                              gimp_tool_options_table_increment_get_row (&inc),
+                                              _("Spacing:"), -1, -1,
+                                              gimp_brush_get_spacing (brush), 1.0, 200.0, 1.0, 10.0, 1,
+                                              FALSE, 1.0, 5000.0,
+                                              _("Percentage of width of brush"),
+                                              NULL));
+
+  g_object_set_data (G_OBJECT (adj), "prop_name", "spacing");
+  g_hash_table_replace (p->adj_hash, "spacing", adj);
+  brush_dialog_private_set_adjustment (p, adj);
+  brush_dialog_private_set_container  (p, container);
+  brush_dialog_private_set_context    (p, context); 
+
+  g_signal_connect (adj, "value-changed",
+                    G_CALLBACK (spacing_update),
+                    p);
+  gimp_tool_options_table_increment_next (&inc);  
+
+  /* Brush preview */
+  frame = gtk_frame_new (_("Preview"));
+  gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_IN);
+  gtk_box_pack_end (GTK_BOX (vbox), frame, TRUE, TRUE, 0);
+  gtk_widget_show (frame);
+
+  preview = gimp_view_new_full_by_types (context,
+                                         GIMP_TYPE_VIEW,
+                                         GIMP_TYPE_BRUSH,
+                                         BRUSH_VIEW_SIZE,
+                                         BRUSH_VIEW_SIZE, 0,
+                                         FALSE, FALSE, TRUE);
+  brush_dialog_private_set_preview (p, preview);
+  gtk_widget_set_size_request (preview, -1, BRUSH_VIEW_SIZE);
+  gimp_view_set_expand (GIMP_VIEW (preview), TRUE);
+  gtk_container_add (GTK_CONTAINER (frame), preview);
+  gtk_widget_show (preview);
+
+  /* Brush Options Editor */
+  frame2         = gimp_frame_new (_("Brush Options"));
+  p->brush_frame = frame2;
+  gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_IN);
+  gtk_box_pack_start (GTK_BOX (vbox), frame2, TRUE, TRUE, 0);
+  gtk_widget_show (frame2);
+  
+  table = gtk_table_new (6, 3, FALSE);
+  gtk_container_add (GTK_CONTAINER (frame2), table);
+  gtk_widget_show (table);
+
+  p->shape_group = NULL;
+
+  /* Stock Box for the brush shape */
+  box = gimp_enum_stock_box_new (GIMP_TYPE_BRUSH_GENERATED_SHAPE,
+                                 "gimp-shape",
+                                 GTK_ICON_SIZE_MENU,
+                                 G_CALLBACK (update_brush_shape),
+                                 p,
+                                 &p->shape_group);
+                                 
+  gimp_table_attach_aligned (GTK_TABLE (table),
+                             gimp_tool_options_table_increment_get_col (&inc),
+                             gimp_tool_options_table_increment_get_row (&inc),
+                             _("Shape:"), 0.0, 0.5,
+                             box, 2, TRUE);
+  gtk_widget_show (box);
+  gimp_tool_options_table_increment_next (&inc);  
+
+  /*  brush radius scale  */
+  adj =
+    GTK_ADJUSTMENT (gimp_scale_entry_new (GTK_TABLE (table),
+                                          gimp_tool_options_table_increment_get_col (&inc),
+                                          gimp_tool_options_table_increment_get_row (&inc),
+                                          _("Radius:"), -1, 5,
+                                          0.0, 0.1, 1000.0, 0.1, 1.0, 1,
+                                          TRUE, 0.0, 0.0,
+                                          NULL, NULL));
+
+  gimp_scale_entry_set_logarithmic (GTK_OBJECT (adj), TRUE);
+
+  g_object_set_data (G_OBJECT (adj), "prop_name", "radius");
+  g_hash_table_replace (p->adj_hash, "radius", adj);
+  gimp_tool_options_table_increment_next (&inc);  
+  g_signal_connect (adj, "value-changed",
+                    G_CALLBACK (update_brush),
+                    p);
+
+  /*  number of spikes  */
+  adj =
+    GTK_ADJUSTMENT (gimp_scale_entry_new (GTK_TABLE (table),
+                                          gimp_tool_options_table_increment_get_col (&inc),
+                                          gimp_tool_options_table_increment_get_row (&inc),
+                                          _("Spikes:"), -1, 5,
+                                          2.0, 2.0, 20.0, 1.0, 1.0, 0,
+                                          TRUE, 0.0, 0.0,
+                                          NULL, NULL));
+
+  g_object_set_data (G_OBJECT (adj), "prop_name", "spikes");
+  g_hash_table_replace (p->adj_hash, "spikes", adj);
+  g_signal_connect (adj, "value-changed",
+                    G_CALLBACK (update_brush),
+                    p);
+  gimp_tool_options_table_increment_next (&inc);  
+
+  /*  brush hardness scale  */
+  adj =
+    GTK_ADJUSTMENT (gimp_scale_entry_new (GTK_TABLE (table),
+                                          gimp_tool_options_table_increment_get_col (&inc),
+                                          gimp_tool_options_table_increment_get_row (&inc),
+                                          _("Hardness:"), -1, 5,
+                                          0.0, 0.0, 1.0, 0.01, 0.1, 2,
+                                          TRUE, 0.0, 0.0,
+                                          NULL, NULL));
+
+  g_object_set_data (G_OBJECT (adj), "prop_name", "hardness");
+  g_hash_table_replace (p->adj_hash, "hardness", adj);
+  g_signal_connect (adj, "value-changed",
+                    G_CALLBACK (update_brush),
+                    p);
+  gimp_tool_options_table_increment_next (&inc);  
+
+  /*  brush aspect ratio scale  */
+  adj =
+    GTK_ADJUSTMENT (gimp_scale_entry_new (GTK_TABLE (table),
+                                          gimp_tool_options_table_increment_get_col (&inc),
+                                          gimp_tool_options_table_increment_get_row (&inc),
+                                          _("Aspect ratio:"), -1, 5,
+                                          0.0, 1.0, 20.0, 0.1, 1.0, 1,
+                                          TRUE, 0.0, 0.0,
+                                          NULL, NULL));
+
+  g_object_set_data (G_OBJECT (adj), "prop_name", "aspect-ratio");
+  g_hash_table_replace (p->adj_hash, "aspect-ratio", adj);
+  g_signal_connect (adj,"value-changed",
+                    G_CALLBACK (update_brush),
+                    p);
+  gimp_tool_options_table_increment_next (&inc);  
+
+  /*  brush angle scale  */
+  adj =
+    GTK_ADJUSTMENT (gimp_scale_entry_new (GTK_TABLE (table),
+                                          gimp_tool_options_table_increment_get_col (&inc),
+                                          gimp_tool_options_table_increment_get_row (&inc),
+                                          _("Angle:"), -1, 5,
+                                          0.0, 0.0, 180.0, 0.1, 1.0, 1,
+                                          TRUE, 0.0, 0.0,
+                                          NULL, NULL));
+
+  g_object_set_data (G_OBJECT (adj), "prop_name", "angle");
+  g_hash_table_replace (p->adj_hash, "angle", adj);
+  g_signal_connect (adj, "value-changed",
+                    G_CALLBACK (update_brush),
+                    p);
+  gimp_tool_options_table_increment_next (&inc);  
+
+  p->spacing_changed_handler_id =
+    gimp_container_add_handler (container, "spacing-changed",
+                                G_CALLBACK (spacing_changed),
+                                p);
+
+  gimp_view_set_viewable (GIMP_VIEW (preview), GIMP_VIEWABLE (brush));
+
+  g_signal_connect (context,
+                    gimp_context_type_to_signal_name (GIMP_TYPE_BRUSH),
+                    G_CALLBACK (brush_changed),
+                    p);
+//  g_signal_connect (brush, "notify", G_CALLBACK (notify_brush), p);
+  if (context && brush)
+    brush_changed (context, GIMP_DATA(brush), p);
+
+  children = gtk_container_get_children (GTK_CONTAINER (table));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
+  g_signal_connect (GTK_WIDGET (*result), "destroy", G_CALLBACK(destroy_brush_popup_dialog), p);
+}
+
+
+/*  public functions  */
+GtkWidget*
+gimp_brush_button_with_popup (GObject *config)
+{
+  GimpContainer *container;
+  GimpContext   *context;
+  GimpViewSize   view_size = GIMP_VIEW_SIZE_SMALL;
+  const gchar        *prop_name;
+  GtkWidget     *label_widget;
+  BrushDialogPrivate *p = NULL;
+
+  context   = GIMP_CONTEXT (config);
+  container = gimp_data_factory_get_container (context->gimp->brush_factory);
+  
+  g_return_val_if_fail (GIMP_IS_CONTAINER (container), NULL);
+  g_return_val_if_fail (GIMP_IS_CONTEXT (context), NULL);
+  g_return_val_if_fail (view_size >  0 &&
+                        view_size <= GIMP_VIEWABLE_MAX_BUTTON_SIZE, NULL);
+
+  prop_name = gimp_context_type_to_prop_name (gimp_container_get_children_type (container));
+
+  label_widget = gimp_prop_view_new (G_OBJECT (context), prop_name,
+                                     context, view_size);
+  gtk_widget_show (label_widget);
+  
+  p = brush_dialog_private_new ();
+
+  return gimp_tool_options_button_with_popup (config, label_widget,
+                                               create_brush_popup_dialog,
+                                               p, brush_dialog_private_destroy);
+}
diff -Naur gimp-2.8.14/app/tools/gimpbrushoptions-gui.h gimp-2.8.14-new/app/tools/gimpbrushoptions-gui.h
--- gimp-2.8.14/app/tools/gimpbrushoptions-gui.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpbrushoptions-gui.h	2015-01-27 17:48:55.368751580 +0800
@@ -0,0 +1,23 @@
+/* GIMP-painter - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_BRUSH_OPTIONS_GUI_H__
+#define __GIMP_BRUSH_OPTIONS_GUI_H__
+
+GtkWidget *gimp_brush_button_with_popup (GObject *config);
+
+#endif  /*  __GIMP_TOOL_OPTIONS_GUI_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpbrushtool.c gimp-2.8.14-new/app/tools/gimpbrushtool.c
--- gimp-2.8.14/app/tools/gimpbrushtool.c	2015-01-27 17:28:36.896833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpbrushtool.c	2015-01-27 17:48:55.368751580 +0800
@@ -41,6 +41,7 @@
 #include "display/gimpcanvaspath.h"
 #include "display/gimpdisplay.h"
 #include "display/gimpdisplayshell.h"
+#include "display/gimpdisplayshell-rotate.h"
 
 #include "gimpbrushtool.h"
 #include "gimptoolcontrol.h"
diff -Naur gimp-2.8.14/app/tools/gimpbucketfilloptions.c gimp-2.8.14-new/app/tools/gimpbucketfilloptions.c
--- gimp-2.8.14/app/tools/gimpbucketfilloptions.c	2015-01-27 17:28:36.903833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpbucketfilloptions.c	2015-01-27 17:48:55.369751580 +0800
@@ -37,6 +37,7 @@
 #include "widgets/gimpwidgets-utils.h"
 
 #include "gimpbucketfilloptions.h"
+#include "gimptooloptions-gui.h"
 #include "gimppaintoptions-gui.h"
 
 #include "gimp-intl.h"
@@ -65,6 +66,12 @@
 
 static void   gimp_bucket_fill_options_reset        (GimpToolOptions *tool_options);
 
+static GtkWidget *gimp_bucket_fill_options_gui_full (GimpToolOptions *tool_options, 
+                                                      gboolean horizontal);
+
+static void   gimp_bucketfill_options_create_view   (GtkWidget *source, 
+                                                      GtkWidget **result, 
+                                                      GObject *config);
 
 G_DEFINE_TYPE (GimpBucketFillOptions, gimp_bucket_fill_options,
                GIMP_TYPE_PAINT_OPTIONS)
@@ -211,8 +218,42 @@
 GtkWidget *
 gimp_bucket_fill_options_gui (GimpToolOptions *tool_options)
 {
+  return gimp_bucket_fill_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_bucket_fill_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_bucket_fill_options_gui_full (tool_options, TRUE);
+}
+
+static GtkWidget *
+gimp_bucket_fill_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
+{
+  GtkWidget *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
+  GtkWidget *frame;
+  GObject   *config    = G_OBJECT (tool_options);
+  GType      tool_type = G_TYPE_NONE;
+
+  /* Detail Options */
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Details..."),
+                                                  horizontal, gimp_bucketfill_options_create_view);
+  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
+  gtk_widget_show (frame);
+
+  return vbox;
+}
+
+static void
+gimp_bucketfill_options_create_view (GtkWidget *source, GtkWidget **result, GObject *config)
+{
+  GimpToolOptions *tool_options = GIMP_TOOL_OPTIONS (config);
+  GtkWidget       *vbox         = gimp_tool_options_gui_full (tool_options, FALSE);
+#if 0
   GObject         *config = G_OBJECT (tool_options);
   GtkWidget       *vbox   = gimp_paint_options_gui (tool_options);
+#endif
   GtkWidget       *vbox2;
   GtkWidget       *table;
   GtkWidget       *frame;
@@ -298,5 +339,5 @@
                              _("Fill by:"), 0.0, 0.5,
                              combo, 2, FALSE);
 
-  return vbox;
+  *result = vbox;
 }
diff -Naur gimp-2.8.14/app/tools/gimpbucketfilloptions.h gimp-2.8.14-new/app/tools/gimpbucketfilloptions.h
--- gimp-2.8.14/app/tools/gimpbucketfilloptions.h	2015-01-27 17:28:36.901833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpbucketfilloptions.h	2015-01-27 17:48:55.369751580 +0800
@@ -48,7 +48,8 @@
 
 GType       gimp_bucket_fill_options_get_type (void) G_GNUC_CONST;
 
-GtkWidget * gimp_bucket_fill_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_bucket_fill_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_bucket_fill_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_BUCKET_FILL_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpbucketfilltool.c gimp-2.8.14-new/app/tools/gimpbucketfilltool.c
--- gimp-2.8.14/app/tools/gimpbucketfilltool.c	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpbucketfilltool.c	2015-01-27 17:48:55.369751580 +0800
@@ -77,6 +77,7 @@
   (* callback) (GIMP_TYPE_BUCKET_FILL_TOOL,
                 GIMP_TYPE_BUCKET_FILL_OPTIONS,
                 gimp_bucket_fill_options_gui,
+                gimp_bucket_fill_options_gui_horizontal,
                 GIMP_CONTEXT_FOREGROUND_MASK |
                 GIMP_CONTEXT_BACKGROUND_MASK |
                 GIMP_CONTEXT_OPACITY_MASK    |
diff -Naur gimp-2.8.14/app/tools/gimpbycolorselecttool.c gimp-2.8.14-new/app/tools/gimpbycolorselecttool.c
--- gimp-2.8.14/app/tools/gimpbycolorselecttool.c	2015-01-27 17:28:36.900833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpbycolorselecttool.c	2015-01-27 17:48:55.370751580 +0800
@@ -62,6 +62,7 @@
   (* callback) (GIMP_TYPE_BY_COLOR_SELECT_TOOL,
                 GIMP_TYPE_REGION_SELECT_OPTIONS,
                 gimp_region_select_options_gui,
+                gimp_region_select_options_gui_horizontal,
                 0,
                 "gimp-by-color-select-tool",
                 _("Select by Color"),
diff -Naur gimp-2.8.14/app/tools/gimpcagetool.c gimp-2.8.14-new/app/tools/gimpcagetool.c
--- gimp-2.8.14/app/tools/gimpcagetool.c	2015-01-27 17:28:36.894833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpcagetool.c	2015-01-27 17:48:55.370751580 +0800
@@ -153,6 +153,7 @@
   (* callback) (GIMP_TYPE_CAGE_TOOL,
                 GIMP_TYPE_CAGE_OPTIONS,
                 gimp_cage_options_gui,
+                NULL,
                 0,
                 "gimp-cage-tool",
                 _("Cage Transform"),
diff -Naur gimp-2.8.14/app/tools/gimpclonetool.c gimp-2.8.14-new/app/tools/gimpclonetool.c
--- gimp-2.8.14/app/tools/gimpclonetool.c	2015-01-27 17:28:36.895833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpclonetool.c	2015-01-27 17:48:55.371751580 +0800
@@ -33,14 +33,20 @@
 #include "display/gimpdisplay.h"
 
 #include "gimpclonetool.h"
+#include "gimptooloptions-gui.h"
 #include "gimppaintoptions-gui.h"
 #include "gimptoolcontrol.h"
 
 #include "gimp-intl.h"
 
 
-static GtkWidget * gimp_clone_options_gui (GimpToolOptions *tool_options);
-
+static GtkWidget * gimp_clone_options_gui            (GimpToolOptions *tool_options);
+static GtkWidget * gimp_clone_options_gui_full       (GimpToolOptions *tool_options,
+                                                       gboolean horizontal);
+static GtkWidget * gimp_clone_options_gui_horizontal (GimpToolOptions *tool_options);
+static void       gimp_clone_options_create_view     (GtkWidget *source,  
+                                                       GtkWidget **result, 
+                                                       GObject *config);
 
 G_DEFINE_TYPE (GimpCloneTool, gimp_clone_tool, GIMP_TYPE_SOURCE_TOOL)
 
@@ -54,6 +60,7 @@
   (* callback) (GIMP_TYPE_CLONE_TOOL,
                 GIMP_TYPE_CLONE_OPTIONS,
                 gimp_clone_options_gui,
+                gimp_clone_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK |
                 GIMP_CONTEXT_PATTERN_MASK,
                 "gimp-clone-tool",
@@ -95,15 +102,46 @@
 /*  tool options stuff  */
 
 static GtkWidget *
-gimp_clone_options_gui (GimpToolOptions *tool_options)
+gimp_clone_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
-  GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_paint_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget *frame;
+  GType      tool_type = G_TYPE_NONE;
+  GObject   *config = G_OBJECT (tool_options);
+
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Options"),
+                                                  horizontal, gimp_clone_options_create_view);
+  gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 0);
+  gtk_widget_show (frame);
+
+  if (horizontal)
+    {
+      GList *children;
+      children = gtk_container_get_children (GTK_CONTAINER (vbox));  
+      gimp_tool_options_setup_popup_layout (children, FALSE);
+    }  
+
+  return vbox;
+}
+  
+static void
+gimp_clone_options_create_view (GtkWidget *source, GtkWidget **result, GObject *config)
+{
+  GimpToolOptions *tool_options = GIMP_TOOL_OPTIONS (config);
+  GtkWidget       *vbox         = gimp_tool_options_gui_full (tool_options, FALSE);
+  GtkWidget       *frame;
+  GtkWidget       *button;
+  GtkWidget       *hbox;
+  GtkWidget       *table;
+  GtkWidget       *combo;
+  GtkWidget       *label;
+# if 0
   GtkWidget *button;
   GtkWidget *hbox;
   GtkWidget *combo;
   GtkWidget *label;
+#endif
 
   frame = gimp_prop_enum_radio_frame_new (config, "clone-type",
                                           _("Source"), 0, 0);
@@ -130,8 +168,24 @@
   gtk_widget_show (label);
 
   combo = gimp_prop_enum_combo_box_new (config, "align-mode", 0, 0);
+  gimp_table_attach_aligned (GTK_TABLE (table), 0, 0,
+                             _("Alignment:"), 0.0, 0.5,
+                             combo, 1, FALSE);
+  *result = vbox;
+}
+#if 0
   gtk_box_pack_start (GTK_BOX (hbox), combo, TRUE, TRUE, 0);
   gtk_widget_show (combo);
+#endif
 
-  return vbox;
+static GtkWidget *
+gimp_clone_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_clone_options_gui_full (tool_options, FALSE);
+}
+
+static GtkWidget *
+gimp_clone_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_clone_options_gui_full (tool_options, TRUE);
 }
diff -Naur gimp-2.8.14/app/tools/gimpcolorbalancetool.c gimp-2.8.14-new/app/tools/gimpcolorbalancetool.c
--- gimp-2.8.14/app/tools/gimpcolorbalancetool.c	2015-01-27 17:28:36.902833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpcolorbalancetool.c	2015-01-27 17:48:55.371751580 +0800
@@ -88,7 +88,7 @@
                                   gpointer                  data)
 {
   (* callback) (GIMP_TYPE_COLOR_BALANCE_TOOL,
-                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL,
+                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL, NULL,
                 0,
                 "gimp-color-balance-tool",
                 _("Color Balance"),
diff -Naur gimp-2.8.14/app/tools/gimpcolorizetool.c gimp-2.8.14-new/app/tools/gimpcolorizetool.c
--- gimp-2.8.14/app/tools/gimpcolorizetool.c	2015-01-27 17:28:36.892833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpcolorizetool.c	2015-01-27 17:48:55.371751580 +0800
@@ -84,7 +84,7 @@
                              gpointer                  data)
 {
   (* callback) (GIMP_TYPE_COLORIZE_TOOL,
-                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL,
+                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL, NULL,
                 0,
                 "gimp-colorize-tool",
                 _("Colorize"),
diff -Naur gimp-2.8.14/app/tools/gimpcoloroptions.c gimp-2.8.14-new/app/tools/gimpcoloroptions.c
--- gimp-2.8.14/app/tools/gimpcoloroptions.c	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpcoloroptions.c	2015-01-27 17:48:55.372751580 +0800
@@ -50,6 +50,9 @@
                                                guint         property_id,
                                                GValue       *value,
                                                GParamSpec   *pspec);
+static void   gimp_color_options_average_create_view (GtkWidget *source, 
+                                                       GtkWidget **result, 
+                                                       GObject *config);
 
 
 G_DEFINE_TYPE (GimpColorOptions, gimp_color_options,
@@ -135,20 +138,20 @@
 }
 
 GtkWidget *
-gimp_color_options_gui (GimpToolOptions *tool_options)
+gimp_color_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config = G_OBJECT (tool_options);
   GtkWidget *vbox;
   GtkWidget *frame;
   GtkWidget *scale;
-  GtkWidget *button;
-
+ 
   if (GIMP_IS_HISTOGRAM_OPTIONS (tool_options))
     vbox = gimp_histogram_options_gui (tool_options);
   else
-    vbox = gimp_tool_options_gui (tool_options);
+    vbox = gimp_tool_options_gui_full (tool_options, horizontal);
 
   /*  the sample average options  */
+#if 0
   frame = gimp_frame_new (NULL);
   gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 0);
   gtk_widget_show (frame);
@@ -164,9 +167,55 @@
   gtk_frame_set_label_widget (GTK_FRAME (frame), button);
   gtk_widget_show (button);
 
+  // gimp-painter-2.7
+  gtk_widget_set_sensitive (scale,
+                            GIMP_COLOR_OPTIONS (config)->sample_average);
+#endif
+  frame = gimp_tool_options_toggle_gui_with_popup (config, G_TYPE_NONE,
+                             "sample-average", _("Average"), _("Sample Average"),
+                             horizontal, gimp_color_options_average_create_view);
+  gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 0);
+  gtk_widget_show (frame);  
+
+//  g_object_set_data (G_OBJECT (button), "set_sensitive", scale);
+#if 0
   g_object_bind_property (config, "sample-average",
                           scale,  "sensitive",
                           G_BINDING_SYNC_CREATE);
+#endif
 
   return vbox;
 }
+
+
+GtkWidget *
+gimp_color_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_color_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_color_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_color_options_gui_full (tool_options, TRUE);
+}
+
+  
+static void
+gimp_color_options_average_create_view (GtkWidget *source, GtkWidget **result, GObject *config)
+{
+  GimpToolOptions *tool_options = GIMP_TOOL_OPTIONS (config);
+  GtkWidget       *vbox         = gimp_tool_options_gui (tool_options);
+  GtkWidget       *scale;
+  GList *children;
+  scale = gimp_prop_spin_scale_new (config, "average-radius",
+                                    _("Radius"),
+                                    1.0, 10.0, 0);
+  gtk_box_pack_start (GTK_BOX (vbox), scale, FALSE, FALSE, 0);
+  gtk_widget_show (scale);
+
+  children = gtk_container_get_children (GTK_CONTAINER (vbox));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
+  *result = vbox;
+}
diff -Naur gimp-2.8.14/app/tools/gimpcoloroptions.h gimp-2.8.14-new/app/tools/gimpcoloroptions.h
--- gimp-2.8.14/app/tools/gimpcoloroptions.h	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpcoloroptions.h	2015-01-27 17:48:55.372751580 +0800
@@ -44,7 +44,10 @@
 
 GType       gimp_color_options_get_type (void) G_GNUC_CONST;
 
-GtkWidget * gimp_color_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_color_options_gui_full       (GimpToolOptions *tool_options,
+                                               gboolean horizontal);
+GtkWidget * gimp_color_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_color_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif /* __GIMP_COLOR_OPTIONS_H__ */
diff -Naur gimp-2.8.14/app/tools/gimpcolorpickeroptions.c gimp-2.8.14-new/app/tools/gimpcolorpickeroptions.c
--- gimp-2.8.14/app/tools/gimpcolorpickeroptions.c	2015-01-27 17:28:36.898833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpcolorpickeroptions.c	2015-01-27 17:48:55.373751580 +0800
@@ -141,11 +141,11 @@
     }
 }
 
-GtkWidget *
-gimp_color_picker_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_color_picker_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject         *config = G_OBJECT (tool_options);
-  GtkWidget       *vbox   = gimp_color_options_gui (tool_options);
+  GtkWidget       *vbox   = gimp_color_options_gui_full (tool_options, horizontal);
   GtkWidget       *button;
   GtkWidget       *frame;
   gchar           *str;
@@ -162,7 +162,13 @@
   /*  the pick FG/BG frame  */
   str = g_strdup_printf (_("Pick Mode  (%s)"),
                          gimp_get_mod_string (toggle_mask));
+  frame = gimp_prop_enum_radio_frame_new_with_orientation (config, "pick-mode", str, -1, -1,
+                                                           horizontal ?
+                                                             GTK_ORIENTATION_HORIZONTAL:
+                                                             GTK_ORIENTATION_VERTICAL);
+#if 0
   frame = gimp_prop_enum_radio_frame_new (config, "pick-mode", str, -1, -1);
+#endif
   g_free (str);
 
   gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 0);
@@ -179,3 +185,15 @@
 
   return vbox;
 }
+
+GtkWidget *
+gimp_color_picker_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_color_picker_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_color_picker_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_color_picker_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpcolorpickeroptions.h gimp-2.8.14-new/app/tools/gimpcolorpickeroptions.h
--- gimp-2.8.14/app/tools/gimpcolorpickeroptions.h	2015-01-27 17:28:36.898833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpcolorpickeroptions.h	2015-01-27 17:48:55.373751580 +0800
@@ -44,7 +44,8 @@
 
 GType       gimp_color_picker_options_get_type (void) G_GNUC_CONST;
 
-GtkWidget * gimp_color_picker_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_color_picker_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_color_picker_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_COLOR_PICKER_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpcolorpickertool.c gimp-2.8.14-new/app/tools/gimpcolorpickertool.c
--- gimp-2.8.14/app/tools/gimpcolorpickertool.c	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpcolorpickertool.c	2015-01-27 17:48:55.373751580 +0800
@@ -88,6 +88,7 @@
   (* callback) (GIMP_TYPE_COLOR_PICKER_TOOL,
                 GIMP_TYPE_COLOR_PICKER_OPTIONS,
                 gimp_color_picker_options_gui,
+                gimp_color_picker_options_gui_horizontal,
                 GIMP_CONTEXT_FOREGROUND_MASK | GIMP_CONTEXT_BACKGROUND_MASK,
                 "gimp-color-picker-tool",
                 _("Color Picker"),
diff -Naur gimp-2.8.14/app/tools/gimpconvolvetool.c gimp-2.8.14-new/app/tools/gimpconvolvetool.c
--- gimp-2.8.14/app/tools/gimpconvolvetool.c	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpconvolvetool.c	2015-01-27 17:48:55.373751580 +0800
@@ -53,7 +53,10 @@
 static void   gimp_convolve_tool_status_update (GimpTool         *tool,
                                                 GimpConvolveType  type);
 
-static GtkWidget * gimp_convolve_options_gui   (GimpToolOptions  *options);
+static GtkWidget * gimp_convolve_options_gui            (GimpToolOptions  *options);
+static GtkWidget * gimp_convolve_options_gui_full       (GimpToolOptions  *options,
+                                                          gboolean horizontal);
+static GtkWidget * gimp_convolve_options_gui_horizontal (GimpToolOptions  *options);
 
 
 G_DEFINE_TYPE (GimpConvolveTool, gimp_convolve_tool, GIMP_TYPE_BRUSH_TOOL)
@@ -68,6 +71,7 @@
   (* callback) (GIMP_TYPE_CONVOLVE_TOOL,
                 GIMP_TYPE_CONVOLVE_OPTIONS,
                 gimp_convolve_options_gui,
+                gimp_convolve_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK,
                 "gimp-convolve-tool",
                 _("Blur / Sharpen"),
@@ -201,10 +205,10 @@
 /*  tool options stuff  */
 
 static GtkWidget *
-gimp_convolve_options_gui (GimpToolOptions *tool_options)
+gimp_convolve_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject         *config = G_OBJECT (tool_options);
-  GtkWidget       *vbox   = gimp_paint_options_gui (tool_options);
+  GtkWidget       *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget       *frame;
   GtkWidget       *scale;
   gchar           *str;
@@ -232,3 +236,15 @@
 
   return vbox;
 }
+
+static GtkWidget *
+gimp_convolve_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_convolve_options_gui_full (tool_options, FALSE);
+}
+
+static GtkWidget *
+gimp_convolve_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_convolve_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpcropoptions.c gimp-2.8.14-new/app/tools/gimpcropoptions.c
--- gimp-2.8.14/app/tools/gimpcropoptions.c	2015-01-27 17:28:36.889833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpcropoptions.c	2015-01-27 17:48:55.374751580 +0800
@@ -151,11 +151,11 @@
     }
 }
 
-GtkWidget *
-gimp_crop_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_crop_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_tool_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_tool_options_gui_full (tool_options, horizontal);
   GtkWidget *vbox_rectangle;
   GtkWidget *button;
 
@@ -172,9 +172,21 @@
   gtk_widget_show (button);
 
   /*  rectangle options  */
-  vbox_rectangle = gimp_rectangle_options_gui (tool_options);
+  vbox_rectangle = gimp_rectangle_options_gui_full (tool_options, horizontal);
   gtk_box_pack_start (GTK_BOX (vbox), vbox_rectangle, FALSE, FALSE, 0);
   gtk_widget_show (vbox_rectangle);
 
   return vbox;
 }
+
+GtkWidget *
+gimp_crop_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_crop_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_crop_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_crop_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpcropoptions.h gimp-2.8.14-new/app/tools/gimpcropoptions.h
--- gimp-2.8.14/app/tools/gimpcropoptions.h	2015-01-27 17:28:36.903833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpcropoptions.h	2015-01-27 17:48:55.374751580 +0800
@@ -47,9 +47,10 @@
 };
 
 
-GType       gimp_crop_options_get_type (void) G_GNUC_CONST;
+GType       gimp_crop_options_get_type       (void) G_GNUC_CONST;
 
-GtkWidget * gimp_crop_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_crop_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_crop_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif /* __GIMP_CROP_OPTIONS_H__ */
diff -Naur gimp-2.8.14/app/tools/gimpcroptool.c gimp-2.8.14-new/app/tools/gimpcroptool.c
--- gimp-2.8.14/app/tools/gimpcroptool.c	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpcroptool.c	2015-01-27 17:48:55.374751580 +0800
@@ -112,6 +112,7 @@
   (* callback) (GIMP_TYPE_CROP_TOOL,
                 GIMP_TYPE_CROP_OPTIONS,
                 gimp_crop_options_gui,
+                gimp_crop_options_gui_horizontal,
                 0,
                 "gimp-crop-tool",
                 _("Crop"),
diff -Naur gimp-2.8.14/app/tools/gimpcurvestool.c gimp-2.8.14-new/app/tools/gimpcurvestool.c
--- gimp-2.8.14/app/tools/gimpcurvestool.c	2015-01-27 17:28:36.889833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpcurvestool.c	2015-01-27 17:48:55.374751580 +0800
@@ -145,6 +145,7 @@
   (* callback) (GIMP_TYPE_CURVES_TOOL,
                 GIMP_TYPE_HISTOGRAM_OPTIONS,
                 gimp_color_options_gui,
+                NULL,
                 0,
                 "gimp-curves-tool",
                 _("Curves"),
diff -Naur gimp-2.8.14/app/tools/gimpdesaturatetool.c gimp-2.8.14-new/app/tools/gimpdesaturatetool.c
--- gimp-2.8.14/app/tools/gimpdesaturatetool.c	2015-01-27 17:28:36.891833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpdesaturatetool.c	2015-01-27 17:48:55.375751580 +0800
@@ -71,7 +71,7 @@
                                gpointer                  data)
 {
   (* callback) (GIMP_TYPE_DESATURATE_TOOL,
-                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL,
+                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL, NULL,
                 0,
                 "gimp-desaturate-tool",
                 _("Desaturate"),
diff -Naur gimp-2.8.14/app/tools/gimpdodgeburntool.c gimp-2.8.14-new/app/tools/gimpdodgeburntool.c
--- gimp-2.8.14/app/tools/gimpdodgeburntool.c	2015-01-27 17:28:36.894833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpdodgeburntool.c	2015-01-27 17:48:55.375751580 +0800
@@ -53,7 +53,10 @@
 static void   gimp_dodge_burn_tool_status_update (GimpTool          *tool,
                                                   GimpDodgeBurnType  type);
 
-static GtkWidget * gimp_dodge_burn_options_gui   (GimpToolOptions   *tool_options);
+static GtkWidget * gimp_dodge_burn_options_gui            (GimpToolOptions   *tool_options);
+static GtkWidget * gimp_dodge_burn_options_gui_full       (GimpToolOptions   *tool_options,
+                                                            gboolean           horizontal);
+static GtkWidget * gimp_dodge_burn_options_gui_horizontal (GimpToolOptions   *tool_options);
 
 
 G_DEFINE_TYPE (GimpDodgeBurnTool, gimp_dodge_burn_tool, GIMP_TYPE_BRUSH_TOOL)
@@ -68,6 +71,7 @@
   (* callback) (GIMP_TYPE_DODGE_BURN_TOOL,
                 GIMP_TYPE_DODGE_BURN_OPTIONS,
                 gimp_dodge_burn_options_gui,
+                gimp_dodge_burn_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK,
                 "gimp-dodge-burn-tool",
                 _("Dodge / Burn"),
@@ -204,10 +208,10 @@
 /*  tool options stuff  */
 
 static GtkWidget *
-gimp_dodge_burn_options_gui (GimpToolOptions *tool_options)
+gimp_dodge_burn_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject         *config = G_OBJECT (tool_options);
-  GtkWidget       *vbox   = gimp_paint_options_gui (tool_options);
+  GtkWidget       *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget       *frame;
   GtkWidget       *scale;
   gchar           *str;
@@ -240,3 +244,15 @@
 
   return vbox;
 }
+
+static GtkWidget *
+gimp_dodge_burn_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_dodge_burn_options_gui_full (tool_options, FALSE);
+}
+
+static GtkWidget *
+gimp_dodge_burn_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_dodge_burn_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpdynamicsoptions-gui.c gimp-2.8.14-new/app/tools/gimpdynamicsoptions-gui.c
--- gimp-2.8.14/app/tools/gimpdynamicsoptions-gui.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpdynamicsoptions-gui.c	2015-01-27 17:48:55.375751580 +0800
@@ -0,0 +1,385 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <glib-object.h>
+#include <glib/gprintf.h>
+#include <gtk/gtk.h>
+
+#include "tools-types.h"
+
+#include "libgimpconfig/gimpconfig.h"
+#include "libgimpmath/gimpmath.h"
+#include "libgimpwidgets/gimpwidgets.h"
+#include "libgimpbase/gimpbase.h" /* gimp-painter-2.7 */
+
+#include "core/gimp.h"
+#include "core/gimpcontainer.h"
+#include "core/gimpcontext.h"
+#include "core/gimptooloptions.h"
+#include "core/gimpdatafactory.h"
+#include "core/gimpdynamics.h"
+
+#include "core/gimpbrush.h"
+#include "core/gimpbrushgenerated.h"
+
+#include "widgets/gimpview.h"
+#include "widgets/gimpviewrenderer.h"
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimpcontainereditor.h"
+#include "widgets/gimpcontainerview.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpcontainerbox.h"
+#include "widgets/gimpdynamicsoutputeditor.h"
+
+#include "gimptooloptions-gui.h"
+#include "gimpdynamicsoptions-gui.h"
+
+#include "gimp-intl.h"
+
+
+#define BRUSH_VIEW_SIZE 256
+
+static void notify_working_dynamics        (GimpDynamics *dynamics, GParamSpec *pspec, gpointer data);
+static void notify_current_target_dynamics (GimpDynamics *dynamics, GParamSpec *pspec, gpointer data);
+static void dynamics_changed               (GimpContext *context, GimpData *brush_data, gpointer data);
+
+/*  private functions  */
+typedef struct _DynamicsDialogPrivate DynamicsDialogPrivate;
+struct _DynamicsDialogPrivate
+{
+  GimpDynamics *working_dynamics;
+  GimpDynamics *current_target_dynamics;
+  GimpContext  *context;
+};
+
+static void
+dynamics_dialog_private_init (DynamicsDialogPrivate *p)
+{
+  if (!p->working_dynamics) 
+    {
+      p->working_dynamics = g_object_new (GIMP_TYPE_DYNAMICS, NULL);
+      g_object_ref (G_OBJECT (p->working_dynamics));
+    }
+}
+
+static void
+dynamics_dialog_private_finalize (DynamicsDialogPrivate *p)
+{
+  if (p->working_dynamics)
+    {
+      g_object_unref (G_OBJECT (p->working_dynamics));
+      p->working_dynamics = NULL;
+    }
+
+  if (p->context)
+    {
+      p->context = NULL;
+    }
+  p->current_target_dynamics = NULL;  
+}
+
+static DynamicsDialogPrivate *
+dynamics_dialog_private_new (void)
+{
+  DynamicsDialogPrivate *p = g_new0 (DynamicsDialogPrivate, 1);
+  
+  g_print ("DynamicsDialogPrivate::new\n");
+  dynamics_dialog_private_init(p);
+  return p;
+}
+
+static void
+dynamics_dialog_private_destroy (gpointer data)
+{
+  DynamicsDialogPrivate *p = (DynamicsDialogPrivate*)data;
+  
+  g_print ("DynamicsDialogPrivate::destroy\n");
+  dynamics_dialog_private_finalize (p);
+
+  if (p)
+    g_free (p);
+}
+
+static void
+dynamics_changed (GimpContext    *context,
+                  GimpData       *dynamics_data,
+                  gpointer        data)
+{
+  DynamicsDialogPrivate *p        = (DynamicsDialogPrivate*)data;
+  GimpDynamics          *dynamics = GIMP_DYNAMICS (dynamics_data);
+  
+  g_return_if_fail (p && context);
+
+  if (p->current_target_dynamics)
+    g_signal_handlers_disconnect_by_func (p->current_target_dynamics,
+                                          notify_current_target_dynamics,
+                                          p);
+  p->current_target_dynamics = dynamics;
+                                        
+  g_return_if_fail (dynamics);
+  
+  notify_current_target_dynamics (dynamics, NULL, p);
+
+  g_signal_connect (p->current_target_dynamics, "notify",
+                    G_CALLBACK (notify_current_target_dynamics),
+                    p);
+/*
+  gtk_widget_set_sensitive (dynamics_editor->check_grid,
+                            editor->data_editable);
+*/
+}
+
+static void
+notify_current_target_dynamics (GimpDynamics *dynamics,
+                                GParamSpec   *pspec,
+                                gpointer      data)
+{
+  DynamicsDialogPrivate *p        = (DynamicsDialogPrivate*)data;
+
+  g_return_if_fail (p && dynamics == p->current_target_dynamics);
+
+  g_signal_handlers_block_by_func (p->working_dynamics,
+                                   notify_working_dynamics,
+                                   p);
+
+  gimp_config_copy (GIMP_CONFIG (p->current_target_dynamics),
+                    GIMP_CONFIG (p->working_dynamics),
+                    GIMP_CONFIG_PARAM_SERIALIZE);
+
+  g_signal_handlers_unblock_by_func (p->working_dynamics,
+                                     notify_working_dynamics,
+                                     p);
+}
+
+static void
+notify_working_dynamics        (GimpDynamics *dynamics,
+                                GParamSpec   *pspec,
+                                gpointer      data)
+{
+  DynamicsDialogPrivate *p        = (DynamicsDialogPrivate*)data;
+    
+  g_return_if_fail (p && dynamics == p->working_dynamics);
+
+  if (p->current_target_dynamics)
+    {
+      g_signal_handlers_block_by_func (p->current_target_dynamics,
+                                       notify_current_target_dynamics,
+                                       p);
+
+      gimp_config_copy (GIMP_CONFIG (p->working_dynamics),
+                        GIMP_CONFIG (p->current_target_dynamics),
+                        GIMP_CONFIG_PARAM_SERIALIZE);
+
+      g_signal_handlers_unblock_by_func (p->current_target_dynamics,
+                                         notify_current_target_dynamics,
+                                         p);
+    }
+}
+
+static void
+destroy_dynamics_popup_dialog (GtkWidget *widget, gpointer data)
+{
+  DynamicsDialogPrivate *p = (DynamicsDialogPrivate*)data;
+  
+  g_print ("popup destroyed\n");
+
+  if (p)
+    {
+        guint result;
+      if (p->current_target_dynamics)
+        {
+          result = g_signal_handlers_disconnect_by_func (p->current_target_dynamics,
+                                                notify_current_target_dynamics,
+                                                p);
+          g_print ("current_target_dynamics::disconnect -> %u\n", result);
+          p->current_target_dynamics = NULL;
+        }
+
+      result = g_signal_handlers_disconnect_by_func (p->working_dynamics,
+                                            notify_working_dynamics,
+                                            p);
+      g_print ("working_dynamics::disconnect -> %u\n", result);
+          
+      result = g_signal_handlers_disconnect_by_func (p->context,
+                                            dynamics_changed,
+                                            p);
+      g_print ("context::disconnect -> %u\n", result);
+
+      dynamics_dialog_private_finalize (p);
+    }
+}
+
+static void
+create_dynamics_popup_dialog (GtkWidget  *button,
+                           GtkWidget **result,
+                           GObject    *config,
+                           gpointer    data)
+{
+  GimpContainer                 *container;
+  GimpContext                   *context;
+  GimpContainerEditor           *editor;
+  GimpDynamics                  *dynamics;
+  GtkWidget                     *vbox;
+  GtkWidget                     *table;
+  GType                          enum_type;
+  GEnumClass                    *enum_class;
+  GEnumValue                    *value;
+    
+  GimpViewType                   view_type = GIMP_VIEW_TYPE_LIST;
+  GimpViewSize                   view_size = GIMP_VIEW_SIZE_SMALL;
+  gint                           view_border_width = 1;
+  gint                           default_view_size = GIMP_VIEW_SIZE_SMALL;
+ 
+  GtkWidget                     *notebook;
+
+  GList                         *children;
+  DynamicsDialogPrivate         *p = (DynamicsDialogPrivate*)data;
+
+
+  GtkAdjustment                 *adj = NULL;
+  GtkWidget                     *preview; 
+  GimpToolOptionsTableIncrement  inc = gimp_tool_options_table_increment (FALSE);
+  GtkWidget                     *frame;
+  GtkWidget                     *box;
+  
+  dynamics_dialog_private_init (p);
+
+  context    = GIMP_CONTEXT (config);
+  p->context = context;
+  container  = gimp_data_factory_get_container (context->gimp->dynamics_factory);
+  
+  g_return_if_fail (GIMP_IS_CONTAINER (container));
+  g_return_if_fail (GIMP_IS_CONTEXT (context));
+  g_return_if_fail (view_size >  0 &&
+                    view_size <= GIMP_VIEWABLE_MAX_BUTTON_SIZE);
+  g_return_if_fail (view_border_width >= 0 &&
+                    view_border_width <= GIMP_VIEW_MAX_BORDER_WIDTH);
+
+  *result    = gtk_hbox_new (FALSE, 1);
+  gtk_widget_show (*result);
+  
+  editor = GIMP_CONTAINER_EDITOR (
+    g_object_new (GIMP_TYPE_CONTAINER_EDITOR, 
+      "view-type", view_type,
+      "container", container,
+      "context",   context,
+      "view-size", view_size,
+      "view-border-width", view_border_width,
+      NULL));
+
+  gimp_container_view_set_reorderable (GIMP_CONTAINER_VIEW (editor->view),
+                                       FALSE);
+
+  gimp_container_box_set_size_request (GIMP_CONTAINER_BOX (editor->view),
+                                       6  * (default_view_size +
+                                             2 * view_border_width),
+                                       10 * (default_view_size +
+                                             2 * view_border_width));
+
+  gtk_box_pack_start (GTK_BOX (*result), GTK_WIDGET (editor), TRUE, TRUE, 0);      
+  gtk_widget_show (GTK_WIDGET (editor));
+  
+  vbox = gtk_vbox_new (FALSE, 0);
+  gtk_box_pack_start (GTK_BOX (*result), vbox, TRUE, TRUE, 0);      
+  gtk_widget_show (vbox);
+  
+  table = gtk_table_new (6, 3, FALSE);
+  gtk_box_pack_start (GTK_BOX (vbox), table, TRUE, TRUE, 0);      
+  gtk_widget_show (table);
+
+  /* Dynamics editor */
+  notebook = gtk_notebook_new ();
+  gtk_notebook_set_show_border (GTK_NOTEBOOK (notebook), FALSE);
+  gtk_notebook_set_show_tabs (GTK_NOTEBOOK (notebook), TRUE);
+  gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook), GTK_POS_LEFT);
+  gtk_box_pack_start (GTK_BOX (vbox), notebook, TRUE, TRUE, 0);
+  gtk_widget_show (notebook);
+
+  dynamics = gimp_context_get_dynamics (context);
+
+  /* Dynamics output editor */
+  enum_type = GIMP_TYPE_DYNAMICS_OUTPUT_TYPE;
+  enum_class = g_type_class_ref (enum_type);
+
+  for (value = enum_class->values;
+       value->value_name;
+       value++)
+    {
+      GimpDynamicsOutput *output;
+      GtkWidget          *output_editor;
+      const gchar        *desc;
+
+      if (value->value < enum_class->minimum || value->value > enum_class->maximum)
+        continue;
+
+      output = gimp_dynamics_get_output (p->working_dynamics, value->value);
+      output_editor = gimp_dynamics_output_editor_new (output);
+      desc = gimp_enum_value_get_desc (enum_class, value);
+
+      gtk_notebook_append_page (GTK_NOTEBOOK (notebook), output_editor, gtk_label_new (desc));
+      gtk_widget_show (output_editor);
+    }
+
+  g_type_class_unref (enum_class);
+
+  children = gtk_container_get_children (GTK_CONTAINER (table));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
+  dynamics_changed (context, GIMP_DATA (dynamics), p);
+  g_signal_connect (p->working_dynamics,
+                    "notify", G_CALLBACK (notify_working_dynamics), p);
+  g_signal_connect (context,
+                    gimp_context_type_to_signal_name (GIMP_TYPE_DYNAMICS),
+                    G_CALLBACK (dynamics_changed),
+                    p);
+  g_signal_connect (GTK_WIDGET (*result), "destroy", G_CALLBACK(destroy_dynamics_popup_dialog), p);
+}
+
+
+/*  public functions  */
+GtkWidget*
+gimp_dynamics_button_with_popup (GObject *config)
+{
+  GimpContainer *container;
+  GimpContext   *context;
+  GimpViewSize   view_size = GIMP_VIEW_SIZE_SMALL;
+  const gchar  *prop_name;
+  GtkWidget     *label_widget;
+  DynamicsDialogPrivate *p = NULL;
+
+  context   = GIMP_CONTEXT (config);
+  container = gimp_data_factory_get_container (context->gimp->dynamics_factory);
+  
+  g_return_val_if_fail (GIMP_IS_CONTAINER (container), NULL);
+  g_return_val_if_fail (GIMP_IS_CONTEXT (context), NULL);
+  g_return_val_if_fail (view_size >  0 &&
+                        view_size <= GIMP_VIEWABLE_MAX_BUTTON_SIZE, NULL);
+
+  prop_name = gimp_context_type_to_prop_name (gimp_container_get_children_type (container));
+
+  label_widget = gimp_prop_view_new (G_OBJECT (context), prop_name,
+                                     context, view_size);
+  gtk_widget_show (label_widget);
+  
+  p = dynamics_dialog_private_new ();
+
+  return gimp_tool_options_button_with_popup (config, label_widget,
+                                               create_dynamics_popup_dialog,
+                                               p, dynamics_dialog_private_destroy);
+}
diff -Naur gimp-2.8.14/app/tools/gimpdynamicsoptions-gui.h gimp-2.8.14-new/app/tools/gimpdynamicsoptions-gui.h
--- gimp-2.8.14/app/tools/gimpdynamicsoptions-gui.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpdynamicsoptions-gui.h	2015-01-27 17:48:55.376751579 +0800
@@ -0,0 +1,23 @@
+/* GIMP-painter - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_DYNAMICS_OPTIONS_GUI_H__
+#define __GIMP_DYNAMICS_OPTIONS_GUI_H__
+
+GtkWidget *gimp_dynamics_button_with_popup (GObject *config);
+
+#endif  /*  __GIMP_TOOL_OPTIONS_GUI_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpellipseselecttool.c gimp-2.8.14-new/app/tools/gimpellipseselecttool.c
--- gimp-2.8.14/app/tools/gimpellipseselecttool.c	2015-01-27 17:28:36.898833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpellipseselecttool.c	2015-01-27 17:48:55.376751579 +0800
@@ -61,6 +61,7 @@
   (* callback) (GIMP_TYPE_ELLIPSE_SELECT_TOOL,
                 GIMP_TYPE_RECTANGLE_SELECT_OPTIONS,
                 gimp_rectangle_select_options_gui,
+                gimp_rectangle_select_options_gui_horizontal,
                 0,
                 "gimp-ellipse-select-tool",
                 _("Ellipse Select"),
diff -Naur gimp-2.8.14/app/tools/gimperasertool.c gimp-2.8.14-new/app/tools/gimperasertool.c
--- gimp-2.8.14/app/tools/gimperasertool.c	2015-01-27 17:28:36.890833809 +0800
+++ gimp-2.8.14-new/app/tools/gimperasertool.c	2015-01-27 17:48:55.376751579 +0800
@@ -45,7 +45,9 @@
                                               GdkModifierType   state,
                                               GimpDisplay      *display);
 
-static GtkWidget * gimp_eraser_options_gui   (GimpToolOptions *tool_options);
+static GtkWidget * gimp_eraser_options_gui            (GimpToolOptions *tool_options);
+static GtkWidget * gimp_eraser_options_gui_horizontal (GimpToolOptions *tool_options);
+static GtkWidget * gimp_eraser_options_gui_full       (GimpToolOptions *tool_options, gboolean horizontal);
 
 
 G_DEFINE_TYPE (GimpEraserTool, gimp_eraser_tool, GIMP_TYPE_BRUSH_TOOL)
@@ -60,6 +62,7 @@
   (* callback) (GIMP_TYPE_ERASER_TOOL,
                 GIMP_TYPE_ERASER_OPTIONS,
                 gimp_eraser_options_gui,
+                gimp_eraser_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK,
                 "gimp-eraser-tool",
                 _("Eraser"),
@@ -134,10 +137,10 @@
 /*  tool options stuff  */
 
 static GtkWidget *
-gimp_eraser_options_gui (GimpToolOptions *tool_options)
+gimp_eraser_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_paint_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget *button;
   gchar     *str;
 
@@ -153,3 +156,16 @@
 
   return vbox;
 }
+
+static GtkWidget *
+gimp_eraser_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_eraser_options_gui_full (tool_options, FALSE);
+}
+
+
+static GtkWidget *
+gimp_eraser_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_eraser_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpflipoptions.c gimp-2.8.14-new/app/tools/gimpflipoptions.c
--- gimp-2.8.14/app/tools/gimpflipoptions.c	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpflipoptions.c	2015-01-27 17:48:55.377751579 +0800
@@ -112,11 +112,11 @@
     }
 }
 
-GtkWidget *
-gimp_flip_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_flip_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject         *config = G_OBJECT (tool_options);
-  GtkWidget       *vbox   = gimp_tool_options_gui (tool_options);
+  GtkWidget       *vbox   = gimp_tool_options_gui_full (tool_options, horizontal);
   GtkWidget       *hbox;
   GtkWidget       *box;
   GtkWidget       *label;
@@ -142,10 +142,12 @@
   str = g_strdup_printf (_("Flip Type  (%s)"),
                          gimp_get_mod_string (toggle_mask));
 
-  frame = gimp_prop_enum_radio_frame_new (config, "flip-type",
-                                          str,
-                                          GIMP_ORIENTATION_HORIZONTAL,
-                                          GIMP_ORIENTATION_VERTICAL);
+  frame = gimp_prop_enum_radio_frame_new_with_orientation (config, "flip-type",
+                                                           str,
+                                                           GIMP_ORIENTATION_HORIZONTAL,
+                                                           GIMP_ORIENTATION_VERTICAL,
+                                                           horizontal ? GTK_ORIENTATION_HORIZONTAL:
+                                                           GTK_ORIENTATION_VERTICAL);
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
   gtk_widget_show (frame);
 
@@ -153,3 +155,15 @@
 
   return vbox;
 }
+
+GtkWidget *
+gimp_flip_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_flip_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_flip_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_flip_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpflipoptions.h gimp-2.8.14-new/app/tools/gimpflipoptions.h
--- gimp-2.8.14/app/tools/gimpflipoptions.h	2015-01-27 17:28:36.900833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpflipoptions.h	2015-01-27 17:48:55.377751579 +0800
@@ -43,7 +43,8 @@
 
 GType       gimp_flip_options_get_type (void) G_GNUC_CONST;
 
-GtkWidget * gimp_flip_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_flip_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_flip_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif /* __GIMP_FLIP_OPTIONS_H__ */
diff -Naur gimp-2.8.14/app/tools/gimpfliptool.c gimp-2.8.14-new/app/tools/gimpfliptool.c
--- gimp-2.8.14/app/tools/gimpfliptool.c	2015-01-27 17:28:36.891833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpfliptool.c	2015-01-27 17:48:55.377751579 +0800
@@ -79,6 +79,7 @@
   (* callback) (GIMP_TYPE_FLIP_TOOL,
                 GIMP_TYPE_FLIP_OPTIONS,
                 gimp_flip_options_gui,
+                gimp_flip_options_gui_horizontal,
                 GIMP_CONTEXT_BACKGROUND_MASK,
                 "gimp-flip-tool",
                 _("Flip"),
diff -Naur gimp-2.8.14/app/tools/gimpforegroundselectoptions.c gimp-2.8.14-new/app/tools/gimpforegroundselectoptions.c
--- gimp-2.8.14/app/tools/gimpforegroundselectoptions.c	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpforegroundselectoptions.c	2015-01-27 17:48:55.378751579 +0800
@@ -51,14 +51,17 @@
 };
 
 
-static void   gimp_foreground_select_options_set_property (GObject      *object,
-                                                           guint         property_id,
-                                                           const GValue *value,
-                                                           GParamSpec   *pspec);
-static void   gimp_foreground_select_options_get_property (GObject      *object,
-                                                           guint         property_id,
-                                                           GValue       *value,
-                                                           GParamSpec   *pspec);
+static void gimp_foreground_select_options_set_property   (GObject      *object,
+                                                            guint         property_id,
+                                                            const GValue *value,
+                                                            GParamSpec   *pspec);
+static void gimp_foreground_select_options_get_property   (GObject      *object,
+                                                            guint         property_id,
+                                                            GValue       *value,
+                                                            GParamSpec   *pspec);
+static void gimp_foreground_selection_options_create_view (GtkWidget *source, 
+                                                            GtkWidget **result, 
+                                                            GObject *config);
 
 
 G_DEFINE_TYPE (GimpForegroundSelectOptions, gimp_foreground_select_options,
@@ -255,11 +258,13 @@
     }
 }
 
-GtkWidget *
-gimp_foreground_select_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_foreground_select_options_gui_full (GimpToolOptions *tool_options, 
+                                         gboolean horizontal)
 {
   GObject         *config = G_OBJECT (tool_options);
-  GtkWidget       *vbox   = gimp_selection_options_gui (tool_options);
+  GtkWidget       *vbox   = gimp_selection_options_gui_full (tool_options, horizontal);
+  GType            tool_type = G_TYPE_NONE;
   GtkWidget       *hbox;
   GtkWidget       *button;
   GtkWidget       *frame;
@@ -270,9 +275,6 @@
   GtkWidget       *table;
   gchar           *title;
   gint             row = 0;
-  GdkModifierType  toggle_mask;
-
-  toggle_mask = gimp_get_toggle_behavior_mask ();
 
   gtk_widget_set_sensitive (GIMP_SELECTION_OPTIONS (tool_options)->antialias_toggle,
                             FALSE);
@@ -282,6 +284,35 @@
   gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
   gtk_widget_show (button);
 
+  /* Detail Options */
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Details..."),
+                                                  horizontal, gimp_foreground_selection_options_create_view);
+  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
+  gtk_widget_show (frame);
+
+  return vbox;
+}
+
+static void
+gimp_foreground_selection_options_create_view (GtkWidget *source, GtkWidget **result, GObject *config)
+{
+  GimpToolOptions *tool_options = GIMP_TOOL_OPTIONS (config);
+  GtkWidget       *vbox         = gimp_tool_options_gui_full (tool_options, FALSE);
+  GtkWidget *hbox;
+  GtkWidget *frame;
+  GtkWidget *scale;
+  GtkWidget *label;
+  GtkWidget *menu;
+  GtkWidget *inner_frame;
+  GtkWidget *table;
+  GtkObject *adj;
+  gchar     *title;
+  gint       row = 0;
+  GdkModifierType  toggle_mask;
+
+  toggle_mask = gimp_get_toggle_behavior_mask ();
+
   /*  foreground / background  */
   title = g_strdup_printf (_("Interactive refinement  (%s)"),
                            gimp_get_mod_string (toggle_mask));
@@ -367,7 +398,19 @@
   gimp_prop_opacity_entry_new (config, "sensitivity-b",
                                GTK_TABLE (table), 0, row++, "b");
 
-  return vbox;
+  *result = vbox;
+}
+
+GtkWidget *
+gimp_foreground_select_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_foreground_select_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_foreground_select_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_foreground_select_options_gui_full (tool_options, TRUE);
 }
 
 void
diff -Naur gimp-2.8.14/app/tools/gimpforegroundselectoptions.h gimp-2.8.14-new/app/tools/gimpforegroundselectoptions.h
--- gimp-2.8.14/app/tools/gimpforegroundselectoptions.h	2015-01-27 17:28:36.905833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpforegroundselectoptions.h	2015-01-27 17:48:55.378751579 +0800
@@ -50,6 +50,7 @@
 GType       gimp_foreground_select_options_get_type       (void) G_GNUC_CONST;
 
 GtkWidget * gimp_foreground_select_options_gui            (GimpToolOptions             *tool_options);
+GtkWidget * gimp_foreground_select_options_gui_horizontal (GimpToolOptions             *tool_options);
 
 void        gimp_foreground_select_options_get_mask_color (GimpForegroundSelectOptions *options,
                                                            GimpRGB                     *color);
diff -Naur gimp-2.8.14/app/tools/gimpforegroundselecttool.c gimp-2.8.14-new/app/tools/gimpforegroundselecttool.c
--- gimp-2.8.14/app/tools/gimpforegroundselecttool.c	2015-01-27 17:28:36.889833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpforegroundselecttool.c	2015-01-27 17:48:55.378751579 +0800
@@ -139,6 +139,7 @@
   (* callback) (GIMP_TYPE_FOREGROUND_SELECT_TOOL,
                 GIMP_TYPE_FOREGROUND_SELECT_OPTIONS,
                 gimp_foreground_select_options_gui,
+                gimp_foreground_select_options_gui_horizontal,
                 GIMP_CONTEXT_FOREGROUND_MASK | GIMP_CONTEXT_BACKGROUND_MASK,
                 "gimp-foreground-select-tool",
                 _("Foreground Select"),
diff -Naur gimp-2.8.14/app/tools/gimpfreeselecttool.c gimp-2.8.14-new/app/tools/gimpfreeselecttool.c
--- gimp-2.8.14/app/tools/gimpfreeselecttool.c	2015-01-27 17:28:36.899833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpfreeselecttool.c	2015-01-27 17:48:55.379751579 +0800
@@ -191,6 +191,7 @@
   (* callback) (GIMP_TYPE_FREE_SELECT_TOOL,
                 GIMP_TYPE_SELECTION_OPTIONS,
                 gimp_selection_options_gui,
+                gimp_selection_options_gui_horizontal,
                 0,
                 "gimp-free-select-tool",
                 _("Free Select"),
diff -Naur gimp-2.8.14/app/tools/gimpfuzzyselecttool.c gimp-2.8.14-new/app/tools/gimpfuzzyselecttool.c
--- gimp-2.8.14/app/tools/gimpfuzzyselecttool.c	2015-01-27 17:28:36.891833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpfuzzyselecttool.c	2015-01-27 17:48:55.379751579 +0800
@@ -60,6 +60,7 @@
   (* callback) (GIMP_TYPE_FUZZY_SELECT_TOOL,
                 GIMP_TYPE_REGION_SELECT_OPTIONS,
                 gimp_region_select_options_gui,
+                gimp_region_select_options_gui_horizontal,
                 0,
                 "gimp-fuzzy-select-tool",
                 _("Fuzzy Select"),
diff -Naur gimp-2.8.14/app/tools/gimpgegltool.c gimp-2.8.14-new/app/tools/gimpgegltool.c
--- gimp-2.8.14/app/tools/gimpgegltool.c	2015-01-27 17:28:36.901833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpgegltool.c	2015-01-27 17:48:55.379751579 +0800
@@ -87,7 +87,7 @@
                          gpointer                  data)
 {
   (* callback) (GIMP_TYPE_GEGL_TOOL,
-                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL,
+                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL, NULL,
                 0,
                 "gimp-gegl-tool",
                 _("GEGL Operation"),
diff -Naur gimp-2.8.14/app/tools/gimphealtool.c gimp-2.8.14-new/app/tools/gimphealtool.c
--- gimp-2.8.14/app/tools/gimphealtool.c	2015-01-27 17:28:36.903833808 +0800
+++ gimp-2.8.14-new/app/tools/gimphealtool.c	2015-01-27 17:48:55.380751579 +0800
@@ -34,7 +34,10 @@
 #include "gimp-intl.h"
 
 
-static GtkWidget * gimp_heal_options_gui (GimpToolOptions *tool_options);
+static GtkWidget * gimp_heal_options_gui            (GimpToolOptions *tool_options);
+static GtkWidget * gimp_heal_options_gui_full       (GimpToolOptions *tool_options,
+                                                      gboolean horizontal);
+static GtkWidget * gimp_heal_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 G_DEFINE_TYPE (GimpHealTool, gimp_heal_tool, GIMP_TYPE_SOURCE_TOOL)
@@ -47,6 +50,7 @@
   (* callback) (GIMP_TYPE_HEAL_TOOL,
                 GIMP_TYPE_SOURCE_OPTIONS,
                 gimp_heal_options_gui,
+                gimp_heal_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK,
                 "gimp-heal-tool",
                 _("Heal"),
@@ -86,10 +90,10 @@
 /*  tool options stuff  */
 
 static GtkWidget *
-gimp_heal_options_gui (GimpToolOptions *tool_options)
+gimp_heal_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_paint_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget *button;
   GtkWidget *hbox;
   GtkWidget *label;
@@ -116,3 +120,15 @@
 
   return vbox;
 }
+
+static GtkWidget *
+gimp_heal_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_heal_options_gui_full (tool_options, FALSE);
+}
+
+static GtkWidget *
+gimp_heal_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_heal_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimphuesaturationtool.c gimp-2.8.14-new/app/tools/gimphuesaturationtool.c
--- gimp-2.8.14/app/tools/gimphuesaturationtool.c	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimphuesaturationtool.c	2015-01-27 17:48:55.380751579 +0800
@@ -96,7 +96,7 @@
                                    gpointer                  data)
 {
   (* callback) (GIMP_TYPE_HUE_SATURATION_TOOL,
-                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL,
+                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL, NULL,
                 0,
                 "gimp-hue-saturation-tool",
                 _("Hue-Saturation"),
diff -Naur gimp-2.8.14/app/tools/gimpinkoptions-gui.c gimp-2.8.14-new/app/tools/gimpinkoptions-gui.c
--- gimp-2.8.14/app/tools/gimpinkoptions-gui.c	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpinkoptions-gui.c	2015-01-27 17:48:55.380751579 +0800
@@ -31,33 +31,55 @@
 #include "widgets/gimppropwidgets.h"
 
 #include "gimpinkoptions-gui.h"
+#include "gimptooloptions-gui.h"
 #include "gimppaintoptions-gui.h"
 
 #include "gimp-intl.h"
 
 
+static GtkWidget * gimp_ink_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal);
+static void sensitivity_create_view (GtkWidget *button, GtkWidget **result, GObject *config);
+static void blob_create_view (GtkWidget *button, GtkWidget **result, GObject *config);
+
 GtkWidget *
 gimp_ink_options_gui (GimpToolOptions *tool_options)
 {
+  return gimp_ink_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_ink_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_ink_options_gui_full (tool_options, TRUE);
+}
+
+GtkWidget *
+gimp_ink_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
+{
   GObject        *config      = G_OBJECT (tool_options);
-  GimpInkOptions *ink_options = GIMP_INK_OPTIONS (tool_options);
-  GtkWidget      *vbox        = gimp_paint_options_gui (tool_options);
+  GtkWidget      *vbox        = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget      *frame;
   GtkWidget      *vbox2;
   GtkWidget      *scale;
-  GtkWidget      *blob_box;
-  GtkWidget      *hbox;
-  GtkWidget      *editor;
-  GtkSizeGroup   *size_group;
+
+  GType          tool_type = G_TYPE_NONE;
+  GimpToolOptionsTableIncrement inc = gimp_tool_options_table_increment (horizontal);
 
   /* adjust sliders */
-  frame = gimp_frame_new (_("Adjustment"));
-  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, TRUE, 0);
-  gtk_widget_show (frame);
 
-  vbox2 = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
-  gtk_container_add (GTK_CONTAINER (frame), vbox2);
-  gtk_widget_show (vbox2);
+  if (horizontal)
+    {
+      vbox2 = vbox;
+    }
+  else
+    {
+      frame = gimp_frame_new (_("Adjustment"));
+      gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, TRUE, 0);
+      gtk_widget_show (frame);
+      vbox2 = gimp_tool_options_gui_full (tool_options, horizontal);
+      gtk_container_add (GTK_CONTAINER (frame), vbox2);
+      gtk_widget_show (vbox2);
+    }
 
   /*  size slider  */
   scale = gimp_prop_spin_scale_new (config, "size",
@@ -74,12 +96,37 @@
   gtk_widget_show (scale);
 
   /* sens sliders */
-  frame = gimp_frame_new (_("Sensitivity"));
-  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, TRUE, 0);
-  gtk_widget_show (frame);
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Sensitivity"),
+                                                  horizontal, sensitivity_create_view);
+  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
+  /*  bottom hbox */
+
+  /* Blob shape widget */
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Ink Blob"),
+                                                  horizontal, blob_create_view);
+  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
+
+  if (horizontal)
+    {
+      GList *children;
+      children = gtk_container_get_children (GTK_CONTAINER (vbox2));  
+      gimp_tool_options_setup_popup_layout (children, FALSE);
+    }
+    
+  return vbox;
+}
+
+static void
+sensitivity_create_view (GtkWidget *button, GtkWidget **result, GObject *config)
+{
+  GtkWidget *vbox2;
+  GtkWidget *scale;
+  GList *children;
 
   vbox2 = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
-  gtk_container_add (GTK_CONTAINER (frame), vbox2);
+/*  gtk_container_add (GTK_CONTAINER (frame), vbox2); */
   gtk_widget_show (vbox2);
 
   /* size sens slider */
@@ -103,17 +150,27 @@
   gtk_box_pack_start (GTK_BOX (vbox2), scale, FALSE, FALSE, 0);
   gtk_widget_show (scale);
 
-  /* Blob shape widgets */
-  frame = gimp_frame_new (_("Shape"));
-  gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
-  gtk_widget_show (frame);
 
+  children = gtk_container_get_children (GTK_CONTAINER (vbox2));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
+  *result = vbox2;
+}
+
+static void
+blob_create_view (GtkWidget *button, GtkWidget **result, GObject *config)
+{
+  GimpInkOptions * ink_options = GIMP_INK_OPTIONS (config);
+  GtkWidget *frame;
+  GtkWidget *blob_box;
+  GtkWidget *hbox;
+  GtkWidget *editor;
+
+  /* Blob shape widgets */
   hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
-  gtk_container_add (GTK_CONTAINER (frame), hbox);
+/*  gtk_container_add (GTK_CONTAINER (frame), hbox); */
   gtk_widget_show (hbox);
 
-  size_group = gtk_size_group_new (GTK_SIZE_GROUP_VERTICAL);
-
   /* Blob type radiobuttons */
   blob_box = gimp_prop_enum_stock_box_new (config, "blob-type",
                                            "gimp-shape", 0, 0);
@@ -122,26 +179,26 @@
   gtk_box_pack_start (GTK_BOX (hbox), blob_box, FALSE, FALSE, 0);
   gtk_widget_show (blob_box);
 
+#if 0
   gtk_size_group_add_widget (size_group, blob_box);
   g_object_unref (size_group);
+#endif
 
   /* Blob editor */
-  frame = gtk_aspect_frame_new (NULL, 0.0, 0.5, 1.0, FALSE);
+  frame = gtk_frame_new("");
   gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_IN);
   gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0);
   gtk_widget_show (frame);
 
-  gtk_size_group_add_widget (size_group, frame);
-
   editor = gimp_blob_editor_new (ink_options->blob_type,
                                  ink_options->blob_aspect,
                                  ink_options->blob_angle);
+  gtk_widget_set_size_request (editor, 80, 80);
   gtk_container_add (GTK_CONTAINER (frame), editor);
   gtk_widget_show (editor);
 
   gimp_config_connect (config, G_OBJECT (editor), "blob-type");
   gimp_config_connect (config, G_OBJECT (editor), "blob-aspect");
   gimp_config_connect (config, G_OBJECT (editor), "blob-angle");
-
-  return vbox;
+  *result = hbox;
 }
diff -Naur gimp-2.8.14/app/tools/gimpinkoptions-gui.h gimp-2.8.14-new/app/tools/gimpinkoptions-gui.h
--- gimp-2.8.14/app/tools/gimpinkoptions-gui.h	2015-01-27 17:28:36.889833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpinkoptions-gui.h	2015-01-27 17:48:55.381751579 +0800
@@ -20,6 +20,7 @@
 
 
 GtkWidget * gimp_ink_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_ink_options_gui_horizontal      (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_INK_OPTIONS_GUI_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpinktool.c gimp-2.8.14-new/app/tools/gimpinktool.c
--- gimp-2.8.14/app/tools/gimpinktool.c	2015-01-27 17:28:36.896833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpinktool.c	2015-01-27 17:48:55.381751579 +0800
@@ -46,6 +46,7 @@
   (* callback) (GIMP_TYPE_INK_TOOL,
                 GIMP_TYPE_INK_OPTIONS,
                 gimp_ink_options_gui,
+                gimp_ink_options_gui_horizontal,
                 GIMP_CONTEXT_FOREGROUND_MASK |
                 GIMP_CONTEXT_BACKGROUND_MASK |
                 GIMP_CONTEXT_OPACITY_MASK    |
diff -Naur gimp-2.8.14/app/tools/gimpiscissorsoptions.c gimp-2.8.14-new/app/tools/gimpiscissorsoptions.c
--- gimp-2.8.14/app/tools/gimpiscissorsoptions.c	2015-01-27 17:28:36.903833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpiscissorsoptions.c	2015-01-27 17:48:55.381751579 +0800
@@ -116,11 +116,11 @@
     }
 }
 
-GtkWidget *
-gimp_iscissors_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_iscissors_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config  = G_OBJECT (tool_options);
-  GtkWidget *vbox    = gimp_selection_options_gui (tool_options);
+  GtkWidget *vbox    = gimp_selection_options_gui_full (tool_options, horizontal);
   GtkWidget *button;
 
   button = gimp_prop_check_button_new (config, "interactive",
@@ -130,3 +130,16 @@
 
   return vbox;
 }
+
+
+GtkWidget *
+gimp_iscissors_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_iscissors_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_iscissors_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_iscissors_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpiscissorsoptions.h gimp-2.8.14-new/app/tools/gimpiscissorsoptions.h
--- gimp-2.8.14/app/tools/gimpiscissorsoptions.h	2015-01-27 17:28:36.890833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpiscissorsoptions.h	2015-01-27 17:48:55.381751579 +0800
@@ -41,9 +41,10 @@
 };
 
 
-GType       gimp_iscissors_options_get_type (void) G_GNUC_CONST;
+GType       gimp_iscissors_options_get_type       (void) G_GNUC_CONST;
 
-GtkWidget * gimp_iscissors_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_iscissors_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_iscissors_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_ISCISSORS_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpiscissorstool.c gimp-2.8.14-new/app/tools/gimpiscissorstool.c
--- gimp-2.8.14/app/tools/gimpiscissorstool.c	2015-01-27 17:28:36.902833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpiscissorstool.c	2015-01-27 17:48:55.382751579 +0800
@@ -270,6 +270,7 @@
   (* callback) (GIMP_TYPE_ISCISSORS_TOOL,
                 GIMP_TYPE_ISCISSORS_OPTIONS,
                 gimp_iscissors_options_gui,
+                gimp_iscissors_options_gui_horizontal,
                 0,
                 "gimp-iscissors-tool",
                 _("Scissors"),
diff -Naur gimp-2.8.14/app/tools/gimplevelstool.c gimp-2.8.14-new/app/tools/gimplevelstool.c
--- gimp-2.8.14/app/tools/gimplevelstool.c	2015-01-27 17:28:36.894833809 +0800
+++ gimp-2.8.14-new/app/tools/gimplevelstool.c	2015-01-27 17:48:55.382751579 +0800
@@ -145,6 +145,7 @@
   (* callback) (GIMP_TYPE_LEVELS_TOOL,
                 GIMP_TYPE_HISTOGRAM_OPTIONS,
                 gimp_color_options_gui,
+                NULL,
                 0,
                 "gimp-levels-tool",
                 _("Levels"),
diff -Naur gimp-2.8.14/app/tools/gimpmagnifyoptions.c gimp-2.8.14-new/app/tools/gimpmagnifyoptions.c
--- gimp-2.8.14/app/tools/gimpmagnifyoptions.c	2015-01-27 17:28:36.901833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpmagnifyoptions.c	2015-01-27 17:48:55.383751579 +0800
@@ -155,11 +155,11 @@
   GIMP_TOOL_OPTIONS_CLASS (parent_class)->reset (tool_options);
 }
 
-GtkWidget *
-gimp_magnify_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_magnify_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject         *config = G_OBJECT (tool_options);
-  GtkWidget       *vbox   = gimp_tool_options_gui (tool_options);
+  GtkWidget       *vbox   = gimp_tool_options_gui_full (tool_options, horizontal);
   GtkWidget       *frame;
   GtkWidget       *button;
   gchar           *str;
@@ -177,8 +177,11 @@
   str = g_strdup_printf (_("Direction  (%s)"),
                          gimp_get_mod_string (toggle_mask));
 
-  frame = gimp_prop_enum_radio_frame_new (config, "zoom-type",
-                                          str, 0, 0);
+  frame = gimp_prop_enum_radio_frame_new_with_orientation (config, "zoom-type",
+                                                           str, 0, 0,
+                                                           horizontal ? 
+                                                             GTK_ORIENTATION_HORIZONTAL :
+                                                             GTK_ORIENTATION_VERTICAL);
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
   gtk_widget_show (frame);
 
@@ -186,3 +189,15 @@
 
   return vbox;
 }
+
+GtkWidget *
+gimp_magnify_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_magnify_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_magnify_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_magnify_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpmagnifyoptions.h gimp-2.8.14-new/app/tools/gimpmagnifyoptions.h
--- gimp-2.8.14/app/tools/gimpmagnifyoptions.h	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpmagnifyoptions.h	2015-01-27 17:48:55.383751579 +0800
@@ -42,9 +42,10 @@
 };
 
 
-GType       gimp_magnify_options_get_type (void) G_GNUC_CONST;
+GType       gimp_magnify_options_get_type       (void) G_GNUC_CONST;
 
-GtkWidget * gimp_magnify_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_magnify_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_magnify_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_MAGNIFY_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpmagnifytool.c gimp-2.8.14-new/app/tools/gimpmagnifytool.c
--- gimp-2.8.14/app/tools/gimpmagnifytool.c	2015-01-27 17:28:36.897833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpmagnifytool.c	2015-01-27 17:48:55.383751579 +0800
@@ -86,6 +86,7 @@
   (* callback) (GIMP_TYPE_MAGNIFY_TOOL,
                 GIMP_TYPE_MAGNIFY_OPTIONS,
                 gimp_magnify_options_gui,
+                gimp_magnify_options_gui_horizontal,
                 0,
                 "gimp-zoom-tool",
                 _("Zoom"),
diff -Naur gimp-2.8.14/app/tools/gimpmeasureoptions.c gimp-2.8.14-new/app/tools/gimpmeasureoptions.c
--- gimp-2.8.14/app/tools/gimpmeasureoptions.c	2015-01-27 17:28:36.900833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpmeasureoptions.c	2015-01-27 17:48:55.383751579 +0800
@@ -113,11 +113,11 @@
     }
 }
 
-GtkWidget *
-gimp_measure_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_measure_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_tool_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_tool_options_gui_full (tool_options, horizontal);
   GtkWidget *button;
 
   /*  the use_info_window toggle button  */
@@ -128,3 +128,16 @@
 
   return vbox;
 }
+
+
+GtkWidget *
+gimp_measure_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_measure_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_measure_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_measure_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpmeasureoptions.h gimp-2.8.14-new/app/tools/gimpmeasureoptions.h
--- gimp-2.8.14/app/tools/gimpmeasureoptions.h	2015-01-27 17:28:36.897833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpmeasureoptions.h	2015-01-27 17:48:55.384751579 +0800
@@ -41,9 +41,10 @@
 };
 
 
-GType       gimp_measure_options_get_type (void) G_GNUC_CONST;
+GType       gimp_measure_options_get_type       (void) G_GNUC_CONST;
 
-GtkWidget * gimp_measure_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_measure_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_measure_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_MEASURE_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpmeasuretool.c gimp-2.8.14-new/app/tools/gimpmeasuretool.c
--- gimp-2.8.14/app/tools/gimpmeasuretool.c	2015-01-27 17:28:36.900833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpmeasuretool.c	2015-01-27 17:48:55.384751579 +0800
@@ -122,6 +122,7 @@
   (* callback) (GIMP_TYPE_MEASURE_TOOL,
                 GIMP_TYPE_MEASURE_OPTIONS,
                 gimp_measure_options_gui,
+                gimp_measure_options_gui_horizontal,
                 0,
                 "gimp-measure-tool",
                 _("Measure"),
diff -Naur gimp-2.8.14/app/tools/gimpmoveoptions.c gimp-2.8.14-new/app/tools/gimpmoveoptions.c
--- gimp-2.8.14/app/tools/gimpmoveoptions.c	2015-01-27 17:28:36.890833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpmoveoptions.c	2015-01-27 17:48:55.384751579 +0800
@@ -160,11 +160,11 @@
                             move_options->move_type != GIMP_TRANSFORM_TYPE_SELECTION);
 }
 
-GtkWidget *
-gimp_move_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_move_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_tool_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_tool_options_gui_full (tool_options, horizontal);
   GtkWidget *hbox;
   GtkWidget *box;
   GtkWidget *label;
@@ -187,8 +187,11 @@
   title = g_strdup_printf (_("Tool Toggle  (%s)"),
                            gimp_get_mod_string (GDK_SHIFT_MASK));
 
-  frame = gimp_prop_boolean_radio_frame_new (config, "move-current",
-                                             title, "true", "false");
+  frame = gimp_prop_boolean_radio_frame_new_with_orientation (config, "move-current",
+                                                              title, "true", "false",
+                                                              horizontal ? 
+                                                                GTK_ORIENTATION_HORIZONTAL :
+                                                                GTK_ORIENTATION_VERTICAL);
 
   gimp_move_options_notify_type (GIMP_MOVE_OPTIONS (config), NULL, frame);
 
@@ -203,3 +206,15 @@
 
   return vbox;
 }
+
+GtkWidget *
+gimp_move_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_move_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_move_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_move_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpmoveoptions.h gimp-2.8.14-new/app/tools/gimpmoveoptions.h
--- gimp-2.8.14/app/tools/gimpmoveoptions.h	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpmoveoptions.h	2015-01-27 17:48:55.385751579 +0800
@@ -42,9 +42,9 @@
 };
 
 
-GType       gimp_move_options_get_type (void) G_GNUC_CONST;
-
-GtkWidget * gimp_move_options_gui      (GimpToolOptions *tool_options);
+GType       gimp_move_options_get_type       (void) G_GNUC_CONST;
 
+GtkWidget * gimp_move_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_move_options_gui_horizontal (GimpToolOptions *tool_options);
 
 #endif /* __GIMP_MOVE_OPTIONS_H__ */
diff -Naur gimp-2.8.14/app/tools/gimpmovetool.c gimp-2.8.14-new/app/tools/gimpmovetool.c
--- gimp-2.8.14/app/tools/gimpmovetool.c	2015-01-27 17:28:36.898833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpmovetool.c	2015-01-27 17:48:55.385751579 +0800
@@ -122,6 +122,7 @@
   (* callback) (GIMP_TYPE_MOVE_TOOL,
                 GIMP_TYPE_MOVE_OPTIONS,
                 gimp_move_options_gui,
+                gimp_move_options_gui_horizontal,
                 0,
                 "gimp-move-tool",
                 C_("tool", "Move"),
diff -Naur gimp-2.8.14/app/tools/gimpmypaintbrusheditor.cpp gimp-2.8.14-new/app/tools/gimpmypaintbrusheditor.cpp
--- gimp-2.8.14/app/tools/gimpmypaintbrusheditor.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypaintbrusheditor.cpp	2015-01-27 17:48:55.386751579 +0800
@@ -0,0 +1,815 @@
+// gimpmypaintbrusheditor.cpp
+//
+// Copyright (C) 2012 - seagetch
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+extern "C" {
+#include "config.h"
+
+#include <glib.h>
+#include <glib/gprintf.h>
+#include <gtk/gtk.h>
+
+#include "libgimpmath/gimpmath.h"
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "tools-types.h"
+
+#include "base/temp-buf.h"
+
+#include "core/gimpbrush.h"
+#include "core/gimpmypaintbrush.h"
+#include "core/gimptoolinfo.h"
+#include "core/mypaintbrush-brushsettings.h"
+#include "core/gimpmypaintbrush-private.hpp"
+#include "core/gimpcurve.h"
+  // for BRUSH VIEW
+#include "core/gimp.h"
+#include "core/gimpdatafactory.h"
+#include "core/gimpcontainer.h"
+#include "core/gimpcontext.h"
+#include "widgets/gimpview.h"
+#include "widgets/gimpviewrenderer.h"
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimpcontainereditor.h"
+#include "widgets/gimpcontainerview.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpcontainerbox.h"
+
+
+#include "paint/gimpmypaintoptions.h"
+
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimpspinscale.h"
+#include "widgets/gimpviewablebox.h"
+#include "widgets/gimpwidgets-constructors.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpcurveview.h"
+
+#include "widgets/gimpwidgets-utils.h"
+
+#include "gimpairbrushtool.h"
+#include "gimpclonetool.h"
+#include "gimpconvolvetool.h"
+#include "gimpdodgeburntool.h"
+#include "gimperasertool.h"
+#include "gimphealtool.h"
+#include "gimpinktool.h"
+#include "gimpmypaintoptions-gui.h"
+#include "gimppenciltool.h"
+#include "gimpperspectiveclonetool.h"
+#include "gimpsmudgetool.h"
+#include "gimptooloptions-gui.h"
+#include "gimpmypaintbrushoptions-gui.h"
+}; // extern "C"
+
+#include "gimp-intl.h"
+
+#include "base/delegators.hpp"
+#include "base/scopeguard.hpp"
+#include "base/glib-cxx-utils.hpp"
+#include "gimptooloptions-gui-cxx.hpp"
+#include "paint/gimpmypaintoptions-history.hpp"
+#include "gimpmypaint-gui-base.hpp"
+#include "gimpmypaintbrusheditor.hpp"
+
+
+///////////////////////////////////////////////////////////////////////////////
+class CurveViewActions {
+  GObject*                   receiver;
+  GimpMypaintOptions*        options;
+  MyPaintBrushSettings*      brush_setting;
+  MyPaintBrushInputSettings* input_setting;
+  GtkTreeModel*              model;
+  GtkAdjustment*             x_min_adj;
+  GtkAdjustment*             x_max_adj;
+  GtkAdjustment*             y_scale_adj;
+  Delegator::Connection*     options_notify_handler;
+  Delegator::Connection*     curve_notify_handler;
+  Delegator::Connection*     x_min_adj_changed_handler;
+  Delegator::Connection*     x_max_adj_changed_handler;
+  Delegator::Connection*     y_scale_adj_changed_handler;
+  static const int         MAXIMUM_NUM_POINTS = 8;
+
+public:
+
+  CurveViewActions(GObject* tree_view, 
+                   GObject* receiver_, 
+                   GimpMypaintOptions* opts, 
+                   gchar* setting_name_, 
+                   GObject* toggle, 
+                   GtkAdjustment* x_min_adj_,
+                   GtkAdjustment* x_max_adj_,
+                   GtkAdjustment* y_scale_adj_) 
+  {
+    GHashTableHolder<gchar*, MyPaintBrushSettings*> brush_settings_dict = mypaint_brush_get_brush_settings_dict();               
+    receiver      = receiver_;
+    options       = opts;
+//      setting_index = setting_index_;
+    brush_setting = brush_settings_dict[setting_name_];
+    model         = GTK_TREE_MODEL( gtk_tree_view_get_model( GTK_TREE_VIEW(tree_view) ) );
+    x_min_adj     = x_min_adj_;
+    x_max_adj     = x_max_adj_;
+    y_scale_adj   = y_scale_adj_; 
+    GtkTreeSelection* tree_sel = gtk_tree_view_get_selection(GTK_TREE_VIEW (tree_view));
+    input_setting = NULL;
+
+    g_object_set_cxx_object(G_OBJECT(tree_view), "behavior", this);
+
+    g_signal_connect_delegator (G_OBJECT(tree_sel), "changed", Delegator::delegator(this, &CurveViewActions::selected));
+    g_signal_connect_delegator (G_OBJECT(toggle), "toggled", Delegator::delegator(this, &CurveViewActions::toggled));
+
+    options_notify_handler      = g_signal_connect_delegator (G_OBJECT(options), "notify", Delegator::delegator(this, &CurveViewActions::notify_options));
+    x_min_adj_changed_handler   = g_signal_connect_delegator (G_OBJECT(x_min_adj), "value-changed", Delegator::delegator(this, &CurveViewActions::value_changed));
+    x_max_adj_changed_handler   = g_signal_connect_delegator (G_OBJECT(x_max_adj), "value-changed", Delegator::delegator(this, &CurveViewActions::value_changed));
+    y_scale_adj_changed_handler = g_signal_connect_delegator (G_OBJECT(y_scale_adj), "value-changed", Delegator::delegator(this, &CurveViewActions::value_changed));
+    curve_notify_handler        = NULL;
+  };
+  
+  ~CurveViewActions() {
+    if (options_notify_handler) {
+      delete options_notify_handler;
+      options_notify_handler = NULL;
+    }
+    if (curve_notify_handler) {
+      delete curve_notify_handler;
+      curve_notify_handler = NULL;
+    }
+    if (x_min_adj_changed_handler) {
+      delete x_min_adj_changed_handler;
+      x_min_adj_changed_handler = NULL;
+    }
+    if (x_max_adj_changed_handler) {
+      delete x_max_adj_changed_handler;
+      x_max_adj_changed_handler = NULL;
+    }
+    if (y_scale_adj_changed_handler) {
+      delete y_scale_adj_changed_handler;
+      y_scale_adj_changed_handler = NULL;
+    }
+  }
+  
+  void get_mapping_range(Mapping* mapping, int index, float* xmin, float* xmax, float* ymin, float* ymax) {
+    int n_points = mapping->get_n(index);
+    if (n_points > 0) {
+      float x, y;
+
+      mapping->get_point(index, 0, &x, ymin);
+      *ymax = *ymin;
+      *xmin = MIN(*xmin, x);
+      *xmax = MAX(*xmax, x);
+      for (int i = 1; i < n_points; i ++) {
+        mapping->get_point(index, i, &x, &y);
+        if (x == -1.0 && y == -1.0)
+          continue;
+        if (*xmin > x)
+          *xmin = x;
+        if (*xmax < x)
+          *xmax = x;
+        if (*ymin > y)
+          *ymin = y;
+        if (*ymax < y)
+          *ymax = y;
+      }
+    } else {
+      *xmin = *xmax = 0;
+      *ymin = *ymax = 0;
+    }
+    
+  }
+
+  void selected(GObject* event_target) {
+    GtkTreeModel *model;
+    GtkTreeIter   iter;
+
+    if (gtk_tree_selection_get_selected (GTK_TREE_SELECTION(event_target), &model, &iter)) {
+      gchar* name = NULL;
+
+      gtk_tree_model_get (model, &iter,
+                          2, &name,
+                          -1);
+
+      activate_input (name);
+      if (name)
+        g_free(name);
+    }
+  };
+  
+  Mapping* get_mapping() {
+    GimpMypaintBrush* myb = gimp_mypaint_options_get_current_brush(options);
+    GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(myb->p);
+    Mapping* mapping = priv->get_setting(brush_setting->index)->mapping;
+    return mapping;
+  }
+  
+  MyPaintBrushInputSettings* get_input_setting(gchar* input_name) {
+    GHashTableHolder<gchar*, MyPaintBrushInputSettings*> input_settings_dict(mypaint_brush_get_input_settings_dict());
+    return input_settings_dict[input_name];
+  }
+  
+  void activate_input(gchar* name) {
+    input_setting = get_input_setting(name);
+    
+    g_return_if_fail (input_setting != NULL);
+    
+    GimpCurveView* curve_view = GIMP_CURVE_VIEW(receiver);
+
+    GimpCurve* old_curve = GIMP_CURVE(gimp_curve_view_get_curve(curve_view));
+
+    if (curve_notify_handler) {
+      delete curve_notify_handler;
+      curve_notify_handler = NULL;
+    }
+    gimp_curve_view_set_curve (curve_view, NULL, NULL);
+    gimp_curve_view_remove_all_backgrounds (curve_view);
+    
+    GimpCurve* curve = GIMP_CURVE(gimp_curve_new(input_setting->displayed_name));
+    gimp_curve_set_curve_type(curve, GIMP_CURVE_SMOOTH);
+    g_object_set(G_OBJECT(curve), "n-points", MAXIMUM_NUM_POINTS, NULL); // "8" is the maximum number of control points of mypaint dynamics...
+    Mapping* mapping = get_mapping();
+    float xmin = input_setting->soft_maximum;
+    float ymin = 0.0;
+    float xmax = input_setting->soft_minimum;
+    float ymax = 0;
+    
+    if (mapping)
+      get_mapping_range(mapping, input_setting->index, &xmin, &xmax, &ymin, &ymax);
+
+    bool is_used = mapping && (ymin != ymax || ymax != 0.0);
+    
+    if (input_setting->hard_minimum == input_setting->hard_maximum) {
+      gtk_adjustment_set_lower(x_min_adj, -20);
+      gtk_adjustment_set_upper(x_min_adj,  20 - 0.1);
+      gtk_adjustment_set_lower(x_max_adj, -20 + 0.1);
+      gtk_adjustment_set_upper(x_max_adj,  20);
+      
+    } else {
+      gtk_adjustment_set_lower(x_min_adj, input_setting->hard_minimum);
+      gtk_adjustment_set_upper(x_min_adj, input_setting->hard_maximum - 0.1);
+      gtk_adjustment_set_lower(x_max_adj, input_setting->hard_minimum + 0.1);
+      gtk_adjustment_set_upper(x_max_adj, input_setting->hard_maximum);
+    }
+
+    gtk_adjustment_set_upper(y_scale_adj,  MAX(0.1, brush_setting->maximum));
+    gtk_adjustment_set_lower(y_scale_adj,  MIN(0, brush_setting->minimum));
+
+    if (is_used) {
+      mapping_to_curve(curve);
+    }
+
+    GimpRGB color = {1.0, 0., 0.};
+    gimp_curve_view_set_curve (curve_view,
+                                 curve, &color);
+    curve_notify_handler = g_signal_connect_delegator(G_OBJECT(curve), "notify::points",
+                                                      Delegator::delegator(this, &CurveViewActions::notify_curve));      
+    
+    update_range_parameters();        
+
+    gimp_curve_view_set_x_axis_label (curve_view,
+                                      input_setting->displayed_name);
+  }
+  
+  
+  void mapping_to_curve(GimpCurve* curve) {
+    g_return_if_fail( input_setting != NULL );
+
+    float xmin = input_setting->soft_maximum;
+    float ymin = 0.0;
+    float xmax = input_setting->soft_minimum;
+    float ymax = 0;
+
+    Mapping* mapping = get_mapping();
+    if (mapping) {
+      int mapping_n_points = mapping->get_n(input_setting->index);
+      int curve_n_points;
+
+      g_object_get(G_OBJECT(curve), "n-points", &curve_n_points, NULL);
+
+      get_mapping_range(mapping, input_setting->index, &xmin, &xmax, &ymin, &ymax);
+      
+      if (ymin != ymax || ymax != 0.0) {
+        
+        float xrange = xmax - xmin;
+        float yrange = ymax - ymin;
+        float x, y;
+        int i = 0;
+
+        for (; i < MAXIMUM_NUM_POINTS; i ++) {
+          gimp_curve_set_point(curve, i, -1.0, -1.0);
+        }
+
+        for (i = 0; i < mapping_n_points; i ++) {
+          mapping->get_point(input_setting->index, i, &x, &y);
+          float normalized_x = xrange != 0.0? (x - xmin) / xrange : 0.;
+          float normalized_y = yrange != 0.0? (y - ymin) / yrange : 0.;
+          int closest_index = (int)(normalized_x * curve_n_points);
+          closest_index = CLAMP(closest_index, 0, curve_n_points - 1);
+          double tmp_x, tmp_y;
+          gimp_curve_get_point(curve, closest_index, &tmp_x, &tmp_y);
+          
+          if (tmp_x < 0)
+            gimp_curve_set_point(curve, i, normalized_x, normalized_y);
+          else
+            ;;
+        }
+      }
+      
+    }
+  }
+  
+  
+  void update_range_parameters() {
+    g_return_if_fail( input_setting != NULL );
+    GimpCurveView* curve_view = GIMP_CURVE_VIEW(receiver);
+    g_return_if_fail( curve_view != NULL );
+
+    float xmin = input_setting->soft_maximum;
+    float ymin = 0;
+    float xmax = input_setting->soft_minimum;
+    float ymax;
+    Mapping* mapping = get_mapping();
+    get_mapping_range(mapping, input_setting->index, &xmin, &xmax, &ymin, &ymax);
+    g_print("xmin,xmax=%3.2f,%3.2f: ymin,ymax=%3.2f, %3.2f in [%f,%f]\n", xmin, xmax, ymin, ymax,brush_setting->minimum, brush_setting->maximum);
+
+    gdouble xmin_value = xmin;
+    gdouble xmax_value = xmax;
+    if (xmin_value == xmax_value) {
+      xmin_value = input_setting->soft_minimum;
+      xmax_value = input_setting->soft_maximum;
+      if (xmin_value == xmax_value) {
+        xmin_value = -20;
+        xmax_value = 20;
+      }
+    }
+    gdouble ymax_value = MAX(ABS(ymax), ABS(ymin));
+    
+    gtk_adjustment_set_value(x_min_adj, xmin_value);
+    gtk_adjustment_set_value(x_max_adj, xmax_value);
+    gtk_adjustment_set_value(y_scale_adj, ymax_value);
+    
+    gimp_curve_view_set_range_x(curve_view,  xmin_value, xmax_value);
+    gimp_curve_view_set_range_y(curve_view, -ymax_value, ymax_value);
+  }
+  
+  
+  void update_list() {
+    GHashTableHolder<gchar*, MyPaintBrushInputSettings*> input_settings_dict = mypaint_brush_get_input_settings_dict();
+    GtkTreeIter iter;
+    g_return_if_fail (gtk_tree_model_get_iter_first(model, &iter));
+    do {
+      gchar* name = NULL;
+
+      gtk_tree_model_get (model, &iter, 2, &name, -1);
+
+      MyPaintBrushInputSettings* s = input_settings_dict[name];
+      Mapping* mapping = get_mapping();
+      float xmin = s->soft_maximum;
+      float ymin = 0.0;
+      float xmax = s->soft_minimum;
+      float ymax = 0.0;
+      
+      if (mapping)
+        get_mapping_range(mapping, s->index, &xmin, &xmax, &ymin, &ymax);
+      
+      bool is_used = mapping && (ymin != ymax || ymax != 0.0);
+      gtk_list_store_set (GTK_LIST_STORE(model), &iter,
+                          0, is_used,
+                          -1);
+    } while (gtk_tree_model_iter_next(model, &iter));        
+  }
+
+  
+  void toggled(GObject* event_target, gchar* path) {
+    GtkTreeIter                      iter;
+
+    if (gtk_tree_model_get_iter_from_string (model, &iter, path)) {
+      gchar*   name;
+      gboolean use;
+
+      gtk_tree_model_get (model, &iter,
+                          2, &name,
+                          0, &use,
+                          -1);
+      g_print("%s is now %d\n", name, use);
+
+      Mapping* mapping = get_mapping();
+      input_setting = get_input_setting(name);
+      
+      if (mapping && input_setting) {
+        float xmin = input_setting->soft_maximum;
+        float ymin = 0.0;
+        float xmax = input_setting->soft_minimum;
+        float ymax = 0.0;
+        
+        if (mapping)
+          get_mapping_range(mapping, input_setting->index, &xmin, &xmax, &ymin, &ymax);
+        
+        bool is_used = mapping && (ymin != ymax || ymax != 0.0);
+        StringHolder signal_name = mypaint_brush_internal_name_to_signal_name(brush_setting->internal_name);
+        if (!is_used) {
+          GimpVector2 points[] = {
+            {input_setting->hard_minimum, 0},
+            {input_setting->hard_maximum, input_setting->normal }
+          };
+          gimp_mypaint_options_set_mapping_point(options, signal_name, input_setting->index, 2, points);
+        } else {
+          gimp_mypaint_options_set_mapping_point(options, signal_name, input_setting->index, 0, NULL);
+        }
+        gtk_list_store_set (GTK_LIST_STORE(model), &iter,
+                            0, !is_used,
+                            -1);
+        activate_input(name);
+      }
+    }
+  }
+  
+  
+  void notify_curve(GObject* target, GParamSpec *pspec) {
+    GimpCurve* curve = GIMP_CURVE(target);
+//      g_print("notify_curve (%lx)->(%lx)\n", (gulong)target, (gulong)receiver);
+//      g_print("block notify for %lx\n", (gulong)options);
+
+    options_notify_handler->block();
+    curve_to_mapping(curve);
+
+//      g_print("unblock notify for %lx\n", (gulong)options);
+    options_notify_handler->unblock();
+
+//      g_print("/notify_curve\n");
+  }
+  
+  void curve_to_mapping(GimpCurve* curve) {
+    Mapping* mapping = get_mapping();
+    GimpCurveView* curve_view = GIMP_CURVE_VIEW(receiver);
+    
+    g_return_if_fail(input_setting && mapping && curve);
+
+    gint n_points;
+    g_object_get(G_OBJECT(curve), "n-points", &n_points, NULL);
+    
+    int count = 0;
+    GimpVector2 points[n_points], tmp;
+
+    for (int i = 0; i < n_points; i ++) {
+      gimp_curve_get_point(curve, i, &(points[count].x), &(points[count].y));
+      if (points[count].x == -1.0 && points[count].y == -1.0)
+        continue;
+        
+      // insert by bubble sort method.
+      for (int j = count; j > 0; j --) {
+        if (points[j].x < points[j-1].x) {
+          tmp = points[j];
+          points[j]   = points[j-1];
+          points[j-1] = tmp;
+        }
+      };
+      count ++;
+    }
+    
+    gdouble xmin, xmax, ymin, ymax, xrange, yrange;
+    gimp_curve_view_get_range_x(curve_view, &xmin, &xmax);
+    gimp_curve_view_get_range_y(curve_view, &ymin, &ymax);
+    
+    xrange = xmax - xmin;
+    yrange = ymax - ymin;
+    
+    float ymin_value = ymax, ymax_value = ymin;
+
+    for (int i = 0; i < count; i ++) {
+      points[i].x = points[i].x * xrange + xmin;
+      points[i].y = points[i].y * yrange + ymin;
+      ymin_value = MIN(points[i].y, ymin_value);
+      ymax_value = MAX(points[i].y, ymax_value);
+    }
+    
+    if (ymin_value == ymax_value) {
+      count = 0;
+    }
+    
+    if (count > 1 || count == 0) {
+      StringHolder signal_name = mypaint_brush_internal_name_to_signal_name(brush_setting->internal_name);
+      gimp_mypaint_options_set_mapping_point(options, signal_name, input_setting->index, count, points);
+    }
+  }
+  
+  
+  void notify_options(GObject* config, GParamSpec *pspec) {
+    GimpCurveView* curve_view = GIMP_CURVE_VIEW(receiver);
+    
+    g_return_if_fail (curve_view);
+    
+    GimpCurve*     curve      = GIMP_CURVE(gimp_curve_view_get_curve(curve_view));
+    
+    if (curve_notify_handler) {
+      curve_notify_handler->block();
+    }
+  
+    update_list();
+
+
+    if (input_setting && strcmp(input_setting->name, pspec->name) == 0)
+      mapping_to_curve(curve);
+
+    if (curve_notify_handler) {
+      curve_notify_handler->unblock();
+    }
+  
+  }
+  
+  
+  void value_changed(GObject* target) {
+    GimpCurveView* curve_view = GIMP_CURVE_VIEW(receiver);
+    GimpCurve*     curve      = GIMP_CURVE(gimp_curve_view_get_curve(curve_view));
+
+    gdouble xmin_value = gtk_adjustment_get_value(x_min_adj);
+    gdouble xmax_value = gtk_adjustment_get_value(x_max_adj);
+    gdouble ymax_value = gtk_adjustment_get_value(y_scale_adj);
+    
+    gimp_curve_view_set_range_x(curve_view, xmin_value, xmax_value);
+    gimp_curve_view_set_range_y(curve_view, -ymax_value, ymax_value);
+
+    curve_to_mapping(curve);
+  };
+
+}; // class CurveViewActions
+
+
+//////////////////////////////////////////////////////////////////////////
+class CurveViewCreator {
+  gchar*              brush_setting_name;
+  GimpMypaintOptions* options;
+public:
+  CurveViewCreator(GimpMypaintOptions* opts, const gchar* name) 
+  {
+    options = opts;
+    brush_setting_name = g_strdup (name);
+  };
+
+  ~CurveViewCreator() {
+    if (brush_setting_name) {
+      g_free(brush_setting_name);
+    }
+  };
+  void create_view(GObject* button, GtkWidget** result);
+};
+
+
+void 
+CurveViewCreator::create_view(GObject* button, GtkWidget** result) 
+{
+  GHashTableHolder<const gchar*, MyPaintBrushSettings*> brush_settings_dict = mypaint_brush_get_brush_settings_dict();
+  GListHolder      inputs               (mypaint_brush_get_input_settings());
+  
+  MyPaintBrushSettings* setting = brush_settings_dict[brush_setting_name];
+  
+  GtkWidget* result_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
+
+  // List view  
+  GtkWidget* list_view  = gtk_tree_view_new();
+  gtk_box_pack_start(GTK_BOX(result_box), list_view, FALSE, TRUE, 0);
+  gtk_widget_show(list_view);
+  
+  gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(list_view), FALSE);
+
+  {  
+    RefPtr<GtkListStore> list_store = GTK_LIST_STORE(gtk_list_store_new(3, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_STRING));
+    gtk_tree_view_set_model (GTK_TREE_VIEW(list_view), GTK_TREE_MODEL(list_store.as(GTK_TYPE_LIST_STORE)));
+  }
+  
+  GtkListStore* store = GTK_LIST_STORE( gtk_tree_view_get_model( GTK_TREE_VIEW(list_view) ) );
+  gtk_list_store_clear (store);
+  
+  for (GList* iter = inputs; iter; iter = iter->next) {
+    
+    GtkTreeIter tree_iter;
+    MyPaintBrushInputSettings* input = reinterpret_cast<MyPaintBrushInputSettings*>(iter->data);
+    gtk_list_store_append(store, &tree_iter);
+    
+    GimpMypaintBrush* myb         = gimp_mypaint_options_get_current_brush(options);
+    GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(myb->p);
+    Mapping* mapping              = priv->get_setting(setting->index)->mapping;
+    
+    bool is_enabled = (mapping && mapping->get_n(input->index));
+    gtk_list_store_set(store, &tree_iter, 0, is_enabled, 1, input->displayed_name, 2, input->name, -1);
+  }
+
+  GtkTreeViewColumn   *column;
+  GtkCellRenderer *renderer;
+  GtkCellRenderer *used;
+
+  renderer = gtk_cell_renderer_toggle_new();
+  g_object_set (G_OBJECT(renderer),
+                "mode",        GTK_CELL_RENDERER_MODE_ACTIVATABLE,
+                "activatable", TRUE,
+                NULL);
+  column = gtk_tree_view_column_new_with_attributes(_("Input"), renderer,
+                                                    "active",  0,
+                                                    NULL);
+  gtk_tree_view_append_column(GTK_TREE_VIEW(list_view), column);
+  used = renderer;
+
+  renderer = gtk_cell_renderer_text_new();
+  column = gtk_tree_view_column_new_with_attributes(_("Input"), renderer,
+                                                    "text",  1,
+                                                    NULL);
+  gtk_tree_view_append_column(GTK_TREE_VIEW(list_view), column);
+
+  // GimpCurveView
+  GtkWidget* table = gtk_table_new(4, 4, FALSE);
+  gtk_widget_show(table);
+  gtk_box_pack_start(GTK_BOX(result_box), table, TRUE, TRUE, 0);
+
+  GtkWidget* curve_view = gimp_curve_view_new();
+  gtk_widget_set_size_request(curve_view, 250, 250);
+  g_object_set (curve_view, "border-width", 1, NULL);
+  g_object_set (curve_view, "y-axis-label", "", NULL);
+  gtk_widget_show(curve_view);
+
+  gtk_table_attach(GTK_TABLE(table), curve_view, 0, 3, 0, 3, 
+                   GtkAttachOptions(GTK_EXPAND | GTK_FILL), 
+                   GtkAttachOptions(GTK_EXPAND | GTK_FILL), 0, 0);
+ 
+  GtkAdjustment* x_min_adj    = GTK_ADJUSTMENT(gtk_adjustment_new(0.0, 0, 0.1, 0.01, 0.1, 0));
+  GtkAdjustment* x_max_adj    = GTK_ADJUSTMENT(gtk_adjustment_new(1.0, 0.9, 1.0, 0.01, 0.1, 0));
+  GtkAdjustment* y_scale_adj  = GTK_ADJUSTMENT(gtk_adjustment_new(1.0/4.0, -1.0, 1.0, 0.01, 0.1, 0)); 
+  GtkWidget*     x_min_edit   = gtk_spin_button_new(x_min_adj, 0.01, 2);
+  GtkWidget*     x_max_edit   = gtk_spin_button_new(x_max_adj, 0.01, 2);
+  GtkWidget*     y_scale_edit = gtk_spin_button_new(y_scale_adj, 0.01, 2);
+
+  gtk_widget_show(x_min_edit);
+  gtk_widget_show(x_max_edit);
+  gtk_widget_show(y_scale_edit);
+
+  gtk_table_attach(GTK_TABLE(table), x_min_edit, 0, 1, 3, 4, 
+                   GtkAttachOptions(GTK_FILL), 
+                   GtkAttachOptions(GTK_FILL), 0, 0);
+  gtk_table_attach(GTK_TABLE(table), x_max_edit, 2, 3, 3, 4, 
+                   GtkAttachOptions(GTK_FILL), 
+                   GtkAttachOptions(GTK_FILL), 0, 0);
+  gtk_table_attach(GTK_TABLE(table), y_scale_edit, 3, 4, 0, 1, 
+                   GtkAttachOptions(GTK_FILL), 
+                   GtkAttachOptions(GTK_FILL), 0, 0);
+ 
+  
+  // Event handler construction
+  GtkTreeSelection* tree_sel = gtk_tree_view_get_selection(GTK_TREE_VIEW (list_view));
+  gtk_tree_selection_set_mode(tree_sel, GTK_SELECTION_BROWSE);
+
+  CurveViewActions* select_action = new CurveViewActions(G_OBJECT(list_view), 
+                                                         G_OBJECT(curve_view), 
+                                                         options, 
+                                                         setting->internal_name, 
+                                                         G_OBJECT(used),
+                                                         x_min_adj,
+                                                         x_max_adj,
+                                                         y_scale_adj);
+
+  *result = result_box;
+}; // class CurveViewCreator
+
+////////////////////////////////////////////////////////////////////////////////
+GtkWidget*
+MypaintBrushEditorPrivate::create() {
+  GtkWidget* brushsetting_vbox;
+  
+  if (type == EXPANDER) {
+    brushsetting_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+    gtk_widget_show(brushsetting_vbox);
+  } else {
+    brushsetting_vbox = gtk_notebook_new();
+    gtk_notebook_set_scrollable (GTK_NOTEBOOK(brushsetting_vbox), TRUE);
+    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(brushsetting_vbox), GTK_POS_LEFT);
+  }
+
+  GList* setting_groups;
+  setting_groups = mypaint_brush_get_setting_group_list();
+
+  for (GList* iter = setting_groups; iter; iter = iter->next) {
+    MypaintBrushSettingGroup* group =
+      (MypaintBrushSettingGroup*)iter->data;
+
+    StringHolder bold_title(g_strdup_printf("<b>%s</b>", group->display_name));    
+    GtkWidget* group_expander;
+    
+    if (type == EXPANDER) {
+      group_expander = gtk_expander_new(bold_title.ptr());
+      gtk_expander_set_use_markup(GTK_EXPANDER(group_expander), TRUE);
+      gtk_widget_show(group_expander);
+      if (strcmp(group->name, "basic") == 0)
+        gtk_expander_set_expanded (GTK_EXPANDER(group_expander), TRUE);
+
+    }
+    
+    GtkWidget* table = gtk_table_new(3, 2 * g_list_length(group->setting_list), FALSE);
+    gtk_widget_show(table);
+
+    int count = 0;
+    for (GList* iter2 = group->setting_list; iter2; iter2 = iter2->next, count += 2) {
+      MyPaintBrushSettingEntry* entry = (MyPaintBrushSettingEntry*)iter2->data;
+      switch (entry->type) {
+        case G_TYPE_DOUBLE: {
+          MyPaintBrushSettings* s = entry->f;
+          StringHolder prop_name(mypaint_brush_internal_name_to_signal_name(s->internal_name));
+          g_print("%s : type=double\n", prop_name.ptr());
+
+          GtkWidget* h;
+          h = gimp_prop_spin_scale_new(G_OBJECT(options), prop_name.ptr(),
+                                       s->displayed_name,
+                                       0.1, 1.0, 2);
+          gtk_widget_set_tooltip_text(h, s->tooltip);
+          gtk_widget_show(h);
+
+          GtkWidget* button = gimp_stock_button_new (GIMP_STOCK_RESET, NULL);
+          gtk_button_set_relief (GTK_BUTTON (button), GTK_RELIEF_NONE);
+          gtk_image_set_from_stock (GTK_IMAGE (gtk_bin_get_child (GTK_BIN (button))),
+                                    GIMP_STOCK_RESET, GTK_ICON_SIZE_MENU);
+          gtk_widget_show (button);
+          gtk_widget_set_tooltip_text(button, _("Reset to default value"));
+
+          //g_signal_connect_...(button, "clicked,...);
+          GtkWidget* button2;
+          if (s->constant) {
+            button2 = gtk_label_new("");
+            gtk_widget_set_tooltip_text(button2, _("No additional configuration"));
+            gtk_misc_set_alignment(GTK_MISC(button2), 0.5, 0.5);
+
+          } else {
+            //        button2 = gtk_button_new_with_label("...");
+            CurveViewCreator* create_view = new CurveViewCreator(options, s->internal_name);
+            button2 = 
+              gimp_tool_options_button_with_popup(gtk_label_new("..."),
+                                                  Delegator::delegator(create_view, &CurveViewCreator::create_view),
+                                                  create_view);
+            gtk_widget_set_tooltip_text(button2, _("Add input value mapping"));
+            //g_signal_connect...(button2, "clicked", self.details_clicked_cb, adj, s)
+          }
+
+          gtk_widget_show(button2);
+          gtk_table_attach(GTK_TABLE(table), h, 0, 1, count, count+1, 
+                           GtkAttachOptions(GTK_EXPAND | GTK_FILL), 
+                           GtkAttachOptions(GTK_FILL), 0, 0);
+
+          gtk_table_attach(GTK_TABLE(table), button, 1, 2, count, count+1, 
+                           GtkAttachOptions(GTK_FILL), 
+                           GtkAttachOptions(0), 0, 0);
+
+          gtk_table_attach(GTK_TABLE(table), button2, 2, 3, count, count+1,                         
+                           GtkAttachOptions(GTK_FILL),                         
+                           GtkAttachOptions(0), 0, 0);
+          break;
+        }  
+        case G_TYPE_BOOLEAN: {
+          MyPaintBrushSwitchSettings* s = entry->b;
+          StringHolder prop_name(mypaint_brush_internal_name_to_signal_name(s->internal_name));
+          g_print("%s : type=boolean\n", prop_name.ptr());
+          GtkWidget* h;
+          h = gimp_prop_check_button_new (G_OBJECT(options), prop_name.ptr(),
+                                          s->displayed_name);
+          gtk_widget_show(h);
+          gtk_table_attach(GTK_TABLE(table), h, 0, 1, count, count+1, 
+                           GtkAttachOptions(GTK_EXPAND | GTK_FILL), 
+                           GtkAttachOptions(0), 0, 0);
+          break;
+        }
+      };
+      
+      //GtkWidget* input_editor = create_input_editor(s->internal_name);
+
+      //new ToggleWidgetAction(G_OBJECT(button2), G_OBJECT(input_editor));
+      //gtk_table_attach(GTK_TABLE(table), input_editor, 0, 3, count + 1, count + 2,
+      //                 GtkAttachOptions(GTK_FILL),
+      //                 GtkAttachOptions(GTK_FILL), 0, 0);
+      
+    }
+    if (type == EXPANDER) {
+      gtk_container_add(GTK_CONTAINER(group_expander), table);
+      gtk_box_pack_start(GTK_BOX(brushsetting_vbox) ,group_expander,TRUE,TRUE,0);
+    } else {
+      GtkWidget* editor_container = gtk_scrolled_window_new (NULL, NULL);
+      gtk_widget_set_size_request(editor_container, 400, 500);
+      gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(editor_container), table);
+      gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(editor_container), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+      gtk_widget_show(editor_container);
+      gtk_notebook_append_page(GTK_NOTEBOOK(brushsetting_vbox), editor_container, gtk_label_new(group->display_name));
+    }
+  }
+
+  if (type == TAB && page_reminder) {
+    page_reminder->bind_to(GTK_NOTEBOOK(brushsetting_vbox));
+  }
+  
+  g_object_set_cxx_object(G_OBJECT(brushsetting_vbox), "behavior-editor-private", this);
+  return brushsetting_vbox;
+}
\ No newline at end of file
diff -Naur gimp-2.8.14/app/tools/gimpmypaintbrusheditor.hpp gimp-2.8.14-new/app/tools/gimpmypaintbrusheditor.hpp
--- gimp-2.8.14/app/tools/gimpmypaintbrusheditor.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypaintbrusheditor.hpp	2015-01-27 17:48:55.386751579 +0800
@@ -0,0 +1,37 @@
+/*
+ * gimpmypaintbrusheditor.hpp
+ *
+ * Copyright (C) 2012 - seagetch
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+class MypaintBrushEditorPrivate : public MypaintGUIPrivateBase {
+private:
+  PageRemindAction* page_reminder;
+
+public:
+  enum EditorType { EXPANDER, TAB };
+  EditorType type;
+  
+public:
+  MypaintBrushEditorPrivate(GimpToolOptions* opts, EditorType _type = EXPANDER) :
+    MypaintGUIPrivateBase(opts), type(_type), page_reminder(NULL)
+  {
+  }
+  GtkWidget* create();
+  GtkWidget* create_input_editor(const gchar* prop_name);
+  void set_page_reminder(PageRemindAction* reminder) {
+    page_reminder = reminder;
+  }
+};
diff -Naur gimp-2.8.14/app/tools/gimpmypaintbrushoptions-gui.cpp gimp-2.8.14-new/app/tools/gimpmypaintbrushoptions-gui.cpp
--- gimp-2.8.14/app/tools/gimpmypaintbrushoptions-gui.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypaintbrushoptions-gui.cpp	2015-01-27 17:48:55.387751579 +0800
@@ -0,0 +1,333 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+extern "C" {
+#include "config.h"
+
+#include <glib-object.h>
+#include <glib/gprintf.h>
+#include <gtk/gtk.h>
+
+#include "tools-types.h"
+
+#include "base/temp-buf.h"
+
+#include "libgimpmath/gimpmath.h"
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "core/gimp.h"
+#include "core/gimpcontainer.h"
+#include "core/gimpcontext.h"
+#include "core/gimptooloptions.h"
+#include "core/gimpdatafactory.h"
+#include "core/gimpmypaintbrush.h"
+
+#include "widgets/gimpview.h"
+#include "widgets/gimpviewrenderer.h"
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimpcontainereditor.h"
+#include "widgets/gimpcontainerview.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpcontainerbox.h"
+
+#include "gimptooloptions-gui.h"
+#include "gimpbrushoptions-gui.h"
+
+#include "gimp-intl.h"
+
+};
+#include "base/delegators.hpp"
+#include "base/glib-cxx-utils.hpp"
+#include "gimptooloptions-gui-cxx.hpp"
+#include "core/gimpmypaintbrush-private.hpp"
+#include "paint/gimpmypaintoptions-history.hpp"
+
+
+class MypaintPopupPrivate {
+  static const int MYPAINT_BRUSH_VIEW_SIZE = 256;
+  static const int HISTORY_PREVIEW_SIZE = 24;
+
+  GimpContainer*         container;
+  GimpContext*           context;
+  GtkListStore*          store;
+  PageRemindAction       page_reminder;
+  Delegator::Connection* brush_changed_handler;
+  
+public:
+  MypaintPopupPrivate(GimpContainer* ctn, GimpContext* ctx) : 
+    page_reminder(NULL) {
+    container = ctn;
+    context   = ctx;
+    brush_changed_handler = NULL;
+  }
+  
+  ~MypaintPopupPrivate();
+  void create(GObject  *button,
+              GtkWidget **result);
+  void destroy(GObject* object);
+  void update_brush (GObject *adjustment);
+  void update_history ();
+  void notify_brush (GObject *brush, GParamSpec *pspec);
+  void brush_changed (GObject *object, GimpData *brush_data);
+  void history_cursor_changed (GObject *object);
+
+};
+
+
+void
+MypaintPopupPrivate::update_brush (GObject* object)
+{
+  GtkAdjustment *adjustment = GTK_ADJUSTMENT(object);
+  gdouble              d_value_brush;
+  gdouble              d_value_adj;
+  gint                 i_value_brush;
+  gint                 i_value_adj;
+  GimpMypaintBrush    *brush;
+  gchar               *prop_name;
+  GtkAdjustment       *adj;
+
+  g_return_if_fail (G_IS_OBJECT (adj));
+  g_return_if_fail (G_IS_OBJECT (context));
+
+  brush = gimp_context_get_mypaint_brush (context);
+
+}
+
+void
+MypaintPopupPrivate::notify_brush (GObject* object,
+                                   GParamSpec         *pspec)
+{
+  GimpMypaintBrush *brush = GIMP_MYPAINT_BRUSH (object);
+  GtkAdjustment *adj     = NULL;
+  gdouble        d_value = 0.0;
+  gint           i_value = 0;
+  
+  g_print ("notify_brush: %s\n", pspec->name);
+
+  if (! strcmp (pspec->name, "shape"))
+    {
+    }
+  else
+    {
+    }
+}
+
+void
+MypaintPopupPrivate::update_history ()
+{
+  GimpMypaintOptionsHistory* history = GimpMypaintOptionsHistory::get_singleton();
+  int history_size = history->get_brush_history_size();
+  gtk_list_store_clear(store);
+  for (int i = 0; i < history_size; i ++) {
+    GtkTreeIter iter;
+    GimpMypaintBrush* brush = history->get_brush(i);
+    if (brush) {
+      gchar* name;
+      g_object_get(G_OBJECT(brush), "name", &name, NULL);
+      g_print("%d: brush %s\n", i, name);
+      GimpMypaintBrushPrivate* priv = reinterpret_cast<GimpMypaintBrushPrivate*>(brush->p);
+      gtk_list_store_append(store, &iter);
+      if (context) {
+        GdkPixbuf* pixbuf = gimp_viewable_get_new_pixbuf(GIMP_VIEWABLE(brush), 
+                                                         context, 
+                                                         HISTORY_PREVIEW_SIZE, 
+                                                         HISTORY_PREVIEW_SIZE);
+        gtk_list_store_set(store, &iter, 0, pixbuf, -1);
+      }
+      gtk_list_store_set(store, &iter, 1, name, 2, brush, -1);
+    }
+  }
+}
+
+void
+MypaintPopupPrivate::brush_changed (GObject*  object,
+                                    GimpData* brush_data)
+{
+  GimpMypaintBrush        *brush        = GIMP_MYPAINT_BRUSH (brush_data);
+  gdouble                  radius       = 0.0;
+  gdouble                  ratio        = 0.0;
+  gdouble                  angle        = 0.0;
+  gboolean                 editable     = false;
+
+  update_history();
+  g_print("brush changed\n");
+}
+
+void
+MypaintPopupPrivate::history_cursor_changed (GObject*  object)
+{
+  GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(object));
+  GtkTreeModel* model;
+  GtkTreeIter   iter;
+  if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
+    GimpMypaintBrush* brush = NULL;
+    gtk_tree_model_get(model, &iter, 2, &brush, -1);
+    if (brush)
+      gimp_context_set_mypaint_brush(context, brush);
+  }
+}
+
+MypaintPopupPrivate::~MypaintPopupPrivate ()
+{
+}
+
+void
+MypaintPopupPrivate::destroy (GObject* object)
+{
+  if (container) {
+    g_object_unref (G_OBJECT (container));
+    container = NULL;
+  }
+
+  if (context) {
+    if (brush_changed_handler) {
+      delete brush_changed_handler;
+      brush_changed_handler = NULL;
+    }
+  }
+}
+
+void
+MypaintPopupPrivate::create (GObject* object,
+                             GtkWidget **result)
+{
+  GtkButton*                     button = GTK_BUTTON(object);
+  GimpContainerEditor           *editor;
+  GimpMypaintBrush              *brush;
+  GtkWidget                     *vbox;
+  GtkWidget                     *frame;
+  GtkWidget                     *box;
+  GtkWidget                     *table;
+  GtkWidget                     *frame2;
+  GtkWidget                     *history;
+  GimpViewType                   view_type = GIMP_VIEW_TYPE_GRID;
+  GimpViewSize                   view_size = GIMP_VIEW_SIZE_LARGE;
+  gint                           view_border_width = 1;
+  gint                           default_view_size = GIMP_VIEW_SIZE_LARGE;
+  GimpToolOptionsTableIncrement  inc = gimp_tool_options_table_increment (FALSE);
+  GList                         *children;
+  GtkAdjustment                 *adj = NULL;
+  
+  container = gimp_data_factory_get_container (context->gimp->mypaint_brush_factory);
+  brush     = gimp_context_get_mypaint_brush (context);
+
+  g_object_ref(G_OBJECT(container));
+  
+  g_return_if_fail (GIMP_IS_CONTAINER (container));
+  g_return_if_fail (GIMP_IS_CONTEXT (context));
+  g_return_if_fail (view_size >  0 &&
+                    view_size <= GIMP_VIEWABLE_MAX_BUTTON_SIZE);
+  g_return_if_fail (view_border_width >= 0 &&
+                    view_border_width <= GIMP_VIEW_MAX_BORDER_WIDTH);
+
+  *result    = gtk_notebook_new ();
+  gtk_widget_show (*result);
+  
+  editor = GIMP_CONTAINER_EDITOR (
+    g_object_new (GIMP_TYPE_CONTAINER_EDITOR,
+      "view-type", view_type,
+      "container", container,
+      "context",   context,
+      "view-size", view_size,
+      "view-border-width", view_border_width,
+      NULL));
+  gimp_container_view_set_reorderable (GIMP_CONTAINER_VIEW (editor->view),
+                                       FALSE);
+
+  gimp_container_box_set_size_request (GIMP_CONTAINER_BOX (editor->view),
+                                       6  * (default_view_size +
+                                             2 * view_border_width),
+                                       10 * (default_view_size +
+                                             2 * view_border_width));
+
+  gtk_notebook_insert_page (GTK_NOTEBOOK (*result), GTK_WIDGET (editor), 
+                            gtk_label_new(_("Preset")),0);
+  gtk_widget_show (GTK_WIDGET (editor));
+
+  // Custom brush history view.
+  GtkTreeViewColumn* column;
+  store   = gtk_list_store_new(3, GDK_TYPE_PIXBUF, G_TYPE_STRING, GIMP_TYPE_MYPAINT_BRUSH);
+  history = gtk_tree_view_new_with_model(GTK_TREE_MODEL(store));
+  
+  GtkCellRenderer* renderer;
+  renderer = gtk_cell_renderer_pixbuf_new();
+  column = gtk_tree_view_column_new_with_attributes("Icon", renderer, "pixbuf", 0, NULL);
+  gtk_tree_view_append_column(GTK_TREE_VIEW(history), column);
+
+  renderer = gtk_cell_renderer_text_new();
+  column = gtk_tree_view_column_new_with_attributes("Name", renderer, "text", 1, NULL);
+  gtk_tree_view_append_column(GTK_TREE_VIEW(history), column);
+
+  g_signal_connect_delegator(G_OBJECT(history), "cursor-changed",
+                             Delegator::delegator(this, &MypaintPopupPrivate::history_cursor_changed));
+
+  gtk_widget_show (GTK_WIDGET (history));
+  gtk_notebook_insert_page (GTK_NOTEBOOK (*result), GTK_WIDGET (history), 
+                            gtk_label_new(_("Custom")),1);
+
+  page_reminder.bind_to(GTK_NOTEBOOK (*result));
+
+  
+
+  brush_changed_handler = 
+    g_signal_connect_delegator (G_OBJECT(context),
+                                gimp_context_type_to_signal_name (GIMP_TYPE_MYPAINT_BRUSH),
+                                Delegator::delegator(this, &MypaintPopupPrivate::brush_changed));
+
+/*
+//  g_signal_connect (brush, "notify", G_CALLBACK (notify_brush), p);
+*/
+  if (context && brush)
+    brush_changed (G_OBJECT(context), GIMP_DATA(brush));
+  children = gtk_container_get_children (GTK_CONTAINER (table));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+  
+  g_signal_connect_delegator (G_OBJECT (*result), "destroy", 
+                              Delegator::delegator(this, &MypaintPopupPrivate::destroy));
+}
+
+extern "C" {
+/*  public functions  */
+GtkWidget*
+gimp_mypaint_brush_button_with_popup (GObject *config)
+{
+  GimpContainer *container;
+  GimpContext   *context;
+  GimpViewSize   view_size = GIMP_VIEW_SIZE_SMALL;
+  const gchar        *prop_name;
+  GtkWidget     *label_widget;
+
+  context   = GIMP_CONTEXT (config);
+  container = gimp_data_factory_get_container (context->gimp->mypaint_brush_factory);
+  
+  g_return_val_if_fail (GIMP_IS_CONTAINER (container), NULL);
+  g_return_val_if_fail (GIMP_IS_CONTEXT (context), NULL);
+  g_return_val_if_fail (view_size >  0 &&
+                        view_size <= GIMP_VIEWABLE_MAX_BUTTON_SIZE, NULL);
+
+  prop_name = gimp_context_type_to_prop_name (gimp_container_get_children_type (container));
+
+  label_widget = gimp_prop_view_new (G_OBJECT (context), prop_name,
+                                     context, view_size);
+  gtk_widget_show (label_widget);
+  
+  MypaintPopupPrivate* priv = new MypaintPopupPrivate(container, context);
+  
+  return gimp_tool_options_button_with_popup (label_widget,
+                                               Delegator::delegator(priv, &MypaintPopupPrivate::create),
+                                               priv);
+}
+};
diff -Naur gimp-2.8.14/app/tools/gimpmypaintbrushoptions-gui.h gimp-2.8.14-new/app/tools/gimpmypaintbrushoptions-gui.h
--- gimp-2.8.14/app/tools/gimpmypaintbrushoptions-gui.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypaintbrushoptions-gui.h	2015-01-27 17:48:55.387751579 +0800
@@ -0,0 +1,23 @@
+/* GIMP-painter - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_BRUSH_OPTIONS_GUI_H__
+#define __GIMP_MYPAINT_BRUSH_OPTIONS_GUI_H__
+
+GtkWidget *gimp_mypaint_brush_button_with_popup (GObject *config);
+
+#endif  /*  __GIMP_MYPAINT_BRUSH_OPTIONS_GUI_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpmypaint-gui-base.hpp gimp-2.8.14-new/app/tools/gimpmypaint-gui-base.hpp
--- gimp-2.8.14/app/tools/gimpmypaint-gui-base.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypaint-gui-base.hpp	2015-01-27 17:48:55.385751579 +0800
@@ -0,0 +1,123 @@
+/*
+ * gimpmypaint-gui-base.hpp
+ *
+ * Copyright (C) 2012 - seagetch
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_GUI_BASE_HPP__
+#define __GIMP_MYPAINT_GUI_BASE_HPP__
+
+///////////////////////////////////////////////////////////////////////////////
+class MypaintGUIPrivateBase {
+protected:
+  GimpMypaintOptions* options;
+
+  class MypaintOptionsPropertyGUIPrivate {
+    typedef MypaintOptionsPropertyGUIPrivate Class;
+    GimpMypaintOptions* options;
+    MyPaintBrushSettings* setting;
+    
+    GtkWidget* widget;
+    gchar*   property_name;
+    gchar*   internal_name;
+    Delegator::Connection* notify_handler;
+    Delegator::Connection* value_changed_handler;
+
+  public:
+    MypaintOptionsPropertyGUIPrivate(GimpMypaintOptions* opts,
+                                     GHashTable* dict,
+                                     const gchar* name) 
+    {
+      StringHolder name_replaced(mypaint_brush_signal_name_to_internal_name(name));
+
+      setting = reinterpret_cast<MyPaintBrushSettings*>(g_hash_table_lookup(dict, name_replaced.ptr()));
+      if (!setting) {
+        g_print("property %s is not found in the lookup dictionary.\n", name_replaced.ptr());
+      }
+      internal_name = (gchar*)g_strdup(name);
+      property_name = (gchar*)g_strdup_printf("notify::%s", name);
+      options = opts;
+      g_object_add_weak_pointer(G_OBJECT(options), (void**)&options);
+      notify_handler = value_changed_handler = NULL;
+    }
+      
+    ~MypaintOptionsPropertyGUIPrivate() {
+      if (property_name)
+        g_free(property_name);
+
+      if (internal_name)
+        g_free(internal_name);
+      
+/*
+      if (widget && value_changed_closure) {
+	  gulong handler_id = g_signal_handler_find(gpointer(widget), G_SIGNAL_MATCH_CLOSURE, 0, 0, value_changed_closure, NULL, NULL);
+	  g_signal_handler_disconnect(gpointer(widget), handler_id);
+	  value_changed_closure = NULL;
+      }
+
+      if (options && notify_closure) {
+        gulong handler_id = g_signal_handler_find(gpointer(optios), G_SIGNAL_MATCH_CLOSURE, 0, 0, notify_closure, NULL, NULL);
+	g_signal_handler_disconnect(gpointer(options), handler_id);
+	value_changed_closure = NULL;
+      }*/
+    }
+      
+    void notify(GObject* object) {
+      gdouble value;
+      g_object_get(G_OBJECT(options), internal_name, &value, NULL);
+    }
+
+    void value_changed(GObject* object) {
+      gdouble value = gtk_spin_button_get_value(GTK_SPIN_BUTTON(object));
+      g_object_set(G_OBJECT(options), property_name, value, NULL);
+    }
+      
+    GtkWidget* create() {
+      gdouble range = setting->maximum - setting->minimum;
+      widget  = gimp_prop_spin_scale_new (G_OBJECT(options), 
+                                          internal_name,
+                                          _(setting->displayed_name),
+                                          range / 1000.0, range / 100.0, 2);
+      g_object_add_weak_pointer(G_OBJECT(widget), (void**)&widget);
+      gimp_spin_scale_set_scale_limits (GIMP_SPIN_SCALE (widget), 
+                                        setting->minimum, 
+                                        setting->maximum);
+
+/*      value_changed_closure = 
+        g_signal_connect_delegator(G_OBJECT(widget),
+				   "value-changed",
+				   Delegator::delegator(this, &Class::value_changed));
+      notify_closure = 
+        g_signal_connect_delegator(G_OBJECT(options),
+				   property_name,
+				   Delegator::delegator(this, &Class::notify));*/
+      g_object_set_cxx_object (G_OBJECT(widget), "behavior", this);
+//      gtk_widget_set_size_request (widget, 200, -1);
+      return widget;
+    }
+  };
+
+public:
+  MypaintGUIPrivateBase(GimpToolOptions* opts)
+  {
+    options = GIMP_MYPAINT_OPTIONS(opts);
+  }
+
+  virtual ~MypaintGUIPrivateBase() {}
+  virtual GtkWidget* create() = 0;
+};
+
+#endif //__GIMP_MYPAINT_GUI_BASE_HPP__
\ No newline at end of file
diff -Naur gimp-2.8.14/app/tools/gimpmypaintoptions-gui.cpp gimp-2.8.14-new/app/tools/gimpmypaintoptions-gui.cpp
--- gimp-2.8.14/app/tools/gimpmypaintoptions-gui.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypaintoptions-gui.cpp	2015-01-27 17:48:55.388751579 +0800
@@ -0,0 +1,491 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern "C" {
+#include "config.h"
+
+#include <glib.h>
+#include <glib/gprintf.h>
+#include <gtk/gtk.h>
+
+#include "libgimpmath/gimpmath.h"
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "tools-types.h"
+
+#include "base/temp-buf.h"
+
+#include "core/gimpbrush.h"
+#include "core/gimpmypaintbrush.h"
+#include "core/gimptoolinfo.h"
+#include "core/mypaintbrush-brushsettings.h"
+#include "core/gimpmypaintbrush-private.hpp"
+#include "core/gimpcurve.h"
+  // for BRUSH VIEW
+#include "core/gimp.h"
+#include "core/gimpdatafactory.h"
+#include "core/gimpcontainer.h"
+#include "core/gimpcontext.h"
+#include "widgets/gimpview.h"
+#include "widgets/gimpviewrenderer.h"
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimpcontainereditor.h"
+#include "widgets/gimpcontainerview.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpcontainerbox.h"
+
+
+#include "paint/gimpmypaintoptions.h"
+
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimpspinscale.h"
+#include "widgets/gimpviewablebox.h"
+#include "widgets/gimpwidgets-constructors.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpcurveview.h"
+
+#include "widgets/gimpwidgets-utils.h"
+
+#include "gimpairbrushtool.h"
+#include "gimpclonetool.h"
+#include "gimpconvolvetool.h"
+#include "gimpdodgeburntool.h"
+#include "gimperasertool.h"
+#include "gimphealtool.h"
+#include "gimpinktool.h"
+#include "gimpmypaintoptions-gui.h"
+#include "gimppenciltool.h"
+#include "gimpperspectiveclonetool.h"
+#include "gimpsmudgetool.h"
+#include "gimptooloptions-gui.h"
+#include "gimpmypaintbrushoptions-gui.h"
+}; // extern "C"
+
+#include "base/delegators.hpp"
+#include "base/scopeguard.hpp"
+#include "base/glib-cxx-utils.hpp"
+#include "gimptooloptions-gui-cxx.hpp"
+#include "paint/gimpmypaintoptions-history.hpp"
+
+#include "gimp-intl.h"
+
+#include "gimpmypaint-gui-base.hpp"
+#include "gimpmypaintbrusheditor.hpp"
+
+///////////////////////////////////////////////////////////////////////////////
+class MypaintDetailOptionsPopupPrivate {
+  static const int BRUSH_VIEW_SIZE = 256;
+
+  GimpContainer*         container;
+  GimpContext*           context;
+  Delegator::Connection* brush_changed_handler;
+  PageRemindAction       page_reminder;
+  
+public:
+  MypaintDetailOptionsPopupPrivate(GimpContainer* ctn, GimpContext* ctx) 
+    : page_reminder(NULL)
+  {
+    container = ctn;
+    context   = ctx;
+
+    brush_changed_handler = NULL;
+  }
+  
+  ~MypaintDetailOptionsPopupPrivate();
+  void create(GObject  *button,
+              GtkWidget **result);
+  void destroy(GObject* object);
+  void update_brush (GObject *adjustment);
+  void notify_brush (GObject *brush, GParamSpec *pspec);
+  void brush_changed (GObject *object, GimpData *brush_data);
+
+};
+
+
+void
+MypaintDetailOptionsPopupPrivate::update_brush (GObject* object)
+{
+  GtkAdjustment *adjustment = GTK_ADJUSTMENT(object);
+  gdouble              d_value_brush;
+  gdouble              d_value_adj;
+  gint                 i_value_brush;
+  gint                 i_value_adj;
+  GimpMypaintBrush    *brush;
+  gchar               *prop_name;
+  GtkAdjustment       *adj;
+
+  g_return_if_fail (G_IS_OBJECT (adj));
+  g_return_if_fail (G_IS_OBJECT (context));
+
+  brush = gimp_context_get_mypaint_brush (context);
+
+}
+
+void
+MypaintDetailOptionsPopupPrivate::notify_brush (GObject* object,
+                                   GParamSpec         *pspec)
+{
+  GimpMypaintBrush *brush = GIMP_MYPAINT_BRUSH (object);
+  GtkAdjustment *adj     = NULL;
+  gdouble        d_value = 0.0;
+  gint           i_value = 0;
+  
+  g_print ("notify_brush: %s\n", pspec->name);
+
+  if (! strcmp (pspec->name, "shape"))
+    {
+    }
+  else
+    {
+    }
+}
+
+void
+MypaintDetailOptionsPopupPrivate::brush_changed (GObject*  object,
+                                    GimpData* brush_data)
+{
+  GimpMypaintBrush        *brush        = GIMP_MYPAINT_BRUSH (brush_data);
+  gdouble                  radius       = 0.0;
+  gdouble                  ratio        = 0.0;
+  gdouble                  angle        = 0.0;
+  gboolean                 editable     = false;
+
+  g_print("brush changed\n");
+
+}
+
+MypaintDetailOptionsPopupPrivate::~MypaintDetailOptionsPopupPrivate ()
+{
+}
+
+void
+MypaintDetailOptionsPopupPrivate::destroy (GObject* object)
+{
+  if (container) {
+    g_object_unref (G_OBJECT (container));
+    container = NULL;
+  }
+
+  if (context) {
+    if (brush_changed_handler) {
+      delete brush_changed_handler;
+      brush_changed_handler = NULL;
+    }
+  }
+}
+
+void
+MypaintDetailOptionsPopupPrivate::create (GObject* object,
+                             GtkWidget **result)
+{
+  GtkButton*                     button = GTK_BUTTON(object);
+  GimpContainerEditor           *editor;
+  GimpBrush                     *brush;
+  GtkWidget                     *vbox;
+  GtkWidget                     *frame;
+  GtkWidget                     *box;
+  GtkWidget                     *table;
+  GtkWidget                     *frame2;
+  GimpViewType                   view_type = GIMP_VIEW_TYPE_GRID;
+  GimpViewSize                   view_size = GIMP_VIEW_SIZE_MEDIUM;
+  gint                           view_border_width = 1;
+  gint                           default_view_size = GIMP_VIEW_SIZE_MEDIUM;
+  GimpToolOptionsTableIncrement  inc = gimp_tool_options_table_increment (FALSE);
+  GList                         *children;
+  GtkAdjustment                 *adj = NULL;
+
+  // 
+  // Brush Selector
+  //
+  container = gimp_data_factory_get_container (context->gimp->brush_factory);
+  brush     = gimp_context_get_brush (context);
+
+  g_object_ref(G_OBJECT(container));
+  
+  g_return_if_fail (GIMP_IS_CONTAINER (container));
+  g_return_if_fail (GIMP_IS_CONTEXT (context));
+  g_return_if_fail (view_size >  0 &&
+                    view_size <= GIMP_VIEWABLE_MAX_BUTTON_SIZE);
+  g_return_if_fail (view_border_width >= 0 &&
+                    view_border_width <= GIMP_VIEW_MAX_BORDER_WIDTH);
+
+  *result    = gtk_hbox_new (FALSE, 1);
+  gtk_widget_show (*result);
+  
+  editor = GIMP_CONTAINER_EDITOR (
+    g_object_new (GIMP_TYPE_CONTAINER_EDITOR,
+      "view-type", view_type,
+      "container", container,
+      "context",   context,
+      "view-size", view_size,
+      "view-border-width", view_border_width,
+      NULL));
+  gimp_container_view_set_reorderable (GIMP_CONTAINER_VIEW (editor->view),
+                                       FALSE);
+
+  gimp_container_box_set_size_request (GIMP_CONTAINER_BOX (editor->view),
+                                       6  * (default_view_size +
+                                             2 * view_border_width),
+                                       10 * (default_view_size +
+                                             2 * view_border_width));
+
+  gtk_box_pack_start (GTK_BOX (*result), GTK_WIDGET (editor), TRUE, TRUE, 0);      
+  gtk_widget_show (GTK_WIDGET (editor));
+  
+
+  brush_changed_handler = 
+    g_signal_connect_delegator (G_OBJECT(context),
+                                gimp_context_type_to_signal_name (GIMP_TYPE_BRUSH),
+                                Delegator::delegator(this, &MypaintDetailOptionsPopupPrivate::brush_changed));
+
+/*
+//  g_signal_connect (brush, "notify", G_CALLBACK (notify_brush), p);
+*/
+  if (context && brush)
+    brush_changed (G_OBJECT(context), GIMP_DATA(brush));
+  children = gtk_container_get_children (GTK_CONTAINER (table));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+  
+  g_signal_connect_delegator (G_OBJECT (*result), "destroy", 
+                              Delegator::delegator(this, &MypaintDetailOptionsPopupPrivate::destroy));
+
+  //
+  // Dynamics Editor
+  // 
+  MypaintBrushEditorPrivate* editor_priv = new MypaintBrushEditorPrivate(GIMP_TOOL_OPTIONS(context), MypaintBrushEditorPrivate::TAB);
+  editor_priv->set_page_reminder(&page_reminder);
+  GtkWidget* dynamics_editor = editor_priv->create();
+  gtk_widget_show(dynamics_editor);
+  
+  gtk_box_pack_start (GTK_BOX (*result), GTK_WIDGET (dynamics_editor), TRUE, TRUE, 0);      
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+class MypaintOptionsGUIPrivate : public MypaintGUIPrivateBase {
+  bool is_toolbar;
+  
+public:
+  MypaintOptionsGUIPrivate(GimpToolOptions* options, bool toolbar);
+  GtkWidget* create();
+
+  void destroy(GObject* o);
+  void reset_size(GObject *o);
+};
+
+
+MypaintOptionsGUIPrivate::
+MypaintOptionsGUIPrivate(GimpToolOptions* opts, bool toolbar) :
+  MypaintGUIPrivateBase(opts), is_toolbar(toolbar)
+{
+}
+
+GtkWidget *
+MypaintOptionsGUIPrivate::create ()
+{
+  GObject            *config  = G_OBJECT (options);
+  GtkWidget          *vbox    = gimp_tool_options_gui_full (GIMP_TOOL_OPTIONS(options), is_toolbar);
+  GtkWidget          *hbox;
+  GtkWidget          *frame;
+  GtkWidget          *table;
+  GtkWidget          *menu;
+  GtkWidget          *scale;
+  GtkWidget          *label;
+  GtkWidget          *button;
+  GtkWidget          *incremental_toggle = NULL;
+  GType             tool_type;
+  GList            *children;
+  GimpToolOptionsTableIncrement inc = gimp_tool_options_table_increment (is_toolbar);  
+
+  tool_type = GIMP_TOOL_OPTIONS(options)->tool_info->tool_type;
+  GHashTableHolder<gchar*, MyPaintBrushSettings*> brush_settings_dict(mypaint_brush_get_brush_settings_dict());
+
+  /*  the main table  */
+  table = gimp_tool_options_table (3, is_toolbar);
+  gtk_table_set_col_spacings (GTK_TABLE (table), 2);
+  gtk_box_pack_start (GTK_BOX (vbox), table, FALSE, FALSE, 0);
+  gtk_widget_show (table);
+
+  /*  the opacity scale  */
+  scale = gimp_prop_opacity_spin_scale_new (config, "opaque",
+                                            _("Opacity"));
+//  gtk_widget_set_size_request (scale, 200, -1);
+  gtk_box_pack_start (GTK_BOX (vbox), scale, FALSE, FALSE, 0);
+  gtk_widget_show (scale);
+
+  /*  the brush  */
+    {
+      GtkWidget *button;
+      MypaintOptionsPropertyGUIPrivate* scale_obj;
+      
+      if (is_toolbar)
+        button = gimp_mypaint_brush_button_with_popup (config);
+      else {
+        button = gimp_mypaint_brush_button_with_popup (config);
+/*        button = gimp_prop_brush_box_new (NULL, GIMP_CONTEXT(options),
+                                          _("MypaintBrush"), 2,
+                                          "mypaint-brush-view-type", "mypaint-brush-view-size",
+                                          "gimp-mypaint-brush-editor");*/
+      }
+      gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
+      gtk_widget_show (button);
+
+      /* brush size */
+      if (is_toolbar)
+        hbox = vbox;
+      else {
+        hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
+        gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
+        gtk_widget_show (hbox);
+      }
+
+      scale_obj = 
+        new MypaintOptionsPropertyGUIPrivate(options, brush_settings_dict.ptr(), "radius-logarithmic");
+      scale = scale_obj->create();
+      gtk_box_pack_start (GTK_BOX (hbox), scale, TRUE, TRUE, 0);
+      gtk_widget_show (scale);
+
+      button = gimp_stock_button_new (GIMP_STOCK_RESET, NULL);
+      gtk_button_set_relief (GTK_BUTTON (button), GTK_RELIEF_NONE);
+      gtk_image_set_from_stock (GTK_IMAGE (gtk_bin_get_child (GTK_BIN (button))),
+                                GIMP_STOCK_RESET, GTK_ICON_SIZE_MENU);
+      gtk_box_pack_start (GTK_BOX (hbox), button, FALSE, FALSE, 0);
+      gtk_widget_show (button);
+
+      g_signal_connect_delegator (G_OBJECT(button), "clicked",
+                                  Delegator::delegator(this, &MypaintOptionsGUIPrivate::reset_size));
+
+      gimp_help_set_help_data (button,
+                               _("Reset size to brush's native size"), NULL);
+
+      if (is_toolbar)
+        hbox = vbox;
+      else {
+        hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
+        gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
+        gtk_widget_show (hbox);
+      }
+
+      scale_obj = 
+        new MypaintOptionsPropertyGUIPrivate(options, brush_settings_dict.ptr(), "slow-tracking");
+      scale = scale_obj->create();
+      gtk_box_pack_start (GTK_BOX (hbox), scale, TRUE, TRUE, 0);
+      gtk_widget_show (scale);
+
+      if (is_toolbar)
+        hbox = vbox;
+      else {
+        hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
+        gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
+        gtk_widget_show (hbox);
+      }
+      scale_obj = 
+        new MypaintOptionsPropertyGUIPrivate(options, brush_settings_dict.ptr(), "hardness");
+      scale = scale_obj->create();
+      gtk_box_pack_start (GTK_BOX (hbox), scale, TRUE, TRUE, 0);
+      gtk_widget_show (scale);
+
+//      frame = dynamics_options_gui (options, tool_type, is_toolbar);
+//      gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
+//      gtk_widget_show (frame);
+    }
+
+  if (is_toolbar) {
+    children = gtk_container_get_children (GTK_CONTAINER (vbox));  
+    gimp_tool_options_setup_popup_layout (children, FALSE);
+
+    GimpViewSize   view_size = GIMP_VIEW_SIZE_MEDIUM;
+    GimpContext*   context   = GIMP_CONTEXT (config);
+    GimpContainer* container = gimp_data_factory_get_container (context->gimp->brush_factory);
+    
+    const gchar* prop_name = gimp_context_type_to_prop_name (gimp_container_get_children_type (container));
+
+    GtkWidget* label_widget = gimp_prop_view_new (G_OBJECT (context), prop_name,
+                                     context, view_size);
+    gtk_widget_show (label_widget);
+  
+    MypaintDetailOptionsPopupPrivate* priv = new MypaintDetailOptionsPopupPrivate(container, context);
+  
+    GtkWidget* brush_button = gimp_tool_options_button_with_popup (label_widget,
+                                Delegator::delegator(priv, &MypaintDetailOptionsPopupPrivate::create),
+                                priv);
+    gtk_box_pack_start(GTK_BOX(hbox), brush_button, FALSE, FALSE, 0);
+    gtk_widget_show(brush_button);
+   }
+
+  g_object_set_cxx_object(G_OBJECT(vbox), "behavior-options-private", this);
+  gtk_widget_show(vbox);
+  return vbox;
+}
+
+void
+MypaintOptionsGUIPrivate::reset_size (GObject* o)
+{
+/*
+ GimpMypaintBrush *brush = gimp_context_get_brush (GIMP_CONTEXT (paint_options));
+
+ if (brush)
+   {
+     g_object_set (paint_options,
+                   "brush-size", (gdouble) MAX (brush->mask->width,
+                                                brush->mask->height),
+                   NULL);
+   }
+*/
+}
+///////////////////////////////////////////////////////////////////////////////
+/*  public functions  */
+extern "C" {
+
+GtkWidget *
+gimp_mypaint_options_gui (GimpToolOptions *tool_options)
+{
+  g_print("MYPAINTOPTIONSGUI::create...\n");
+  MypaintOptionsGUIPrivate* priv = new MypaintOptionsGUIPrivate(tool_options, false);
+  MypaintBrushEditorPrivate* editor_priv = new MypaintBrushEditorPrivate(tool_options);
+  GtkWidget* priv_widget = priv->create();
+  GtkWidget* editor_widget = editor_priv->create();
+
+  GtkWidget* options_box = gtk_notebook_new();
+  gtk_widget_show (options_box);
+//  gtk_notebook_set_show_tabs(GTK_NOTEBOOK(options_box), FALSE);
+
+//  gtk_notebook_insert_page(GTK_NOTEBOOK(options_box), brushsetting_vbox, label, 0);
+//  gtk_notebook_insert_page(GTK_NOTEBOOK(editor->options_box), brushinputs, label, 1);
+//  gtk_notebook_insert_page(GTK_NOTEBOOK(editor->options_box), brushicon, label, 2);
+  gtk_notebook_insert_page(GTK_NOTEBOOK(options_box), priv_widget, gtk_label_new(_("Basic")), 0);
+  gtk_notebook_insert_page(GTK_NOTEBOOK(options_box), editor_widget, gtk_label_new("Details"), 1);
+//  gtk_notebook_set_current_page (GTK_NOTEBOOK(options_box), 1);
+#if 0
+  GtkWidget*options_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
+  gtk_widget_show (options_box);
+  g_print("MYPAINTOPTIONSGUI::add PRIV_WIDGET=%lx\n", (gulong)(gpointer)priv_widget);
+  gtk_box_pack_start(GTK_BOX(options_box), priv_widget, TRUE, TRUE, 2);  
+  g_print("MYPAINTOPTIONSGUI::add EDITOR_WIDGET=%lx\n", (gulong)(gpointer)editor_widget);
+  gtk_box_pack_start(GTK_BOX(options_box), editor_widget, TRUE, TRUE, 2);  
+#endif
+  return options_box;
+}
+
+GtkWidget *
+gimp_mypaint_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  MypaintOptionsGUIPrivate* priv = new MypaintOptionsGUIPrivate(tool_options, true);
+  return priv->create();
+}
+
+}; // extern "C"
diff -Naur gimp-2.8.14/app/tools/gimpmypaintoptions-gui.h gimp-2.8.14-new/app/tools/gimpmypaintoptions-gui.h
--- gimp-2.8.14/app/tools/gimpmypaintoptions-gui.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypaintoptions-gui.h	2015-01-27 17:48:55.388751579 +0800
@@ -0,0 +1,27 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_OPTIONS_GUI_H__
+#define __GIMP_MYPAINT_OPTIONS_GUI_H__
+
+
+GtkWidget * gimp_mypaint_options_gui (GimpToolOptions *tool_options);
+GtkWidget * gimp_mypaint_options_gui_horizontal (GimpToolOptions *tool_options);
+GtkWidget * gimp_mypaint_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal);
+
+
+#endif /* __GIMP_MYPAINT_OPTIONS_GUI_H__ */
diff -Naur gimp-2.8.14/app/tools/gimpmypainttool.cpp gimp-2.8.14-new/app/tools/gimpmypainttool.cpp
--- gimp-2.8.14/app/tools/gimpmypainttool.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypainttool.cpp	2015-01-27 17:48:55.389751579 +0800
@@ -0,0 +1,827 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+extern "C" {
+#include "config.h"
+
+#include <gegl.h>
+#include <gtk/gtk.h>
+#include <sys/time.h> // gimp-painter-2.7: for gettimeofday
+
+#include "libgimpbase/gimpbase.h"
+#include "libgimpmath/gimpmath.h"
+
+#include "tools-types.h"
+
+#include "core/gimp.h"
+#include "core/gimp-utils.h"
+#include "core/gimpdrawable.h"
+#include "core/gimperror.h"
+#include "core/gimpimage.h"
+#include "core/gimpprojection.h"
+#include "core/gimptoolinfo.h"
+
+#include "paint/gimpmypaintcore.hpp"
+#include "paint/gimpmypaintoptions.h"
+
+#include "widgets/gimpdevices.h"
+#include "widgets/gimpwidgets-utils.h"
+
+#include "display/gimpdisplay.h"
+#include "display/gimpdisplayshell.h"
+#include "display/gimpdisplayshell-selection.h"
+
+#include "gimpcoloroptions.h"
+#include "gimpmypainttool.h"
+#include "gimptoolcontrol.h"
+
+#include "gimp-intl.h"
+#include "libgimpwidgets/gimpwidgets.h"
+#include "widgets/gimphelp-ids.h"
+#include "gimpmypaintoptions-gui.h"
+extern "C++" {
+#include "base/delegators.hpp"  // g_object_set_cxx_object
+};
+static void   gimp_mypaint_tool_constructed    (GObject               *object);
+static void   gimp_mypaint_tool_finalize       (GObject               *object);
+
+static void   gimp_mypaint_tool_control        (GimpTool              *tool,
+                                              GimpToolAction         action,
+                                              GimpDisplay           *display);
+static void   gimp_mypaint_tool_button_press   (GimpTool              *tool,
+                                              const GimpCoords      *coords,
+                                              guint32                time,
+                                              GdkModifierType        state,
+                                              GimpButtonPressType    press_type,
+                                              GimpDisplay           *display);
+static void   gimp_mypaint_tool_button_release (GimpTool              *tool,
+                                              const GimpCoords      *coords,
+                                              guint32                time,
+                                              GdkModifierType        state,
+                                              GimpButtonReleaseType  release_type,
+                                              GimpDisplay           *display);
+static void   gimp_mypaint_tool_motion         (GimpTool              *tool,
+                                              const GimpCoords      *coords,
+                                              guint32                time,
+                                              GdkModifierType        state,
+                                              GimpDisplay           *display);
+static void   gimp_mypaint_tool_motion_internal (GimpTool              *tool,
+                                              const GimpCoords      *coords,
+                                              guint32                time,
+                                              GdkModifierType        state,
+                                              GimpDisplay           *display,
+                                              gboolean               button_pressed);
+static void   gimp_mypaint_tool_modifier_key   (GimpTool              *tool,
+                                              GdkModifierType        key,
+                                              gboolean               press,
+                                              GdkModifierType        state,
+                                              GimpDisplay           *display);
+static void   gimp_mypaint_tool_cursor_update  (GimpTool              *tool,
+                                              const GimpCoords      *coords,
+                                              GdkModifierType        state,
+                                              GimpDisplay           *display);
+static void   gimp_mypaint_tool_oper_update    (GimpTool              *tool,
+                                              const GimpCoords      *coords,
+                                              GdkModifierType        state,
+                                              gboolean               proximity,
+                                              GimpDisplay           *display);
+
+static void   gimp_mypaint_tool_draw           (GimpDrawTool          *draw_tool);
+
+static void   gimp_mypaint_tool_hard_notify    (GimpMypaintOptions      *options,
+                                              const GParamSpec      *pspec,
+                                              GimpTool              *tool);
+
+
+G_DEFINE_TYPE (GimpMypaintTool, gimp_mypaint_tool, GIMP_TYPE_COLOR_TOOL)
+
+#define parent_class gimp_mypaint_tool_parent_class
+
+
+static void
+gimp_mypaint_tool_class_init (GimpMypaintToolClass *klass)
+{
+  GObjectClass      *object_class    = G_OBJECT_CLASS (klass);
+  GimpToolClass     *tool_class      = GIMP_TOOL_CLASS (klass);
+  GimpDrawToolClass *draw_tool_class = GIMP_DRAW_TOOL_CLASS (klass);
+
+  object_class->constructed  = gimp_mypaint_tool_constructed;
+  object_class->finalize     = gimp_mypaint_tool_finalize;
+
+  tool_class->control        = gimp_mypaint_tool_control;
+  tool_class->button_press   = gimp_mypaint_tool_button_press;
+  tool_class->button_release = gimp_mypaint_tool_button_release;
+  tool_class->motion         = gimp_mypaint_tool_motion;
+  tool_class->modifier_key   = gimp_mypaint_tool_modifier_key;
+  tool_class->cursor_update  = gimp_mypaint_tool_cursor_update;
+  tool_class->oper_update    = gimp_mypaint_tool_oper_update;
+
+  draw_tool_class->draw      = gimp_mypaint_tool_draw;
+}
+
+static void
+gimp_mypaint_tool_init (GimpMypaintTool *paint_tool)
+{
+  GimpTool *tool = GIMP_TOOL (paint_tool);
+
+  tool->want_full_motion_tracking = TRUE;
+  
+  gimp_tool_control_set_motion_mode    (tool->control, GIMP_MOTION_MODE_EXACT);
+  gimp_tool_control_set_scroll_lock    (tool->control, TRUE);
+  gimp_tool_control_set_action_value_1 (tool->control,
+                                        "context/context-opacity-set");
+
+  paint_tool->pick_colors = FALSE;
+  paint_tool->draw_line   = FALSE;
+
+  paint_tool->status      = _("Click to paint");
+  paint_tool->status_line = _("Click to draw the line");
+  paint_tool->status_ctrl = _("%s to pick a color");
+
+  paint_tool->core        = NULL;
+
+  //FIXME! pick_mode should be changed according to the attributes of the selected slash
+  GIMP_COLOR_TOOL (tool)->pick_mode = GIMP_COLOR_PICK_MODE_FOREGROUND;
+}
+
+static void
+gimp_mypaint_tool_constructed (GObject *object)
+{
+  GimpTool         *tool       = GIMP_TOOL (object);
+  GimpMypaintTool    *paint_tool = GIMP_MYPAINT_TOOL (object);
+  GimpMypaintOptions *options    = GIMP_MYPAINT_TOOL_GET_OPTIONS (tool);
+//  GimpMypaintInfo    *paint_info;
+  GimpMypaintCore    *core;
+
+  if (G_OBJECT_CLASS (parent_class)->constructed)
+    G_OBJECT_CLASS (parent_class)->constructed (object);
+
+  g_assert (GIMP_IS_TOOL_INFO (tool->tool_info));
+//  g_assert (GIMP_IS_MYPAINT_INFO (tool->tool_info->paint_info));
+
+//  paint_info = tool->tool_info->paint_info;
+
+//  g_assert (g_type_is_a (paint_info->mypaint_type, GIMP_TYPE_MYPAINT_CORE));
+
+  paint_tool->core = core = new GimpMypaintCore();
+  g_object_set_cxx_object(object, "paint-core", core);
+/*
+  g_signal_connect_object (options, "notify::hard",
+                           G_CALLBACK (gimp_mypaint_tool_hard_notify),
+                           tool, 0);
+  gimp_mypaint_tool_hard_notify (options, NULL, tool);
+*/
+}
+
+static void
+gimp_mypaint_tool_finalize (GObject *object)
+{
+  GimpMypaintTool *paint_tool = GIMP_MYPAINT_TOOL (object);
+/*
+  if (paint_tool->core) {
+    GimpMypaintCore* core = reinterpret_cast<GimpMypaintCore*>(paint_tool->core);
+    delete core;
+    paint_tool->core = NULL;
+  }
+*/
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+/**
+ * gimp_mypaint_tool_enable_color_picker:
+ * @tool: a #GimpMypaintTool
+ * @mode: the #GimpColorPickMode to set
+ *
+ * This is a convenience function used from the init method of paint
+ * tools that want the color picking functionality. The @mode that is
+ * set here is used to decide what cursor modifier to draw and if the
+ * picked color goes to the foreground or background color.
+ **/
+void
+gimp_mypaint_tool_enable_color_picker (GimpMypaintTool     *tool,
+                                     GimpColorPickMode  mode)
+{
+  g_return_if_fail (GIMP_IS_MYPAINT_TOOL (tool));
+
+  tool->pick_colors = TRUE;
+
+  GIMP_COLOR_TOOL (tool)->pick_mode = mode;
+}
+
+static void
+gimp_mypaint_tool_control (GimpTool       *tool,
+                         GimpToolAction  action,
+                         GimpDisplay    *display)
+{
+  GimpMypaintTool *paint_tool = GIMP_MYPAINT_TOOL (tool);
+  GimpMypaintCore* core = NULL;
+
+  switch (action) {
+    case GIMP_TOOL_ACTION_PAUSE:
+    case GIMP_TOOL_ACTION_RESUME:
+      break;
+
+    case GIMP_TOOL_ACTION_HALT:
+      core = reinterpret_cast<GimpMypaintCore*>(paint_tool->core);
+      core->cleanup();
+      break;
+  }
+
+  GIMP_TOOL_CLASS (parent_class)->control (tool, action, display);
+}
+
+static void
+gimp_mypaint_tool_button_press (GimpTool            *tool,
+                              const GimpCoords    *coords,
+                              guint32              time,
+                              GdkModifierType      state,
+                              GimpButtonPressType  press_type,
+                              GimpDisplay         *display)
+{
+  GimpDrawTool     *draw_tool     = GIMP_DRAW_TOOL (tool);
+  GimpDisplayShell *shell         = gimp_display_get_shell (display);
+  GimpImage        *image         = gimp_display_get_image (display);
+  GimpCoords        curr_coords;
+  gint              off_x, off_y;
+  GError           *error = NULL;
+
+  if (gimp_color_tool_is_enabled (GIMP_COLOR_TOOL (tool))) {
+    g_print("button_press where ColorTool.is_enabled == TRUE\n");
+    GIMP_TOOL_CLASS (parent_class)->button_press (tool, coords, time, state,
+                                                  press_type, display);
+    return;
+  }
+
+  if (gimp_draw_tool_is_active (draw_tool))
+    gimp_draw_tool_stop (draw_tool);
+
+  if (tool->display            &&
+      tool->display != display &&
+      gimp_display_get_image (tool->display) == image) {
+    /*  if this is a different display, but the same image, HACK around
+     *  in tool internals AFTER stopping the current draw_tool, so
+     *  straight line drawing works across different views of the
+     *  same image.
+     */
+
+    tool->display = display;
+  }
+/*
+  if (! gimp_mypaint_core_start (core, drawable, paint_options, &curr_coords,
+                               &error))
+    {
+      gimp_tool_message_literal (tool, display, error->message);
+      g_clear_error (&error);
+      return;
+    }
+*/
+
+  {
+      GimpImage *image = gimp_display_get_image (display);
+
+      tool->display  = display;
+      tool->drawable = gimp_image_get_active_drawable (image);
+
+      gimp_tool_control_activate (tool->control);
+    }
+
+  /*  pause the current selection  */
+  gimp_display_shell_selection_pause (shell);
+
+  /*  Let the specific painting function initialize itself  */
+  if (press_type == GIMP_BUTTON_PRESS_NORMAL) {  // ignore the extra double-click event
+    if (state & GDK_BUTTON1_MASK) { // mouse button pressed (while painting without pressure information)
+      // For the mouse we don't get a motion event for "pressure"
+      // changes, so we simulate it. (Note: we can't use the
+      // event's button state because it carries the old state.)
+      gimp_mypaint_tool_motion_internal (tool, coords, time, state, display, coords->pressure > 0.0 || (state & GDK_BUTTON1_MASK));
+    }
+  }
+
+  gimp_projection_flush_now (gimp_image_get_projection (image));
+  gimp_display_flush_now (display);
+  GIMP_MYPAINT_TOOL(tool)->last_flush_time = time;
+  gimp_draw_tool_start (draw_tool, display);
+}
+
+
+#if 0
+    def button_release_cb(self, win, event):
+        # (see comment above in button_press_cb)
+        if event.button == 1:
+            if not self.last_event_had_pressure_info:
+                self.motion_notify_cb(win, event, button1_pressed=False)
+            # Outsiders can access this via gui.document
+            for func in self._input_stroke_ended_observers:
+                func(event)
+#endif
+static void
+gimp_mypaint_tool_button_release (GimpTool              *tool,
+                                const GimpCoords      *coords,
+                                guint32                time,
+                                GdkModifierType        state,
+                                GimpButtonReleaseType  release_type,
+                                GimpDisplay           *display)
+{
+  GimpMypaintTool    *paint_tool    = GIMP_MYPAINT_TOOL (tool);
+  GimpDisplayShell *shell         = gimp_display_get_shell (display);
+  GimpImage        *image         = gimp_display_get_image (display);
+
+  if (gimp_color_tool_is_enabled (GIMP_COLOR_TOOL (tool)))
+    {
+      GIMP_TOOL_CLASS (parent_class)->button_release (tool, coords, time,
+                                                      state, release_type,
+                                                      display);
+      return;
+    }
+
+  gimp_draw_tool_pause (GIMP_DRAW_TOOL (tool));
+
+  /*  Let the specific painting function finish up  */
+  gimp_mypaint_tool_motion_internal (tool, coords, time, state, display, coords->pressure > 0.0 || (state & GDK_BUTTON1_MASK));
+
+  /*  resume the current selection  */
+  gimp_display_shell_selection_resume (shell);
+  gimp_image_flush (image);
+
+  gimp_draw_tool_resume (GIMP_DRAW_TOOL (tool));
+}
+
+static void
+gimp_mypaint_tool_motion (GimpTool         *tool,
+                        const GimpCoords *coords,
+                        guint32           time,
+                        GdkModifierType   state,
+                        GimpDisplay      *display)
+{
+  gimp_mypaint_tool_motion_internal (tool, coords, time, state, display, coords->pressure > 0.0 || (state & GDK_BUTTON1_MASK));
+}
+
+
+static void
+gimp_mypaint_tool_motion_internal (GimpTool         *tool,
+                                   const GimpCoords *coords,
+                                   guint32           time,
+                                   GdkModifierType   state,
+                                   GimpDisplay      *display,
+                                   gboolean          button1_pressed)
+{
+  GimpMypaintTool    *paint_tool    = GIMP_MYPAINT_TOOL (tool);
+  GimpMypaintOptions *paint_options = GIMP_MYPAINT_TOOL_GET_OPTIONS (tool);
+  GimpMypaintCore    *core = reinterpret_cast<GimpMypaintCore*>(paint_tool->core);
+  GimpImage        *image         = gimp_display_get_image (display);
+  GimpDrawable     *drawable      = gimp_image_get_active_drawable (image);
+  GimpCoords        curr_coords;
+  gint              off_x, off_y;
+  gdouble           dtime;
+
+  if (button1_pressed)
+    GIMP_TOOL_CLASS (parent_class)->motion (tool, coords, time, state, display);
+
+  if (gimp_color_tool_is_enabled (GIMP_COLOR_TOOL (tool)))
+    return;
+
+  curr_coords = *coords;
+
+  gimp_item_get_offset (GIMP_ITEM (drawable), &off_x, &off_y);
+
+  curr_coords.x -= off_x;
+  curr_coords.y -= off_y;
+
+
+  if (paint_tool->last_event_time > 0) {
+      dtime = (time - paint_tool->last_event_time) / 1000.0;
+  } else
+      dtime = 0;
+
+  paint_tool->last_event_x = curr_coords.x;
+  paint_tool->last_event_y = curr_coords.y;
+  paint_tool->last_event_time = time;
+  if (dtime == 0)
+      return;
+
+  // Refuse drawing if the layer is locked or hidden
+  if (gimp_viewable_get_children (GIMP_VIEWABLE (drawable))) {
+      gimp_tool_message_literal (tool, display,
+                                 _("Cannot paint on layer groups."));
+      return;
+  }
+
+  if (gimp_item_is_content_locked (GIMP_ITEM (drawable))) {
+      gimp_tool_message_literal (tool, display,
+                                 _("The active layer's pixels are locked."));
+      return;
+  }
+
+  // NOTICE: coordinates is already transformed at 
+  //         gimp_display_shell_canvas_tool_events @ gimpdisplayshell-tool-events.c
+  /*
+        cr = self.get_model_coordinates_cairo_context()
+        x, y = cr.device_to_user(event.x, event.y)
+  pressure = event.get_axis(gdk.AXIS_PRESSURE)
+  */
+
+  // FIXME: Gimp sets default pressure to 1.0 at gimpdeviceinfo-coords.c while MyPaint sets 0.5 or 0
+  //         according to its button state.
+
+  if (curr_coords.pressure > 0.0) {
+    paint_tool->last_painting_x = curr_coords.x;
+    paint_tool->last_painting_y = curr_coords.y;
+  }
+
+  // If the device has changed and the last pressure value from the previous device
+  // is not equal to 0.0, this can leave a visible stroke on the layer even if the 'new'
+  // device is not pressed on the tablet and has a pressure axis == 0.0.
+  // Reseting the brush when the device changes fixes this issue, but there may be a
+  // much more elegant solution that only resets the brush on this edge-case.
+  // FIXME: Can't get device information here!
+//  if (!same_device)
+//    core->reset_brush();
+
+  //# On Windows, GTK timestamps have a resolution around
+  //# 15ms, but tablet events arrive every 8ms.
+  //# https://gna.org/bugs/index.php?16569
+  //# TODO: proper fix in the brush engine, using only smooth,
+  //#       filtered speed inputs, will make this unneccessary
+  /*
+  if dtime < 0.0:
+      print 'Time is running backwards, dtime=%f' % dtime
+      dtime = 0.0
+  data = (x, y, pressure, xtilt, ytilt)
+  if dtime == 0.0:
+      self.motions.append(data)
+  elif dtime > 0.0:
+      if self.motions:
+          # replay previous events that had identical timestamp
+          if dtime > 0.1:
+              # really old events, don't associate them with the new one
+              step = 0.1
+          else:
+              step = dtime
+          step /= len(self.motions)+1
+          for data_old in self.motions:
+              self.doc.stroke_to(step, *data_old)
+              dtime -= step
+          self.motions = []
+      self.doc.stroke_to(dtime, *data)
+  */
+  if (!button1_pressed)
+    curr_coords.pressure = 0.0;
+
+  gimp_draw_tool_pause (GIMP_DRAW_TOOL (tool));
+
+  core->stroke_to(drawable, dtime, &curr_coords, paint_options);
+
+  if (time - paint_tool->last_flush_time > 100) {
+    gimp_projection_finish_draw (gimp_image_get_projection (image)); 
+    gimp_display_flush_now (display);
+    paint_tool->last_flush_time = time;
+  } else {
+    gimp_projection_flush (gimp_image_get_projection (image));
+    gimp_display_flush (display);
+  }
+
+  gimp_draw_tool_resume (GIMP_DRAW_TOOL (tool));
+}
+
+static void
+gimp_mypaint_tool_modifier_key (GimpTool        *tool,
+                              GdkModifierType  key,
+                              gboolean         press,
+                              GdkModifierType  state,
+                              GimpDisplay     *display)
+{
+  GimpMypaintTool *paint_tool = GIMP_MYPAINT_TOOL (tool);
+  GimpDrawTool  *draw_tool  = GIMP_DRAW_TOOL (tool);
+
+  if (key != gimp_get_constrain_behavior_mask ())
+    return;
+
+  if (press) {
+    GimpToolInfo *info = gimp_get_tool_info (display->gimp,
+                                             "gimp-color-picker-tool");
+
+    if (GIMP_IS_TOOL_INFO (info)) {
+        if (gimp_draw_tool_is_active (draw_tool))
+          gimp_draw_tool_stop (draw_tool);
+
+        gimp_color_tool_enable (GIMP_COLOR_TOOL (tool),
+                                GIMP_COLOR_OPTIONS (info->tool_options));
+
+        switch (GIMP_COLOR_TOOL (tool)->pick_mode) {
+          case GIMP_COLOR_PICK_MODE_FOREGROUND:
+            gimp_tool_push_status (tool, display,
+                                   _("Click in any image to pick the "
+                                     "foreground color"));
+            break;
+
+          case GIMP_COLOR_PICK_MODE_BACKGROUND:
+            gimp_tool_push_status (tool, display,
+                                   _("Click in any image to pick the "
+                                     "background color"));
+            break;
+
+          default:
+            break;
+        }
+    }
+  } else if (gimp_color_tool_is_enabled (GIMP_COLOR_TOOL (tool))) {
+    gimp_tool_pop_status (tool, display);
+    gimp_color_tool_disable (GIMP_COLOR_TOOL (tool));
+  }
+}
+
+static void
+gimp_mypaint_tool_cursor_update (GimpTool         *tool,
+                               const GimpCoords *coords,
+                               GdkModifierType   state,
+                               GimpDisplay      *display)
+{
+  GimpCursorModifier  modifier;
+  GimpCursorModifier  toggle_modifier;
+  GimpCursorModifier  old_modifier;
+  GimpCursorModifier  old_toggle_modifier;
+
+  modifier        = tool->control->cursor_modifier;
+  toggle_modifier = tool->control->toggle_cursor_modifier;
+
+  old_modifier        = modifier;
+  old_toggle_modifier = toggle_modifier;
+
+  if (! gimp_color_tool_is_enabled (GIMP_COLOR_TOOL (tool))) {
+    GimpImage    *image    = gimp_display_get_image (display);
+    GimpDrawable *drawable = gimp_image_get_active_drawable (image);
+
+    if (gimp_viewable_get_children (GIMP_VIEWABLE (drawable)) ||
+      gimp_item_is_content_locked (GIMP_ITEM (drawable))) {
+      modifier        = GIMP_CURSOR_MODIFIER_BAD;
+      toggle_modifier = GIMP_CURSOR_MODIFIER_BAD;
+    }
+
+    gimp_tool_control_set_cursor_modifier        (tool->control,
+                                                  modifier);
+    gimp_tool_control_set_toggle_cursor_modifier (tool->control,
+                                                  toggle_modifier);
+  }
+
+  GIMP_TOOL_CLASS (parent_class)->cursor_update (tool, coords, state,
+                                                 display);
+
+  /*  reset old stuff here so we are not interferring with the modifiers
+   *  set by our subclasses
+   */
+  gimp_tool_control_set_cursor_modifier        (tool->control,
+                                                old_modifier);
+  gimp_tool_control_set_toggle_cursor_modifier (tool->control,
+                                                old_toggle_modifier);
+}
+
+static void
+gimp_mypaint_tool_oper_update (GimpTool         *tool,
+                             const GimpCoords *coords,
+                             GdkModifierType   state,
+                             gboolean          proximity,
+                             GimpDisplay      *display)
+{
+  GimpMypaintTool    *paint_tool    = GIMP_MYPAINT_TOOL (tool);
+  GimpDrawTool     *draw_tool     = GIMP_DRAW_TOOL (tool);
+  GimpMypaintOptions *paint_options = GIMP_MYPAINT_TOOL_GET_OPTIONS (tool);
+  GimpMypaintCore    *core          = reinterpret_cast<GimpMypaintCore*>(paint_tool->core);
+  GimpDisplayShell *shell         = gimp_display_get_shell (display);
+  GimpImage        *image         = gimp_display_get_image (display);
+  GimpDrawable     *drawable      = gimp_image_get_active_drawable (image);
+
+  if (gimp_color_tool_is_enabled (GIMP_COLOR_TOOL (tool)))
+    {
+      GIMP_TOOL_CLASS (parent_class)->oper_update (tool, coords, state,
+                                                   proximity, display);
+      return;
+    }
+#if 0
+  gimp_draw_tool_pause (draw_tool);
+
+  timeval tv;
+  gettimeofday(&tv, NULL);
+  guint32 time = (guint32)((tv.tv_sec) * 1000.0 + (tv.tv_usec / 1000.0));
+  g_print("time=%d\n", time);
+  gimp_mypaint_tool_motion_internal (tool, coords, time, state, display, FALSE);
+#endif
+#if 0
+  if (gimp_draw_tool_is_active (draw_tool) &&
+      draw_tool->display != display)
+    gimp_draw_tool_stop (draw_tool);
+
+  gimp_tool_pop_status (tool, display);
+
+  if (tool->display            &&
+      tool->display != display &&
+      gimp_display_get_image (tool->display) == image)
+    {
+      /*  if this is a different display, but the same image, HACK around
+       *  in tool internals AFTER stopping the current draw_tool, so
+       *  straight line drawing works across different views of the
+       *  same image.
+       */
+
+      tool->display = display;
+    }
+
+  if (drawable && proximity)
+    {
+      gboolean constrain_mask = gimp_get_constrain_behavior_mask ();
+
+      if (display == tool->display && (state & GDK_SHIFT_MASK))
+        {
+          /*  If shift is down and this is not the first paint stroke,
+           *  draw a line.
+           */
+
+          gchar   *status_help;
+          gdouble  dx, dy, dist;
+          gint     off_x, off_y;
+
+          paint_tool->curr_coords = *coords;
+
+          gimp_item_get_offset (GIMP_ITEM (drawable), &off_x, &off_y);
+
+          paint_tool->curr_coords.x -= off_x;
+          paint_tool->curr_coords.y -= off_y;
+
+//          gimp_mypaint_core_round_line (core, paint_options,
+//                                      (state & constrain_mask) != 0);
+
+          dx = paint_tool->curr_coords.x - paint_tool->last_event_x;
+          dy = paint_tool->curr_coords.y - paint_tool->last_event_y;
+
+          status_help = gimp_suggest_modifiers (paint_tool->status_line,
+                                                GdkModifierType(constrain_mask & ~state),
+                                                NULL,
+                                                _("%s for constrained angles"),
+                                                NULL);
+
+          /*  show distance in statusbar  */
+          if (shell->unit == GIMP_UNIT_PIXEL)
+            {
+              dist = sqrt (SQR (dx) + SQR (dy));
+
+              gimp_tool_push_status (tool, display, "%.1f %s.  %s",
+                                     dist, _("pixels"), status_help);
+            }
+          else
+            {
+              gdouble xres;
+              gdouble yres;
+              gchar   format_str[64];
+
+              gimp_image_get_resolution (image, &xres, &yres);
+
+              g_snprintf (format_str, sizeof (format_str), "%%.%df %s.  %%s",
+                          gimp_unit_get_digits (shell->unit),
+                          gimp_unit_get_symbol (shell->unit));
+
+              dist = (gimp_unit_get_factor (shell->unit) *
+                      sqrt (SQR (dx / xres) +
+                            SQR (dy / yres)));
+
+              gimp_tool_push_status (tool, display, format_str,
+                                     dist, status_help);
+            }
+
+          g_free (status_help);
+
+          paint_tool->draw_line = TRUE;
+        }
+      else
+        {
+          gchar           *status;
+          GdkModifierType  modifiers = GdkModifierType(0);
+
+          /* HACK: A paint tool may set status_ctrl to NULL to indicate that
+           * it ignores the Ctrl modifier (temporarily or permanently), so
+           * it should not be suggested.  This is different from how
+           * gimp_suggest_modifiers() would interpret this parameter.
+           */
+          if (paint_tool->status_ctrl != NULL)
+            modifiers = GdkModifierType(modifiers|constrain_mask);
+
+          /* suggest drawing lines only after the first point is set
+           */
+          if (display == tool->display)
+            modifiers = GdkModifierType(modifiers|GDK_SHIFT_MASK);
+
+          status = gimp_suggest_modifiers (paint_tool->status,
+                                           GdkModifierType(modifiers & ~state),
+                                           _("%s for a straight line"),
+                                           paint_tool->status_ctrl,
+                                           NULL);
+          gimp_tool_push_status (tool, display, "%s", status);
+          g_free (status);
+
+          paint_tool->draw_line = FALSE;
+        }
+
+      if (! gimp_draw_tool_is_active (draw_tool))
+        gimp_draw_tool_start (draw_tool, display);
+    }
+  else if (gimp_draw_tool_is_active (draw_tool))
+    {
+      gimp_draw_tool_stop (draw_tool);
+    }
+#endif
+  GIMP_TOOL_CLASS (parent_class)->oper_update (tool, coords, state, proximity,
+                                               display);
+#if 0
+  gimp_draw_tool_resume (draw_tool);
+#endif
+}
+
+static void
+gimp_mypaint_tool_draw (GimpDrawTool *draw_tool)
+{
+  if (! gimp_color_tool_is_enabled (GIMP_COLOR_TOOL (draw_tool)))
+    {
+      GimpMypaintTool *paint_tool = GIMP_MYPAINT_TOOL (draw_tool);
+
+      if (paint_tool->draw_line &&
+          ! gimp_tool_control_is_active (GIMP_TOOL (draw_tool)->control))
+        {
+          GimpMypaintCore *core     = reinterpret_cast<GimpMypaintCore*>(paint_tool->core);
+          GimpImage     *image      = gimp_display_get_image (draw_tool->display);
+          GimpDrawable  *drawable   = gimp_image_get_active_drawable (image);
+          gint           off_x, off_y;
+
+          gimp_item_get_offset (GIMP_ITEM (drawable), &off_x, &off_y);
+
+          /*  Draw the line between the start and end coords  */
+          gimp_draw_tool_add_line (draw_tool,
+                                   paint_tool->last_event_x + off_x,
+                                   paint_tool->last_event_y + off_y,
+                                   paint_tool->curr_coords.x + off_x,
+                                   paint_tool->curr_coords.y + off_y);
+
+          /*  Draw start target  */
+          gimp_draw_tool_add_handle (draw_tool,
+                                     GIMP_HANDLE_CROSS,
+                                     paint_tool->last_event_x + off_x,
+                                     paint_tool->last_event_y + off_y,
+                                     GIMP_TOOL_HANDLE_SIZE_CROSS,
+                                     GIMP_TOOL_HANDLE_SIZE_CROSS,
+                                     GIMP_HANDLE_ANCHOR_CENTER);
+
+          /*  Draw end target  */
+          gimp_draw_tool_add_handle (draw_tool,
+                                     GIMP_HANDLE_CROSS,
+                                     paint_tool->curr_coords.x + off_x,
+                                     paint_tool->curr_coords.y + off_y,
+                                     GIMP_TOOL_HANDLE_SIZE_CROSS,
+                                     GIMP_TOOL_HANDLE_SIZE_CROSS,
+                                     GIMP_HANDLE_ANCHOR_CENTER);
+        }
+    }
+
+  GIMP_DRAW_TOOL_CLASS (parent_class)->draw (draw_tool);
+}
+
+static void
+gimp_mypaint_tool_hard_notify (GimpMypaintOptions *options,
+                             const GParamSpec *pspec,
+                             GimpTool         *tool)
+{
+  gimp_tool_control_set_precision (tool->control,
+                                   GIMP_CURSOR_PRECISION_SUBPIXEL);
+}
+
+
+void
+gimp_mypaint_tool_register (GimpToolRegisterCallback  callback,
+                            gpointer                  data)
+{
+  (* callback) (GIMP_TYPE_MYPAINT_TOOL,
+                GIMP_TYPE_MYPAINT_OPTIONS,
+                gimp_mypaint_options_gui,
+                gimp_mypaint_options_gui_horizontal,
+                GimpContextPropMask(GIMP_MYPAINT_OPTIONS_CONTEXT_MASK),
+                "gimp-mypaint-tool",
+                _("Mypaint Brush"),
+                _("Mypaint Brush Tool: Paint using a mypaint brush"),
+                N_("_Mypaintbrush"), "P",
+                NULL, GIMP_HELP_TOOL_MYPAINT,
+                GIMP_STOCK_TOOL_MYPAINT,
+                data);
+}
+
+
+}
diff -Naur gimp-2.8.14/app/tools/gimpmypainttool.h gimp-2.8.14-new/app/tools/gimpmypainttool.h
--- gimp-2.8.14/app/tools/gimpmypainttool.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimpmypainttool.h	2015-01-27 17:48:55.389751579 +0800
@@ -0,0 +1,76 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_TOOL_H__
+#define __GIMP_MYPAINT_TOOL_H__
+
+
+#include "gimpcolortool.h"
+#include "tools-types.h"
+
+
+#define GIMP_TYPE_MYPAINT_TOOL            (gimp_mypaint_tool_get_type ())
+#define GIMP_MYPAINT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MYPAINT_TOOL, GimpMypaintTool))
+#define GIMP_MYPAINT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MYPAINT_TOOL, GimpMypaintToolClass))
+#define GIMP_IS_MYPAINT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MYPAINT_TOOL))
+#define GIMP_IS_MYPAINT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MYPAINT_TOOL))
+#define GIMP_MYPAINT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MYPAINT_TOOL, GimpMypaintToolClass))
+
+#define GIMP_MYPAINT_TOOL_GET_OPTIONS(t)  (GIMP_MYPAINT_OPTIONS (gimp_tool_get_options (GIMP_TOOL (t))))
+
+
+typedef struct _GimpMypaintToolClass GimpMypaintToolClass;
+
+struct _GimpMypaintTool
+{
+  GimpColorTool  parent_instance;
+
+  gboolean       pick_colors;  /*  pick color if ctrl is pressed   */
+  gboolean       draw_line;
+
+  const gchar   *status;       /* status message */
+  const gchar   *status_line;  /* status message when drawing a line */
+  const gchar   *status_ctrl;  /* additional message for the ctrl modifier */
+  
+  GimpCoords curr_coords;
+  guint32 last_event_time;
+  gdouble last_event_x;
+  gdouble last_event_y;
+  gdouble last_painting_x;
+  gdouble last_painting_y;
+  
+  guint32 last_flush_time;
+
+  gpointer core;
+};
+
+struct _GimpMypaintToolClass
+{
+  GimpColorToolClass  parent_class;
+};
+
+
+GType   gimp_mypaint_tool_get_type            (void) G_GNUC_CONST;
+
+void    gimp_mypaint_tool_enable_color_picker (GimpMypaintTool     *tool,
+                                             GimpColorPickMode  mode);
+
+void    gimp_mypaint_tool_register (GimpToolRegisterCallback  callback,
+                                     gpointer                  data);
+
+
+#endif  /*  __GIMP_MYPAINT_TOOL_H__  */
diff -Naur gimp-2.8.14/app/tools/gimppaintbrushtool.c gimp-2.8.14-new/app/tools/gimppaintbrushtool.c
--- gimp-2.8.14/app/tools/gimppaintbrushtool.c	2015-01-27 17:28:36.896833809 +0800
+++ gimp-2.8.14-new/app/tools/gimppaintbrushtool.c	2015-01-27 17:48:55.389751579 +0800
@@ -44,6 +44,7 @@
   (* callback) (GIMP_TYPE_PAINTBRUSH_TOOL,
                 GIMP_TYPE_PAINT_OPTIONS,
                 gimp_paint_options_gui,
+                gimp_paint_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK |
                 GIMP_CONTEXT_GRADIENT_MASK,
                 "gimp-paintbrush-tool",
diff -Naur gimp-2.8.14/app/tools/gimppaintoptions-gui.c gimp-2.8.14-new/app/tools/gimppaintoptions-gui.c
--- gimp-2.8.14/app/tools/gimppaintoptions-gui.c	2015-01-27 17:28:36.889833809 +0800
+++ gimp-2.8.14-new/app/tools/gimppaintoptions-gui.c	2015-01-27 17:48:55.390751578 +0800
@@ -22,8 +22,12 @@
 #include "libgimpwidgets/gimpwidgets.h"
 
 #include "tools-types.h"
+#include "base/base-types.h"
+
+#include "base/temp-buf.h"
 
 #include "core/gimptoolinfo.h"
+#include "core/gimpbrush.h"
 
 #include "paint/gimppaintoptions.h"
 
@@ -31,6 +35,8 @@
 #include "widgets/gimpspinscale.h"
 #include "widgets/gimpviewablebox.h"
 #include "widgets/gimpwidgets-constructors.h"
+#include "widgets/gimppopupbutton.h"
+
 #include "widgets/gimpwidgets-utils.h"
 
 #include "gimpairbrushtool.h"
@@ -45,9 +51,25 @@
 #include "gimpperspectiveclonetool.h"
 #include "gimpsmudgetool.h"
 #include "gimptooloptions-gui.h"
+#include "gimpbrushoptions-gui.h"
+#include "gimpdynamicsoptions-gui.h"
 
 #include "gimp-intl.h"
 
+typedef void (*GimpContextNotifyCallback)   (GObject *config, GParamSpec *param_spec, GtkWidget *label);
+
+static GtkWidget * jitter_options_gui    (GimpPaintOptions *paint_options,
+                                          GType             tool_type,
+                                          gboolean          horizontal);
+static GtkWidget * smoothing_options_gui (GimpPaintOptions *paint_options,
+                                          GType             tool_type,
+                                          gboolean          horizontal);
+static GtkWidget * texture_options_gui   (GimpPaintOptions *paint_options,
+                                          GType             tool_type,
+                                          gboolean          horizontal);
+static GtkWidget * dynamics_options_gui       (GimpPaintOptions *paint_options,
+                                               GType             tool_type,
+                                               gboolean          horizontal);
 
 static void gimp_paint_options_gui_reset_size  (GtkWidget        *button,
                                                 GimpPaintOptions *paint_options);
@@ -57,30 +79,76 @@
 static void gimp_paint_options_gui_reset_angle (GtkWidget        *button,
                                                 GimpPaintOptions *paint_options);
 
+static void       dynamics_options_create_view  (GtkWidget *button,
+                                                  GtkWidget **result, GObject *config);
+static void       jitter_options_create_view    (GtkWidget *button,
+                                                  GtkWidget **result, GObject *config);
+static void       smoothing_options_create_view (GtkWidget *button,
+                                                  GtkWidget **result, GObject *config);
+static void       texture_options_create_view   (GtkWidget *button,
+                                                  GtkWidget **result, GObject *config);
+#if 0
 static GtkWidget * dynamics_options_gui        (GimpPaintOptions *paint_options,
                                                 GType             tool_type);
 static GtkWidget * jitter_options_gui          (GimpPaintOptions *paint_options,
                                                 GType             tool_type);
 static GtkWidget * smoothing_options_gui       (GimpPaintOptions *paint_options,
                                                 GType             tool_type);
-
+#endif
 
 /*  public functions  */
 
 GtkWidget *
 gimp_paint_options_gui (GimpToolOptions *tool_options)
 {
+  return gimp_paint_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_paint_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_paint_options_gui_full (tool_options, TRUE);
+}
+
+GtkWidget *
+gimp_paint_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
+{
   GObject          *config  = G_OBJECT (tool_options);
   GimpPaintOptions *options = GIMP_PAINT_OPTIONS (tool_options);
+
+  GtkWidget        *vbox    = gimp_tool_options_gui_full (tool_options, horizontal);
+  GtkWidget        *hbox;
+  GtkWidget        *frame;
+  GtkWidget        *table;
+#if 0
   GtkWidget        *vbox    = gimp_tool_options_gui (tool_options);
   GtkWidget        *hbox;
+#endif
   GtkWidget        *menu;
   GtkWidget        *label;
   GtkWidget        *scale;
   GType             tool_type;
+  GList            *children;
+  GimpToolOptionsTableIncrement inc = gimp_tool_options_table_increment (horizontal);
 
   tool_type = tool_options->tool_info->tool_type;
 
+#if 1
+  /*  the main table  */
+  table = gimp_tool_options_table (3, horizontal);
+  gtk_table_set_col_spacings (GTK_TABLE (table), 2);
+  gtk_box_pack_start (GTK_BOX (vbox), table, FALSE, FALSE, 0);
+  gtk_widget_show (table);
+
+  /*  the paint mode menu  */
+  menu  = gimp_prop_paint_mode_menu_new (config, "paint-mode", TRUE, FALSE);
+  label = gimp_table_attach_aligned (GTK_TABLE (table),
+                                     gimp_tool_options_table_increment_get_col (&inc),
+                                     gimp_tool_options_table_increment_get_row (&inc),
+                                     _("Mode:"), 0.0, 0.5,
+                                     menu, 2, FALSE);
+  gimp_tool_options_table_increment_next (&inc);
+#else
   /*  the paint mode menu  */
   hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
   gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
@@ -93,6 +161,7 @@
   menu = gimp_prop_paint_mode_menu_new (config, "paint-mode", TRUE, FALSE);
   gtk_box_pack_start (GTK_BOX (hbox), menu, TRUE, TRUE, 0);
   gtk_widget_show (menu);
+#endif
 
   if (tool_type == GIMP_TYPE_ERASER_TOOL     ||
       tool_type == GIMP_TYPE_CONVOLVE_TOOL   ||
@@ -114,19 +183,44 @@
   if (g_type_is_a (tool_type, GIMP_TYPE_BRUSH_TOOL))
     {
       GtkWidget *button;
+#if 0
       GtkWidget *hbox;
       GtkWidget *frame;
+#endif
 
-      button = gimp_prop_brush_box_new (NULL, GIMP_CONTEXT (tool_options),
-                                        _("Brush"), 2,
-                                        "brush-view-type", "brush-view-size",
-                                        "gimp-brush-editor");
+      if (horizontal)
+        button = gimp_brush_button_with_popup (config);
+      else
+        {
+#if 0
+      {
+        button = gimp_prop_brush_box_new (NULL, GIMP_CONTEXT (tool_options), _("Brush:"), 2,
+                                          "brush-view-type", "brush-view-size");
+      gimp_table_attach_aligned (GTK_TABLE (table),
+                                 gimp_tool_options_table_increment_get_col (&inc),
+                                 gimp_tool_options_table_increment_get_row (&inc),
+                                 _("Brush:"), 0.0, 0.5,
+                                 button, 2, FALSE);
+      gimp_tool_options_table_increment_next (&inc);
+      }
+#endif
+          button = gimp_prop_brush_box_new (NULL, GIMP_CONTEXT (tool_options),
+                                            _("Brush"), 2,
+                                            "brush-view-type", "brush-view-size",
+                                            "gimp-brush-editor");
+        }
       gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
       gtk_widget_show (button);
 
-      hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
-      gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
-      gtk_widget_show (hbox);
+      /* brush size */
+      if (horizontal)
+        hbox = vbox;
+      else
+        {
+          hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
+          gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
+          gtk_widget_show (hbox);
+        }
 
       scale = gimp_prop_spin_scale_new (config, "brush-size",
                                         _("Size"),
@@ -149,6 +243,8 @@
       gimp_help_set_help_data (button,
                                _("Reset size to brush's native size"), NULL);
 
+      if (!horizontal)
+        {
       hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
       gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
       gtk_widget_show (hbox);
@@ -194,22 +290,51 @@
                         G_CALLBACK (gimp_paint_options_gui_reset_angle),
                         options);
 
-      gimp_help_set_help_data (button,
-                               _("Reset angle to zero"), NULL);
+          gimp_help_set_help_data (button,
+                                   _("Reset angle to zero"), NULL);
 
-      button = gimp_prop_dynamics_box_new (NULL, GIMP_CONTEXT (tool_options),
-                                           _("Dynamics"), 2,
-                                           "dynamics-view-type",
-                                           "dynamics-view-size",
-                                           "gimp-dynamics-editor");
-      gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
-      gtk_widget_show (button);
+          button = gimp_prop_dynamics_box_new (NULL, GIMP_CONTEXT (tool_options),
+                                               _("Dynamics"), 2,
+                                               "dynamics-view-type",
+                                               "dynamics-view-size",
+                                               "gimp-dynamics-editor");
+          gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
+          gtk_widget_show (button);
+        }
+      else
+        {
+          button = gimp_dynamics_button_with_popup (config);
+          gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
+          gtk_widget_show (button);
+        }
+      frame = dynamics_options_gui (options, tool_type, horizontal);
+      gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
+      gtk_widget_show (frame);
 
-      frame = dynamics_options_gui (options, tool_type);
+      frame = jitter_options_gui (options, tool_type, horizontal);
       gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
       gtk_widget_show (frame);
+    }
+
+#if 0
+  /* the "smoothing" toggle */
+  if (g_type_is_a (tool_type, GIMP_TYPE_BRUSH_TOOL) ||
+      tool_type == GIMP_TYPE_INK_TOOL ||
+      tool_type == GIMP_TYPE_SMUDGE_TOOL ||
+      tool_type == GIMP_TYPE_DODGE_BURN_TOOL)
+    {
+      frame = smoothing_options_gui (options, tool_type, horizontal);
+      gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
+      gtk_widget_show (frame);
+    }
+#endif
 
-      frame = jitter_options_gui (options, tool_type);
+  /* gimp-painter-2.7: the "texture" toggle */
+  if (g_type_is_a (tool_type, GIMP_TYPE_BRUSH_TOOL) ||
+      tool_type == GIMP_TYPE_SMUDGE_TOOL ||
+      tool_type == GIMP_TYPE_DODGE_BURN_TOOL)
+    {
+      frame = texture_options_gui (options, tool_type, horizontal);
       gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
       gtk_widget_show (frame);
     }
@@ -217,9 +342,12 @@
   /*  the "smooth stroke" options  */
   if (g_type_is_a (tool_type, GIMP_TYPE_PAINT_TOOL))
     {
+      frame = smoothing_options_gui (options, tool_type, horizontal);
+#if 0
       GtkWidget *frame;
 
       frame = smoothing_options_gui (options, tool_type);
+#endif
       gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
       gtk_widget_show (frame);
     }
@@ -256,18 +384,38 @@
       gtk_widget_show (button);
     }
 
+  if (tool_type == GIMP_TYPE_SMUDGE_TOOL)
+    {
+      GtkWidget* button;
+      button = gimp_prop_check_button_new (config, "use-color-blending", _("Color Blending"));
+      gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
+      gtk_widget_show (button);
+    }
+
+  if (horizontal)
+    {
+      children = gtk_container_get_children (GTK_CONTAINER (vbox));
+      gimp_tool_options_setup_popup_layout (children, FALSE);
+    }
+
   return vbox;
 }
 
 
 /*  private functions  */
-
 static GtkWidget *
 dynamics_options_gui (GimpPaintOptions *paint_options,
-                      GType             tool_type)
+                      GType             tool_type,
+                      gboolean          horizontal)
+{
+  return gimp_tool_options_expander_gui_with_popup (G_OBJECT (paint_options), tool_type,
+                                             "dynamics-expanded", _("Dynamics"), _("Dynamics Options"),
+                                             horizontal, dynamics_options_create_view);
+}
+
+static void
+dynamics_options_create_view (GtkWidget *button, GtkWidget **result, GObject *config)
 {
-  GObject   *config = G_OBJECT (paint_options);
-  GtkWidget *frame;
   GtkWidget *inner_frame;
   GtkWidget *label;
   GtkWidget *scale;
@@ -279,11 +427,14 @@
   GtkWidget *hbox;
   GtkWidget *box;
 
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
+#if 0
   frame = gimp_prop_expander_new (config, "dynamics-expanded",
                                   _("Dynamics Options"));
 
   vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
   gtk_container_add (GTK_CONTAINER (frame), vbox);
+#endif
   gtk_widget_show (vbox);
 
   inner_frame = gimp_frame_new (_("Fade Options"));
@@ -309,12 +460,6 @@
   gtk_box_pack_start (GTK_BOX (hbox), menu, FALSE, FALSE, 0);
   gtk_widget_show (menu);
 
-#if 0
-  /* FIXME pixel digits */
-  g_object_set_data (G_OBJECT (menu), "set_digits", spinbutton);
-  gimp_unit_menu_set_pixel_digits (GIMP_UNIT_MENU (menu), 0);
-#endif
-
   /*  the repeat type  */
   hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
   gtk_box_pack_start (GTK_BOX (inner_vbox), hbox, FALSE, FALSE, 0);
@@ -334,7 +479,7 @@
   gtk_widget_show (checkbox);
 
   /* Color UI */
-  if (g_type_is_a (tool_type, GIMP_TYPE_PAINTBRUSH_TOOL))
+//  if (g_type_is_a (tool_type, GIMP_TYPE_PAINTBRUSH_TOOL))
     {
       inner_frame = gimp_frame_new (_("Color Options"));
       gtk_box_pack_start (GTK_BOX (vbox), inner_frame, FALSE, FALSE, 0);
@@ -350,66 +495,134 @@
       gtk_widget_show (box);
     }
 
-  return frame;
+//  if (horizontal)
+    {
+      GList *children;
+      children = gtk_container_get_children (GTK_CONTAINER (hbox));
+      gimp_tool_options_setup_popup_layout (children, FALSE);
+    }
+
+  *result = vbox;
 }
 
 static GtkWidget *
-jitter_options_gui (GimpPaintOptions *paint_options,
-                    GType             tool_type)
+jitter_options_gui (GimpPaintOptions           *paint_options,
+                    GType                       tool_type,
+                    gboolean                    horizontal)
 {
-  GObject   *config = G_OBJECT (paint_options);
-  GtkWidget *frame;
+  return gimp_tool_options_toggle_gui_with_popup (G_OBJECT (paint_options), tool_type,
+                             "use-jitter", _("Jitter"), _("Apply Jitter"),
+                             horizontal, jitter_options_create_view);
+}
+
+static void
+jitter_options_create_view (GtkWidget *button, GtkWidget **result, GObject *config)
+{
+  GtkWidget *vbox;
   GtkWidget *scale;
+  GList     *children;
 
+  vbox = gtk_vbox_new (FALSE, 2);
   scale = gimp_prop_spin_scale_new (config, "jitter-amount",
                                     _("Amount"),
                                     0.01, 1.0, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), scale, TRUE, TRUE, 0);
+  gtk_widget_show (scale);
+
+  children = gtk_container_get_children (GTK_CONTAINER (vbox));
+  gimp_tool_options_setup_popup_layout (children, FALSE);
 
-  frame = gimp_prop_expanding_frame_new (config, "use-jitter",
-                                         _("Apply Jitter"),
-                                         scale, NULL);
+  *result = vbox;
+}
+
+static void
+gimp_paint_options_gui_reset_size (GtkWidget        *button,
+                                   GimpPaintOptions *paint_options)
+{
+ GimpBrush *brush = gimp_context_get_brush (GIMP_CONTEXT (paint_options));
 
-  return frame;
+ if (brush)
+   {
+     g_object_set (paint_options,
+                   "brush-size", (gdouble) MAX ((brush->mask->width),
+                                                (brush->mask->height)),
+                   NULL);
+   }
 }
 
 static GtkWidget *
-smoothing_options_gui (GimpPaintOptions *paint_options,
-                       GType             tool_type)
+smoothing_options_gui (GimpPaintOptions         *paint_options,
+                    GType                       tool_type,
+                    gboolean                    horizontal)
+{
+  return gimp_tool_options_toggle_gui_with_popup (G_OBJECT (paint_options), tool_type,
+                             "use-smoothing", _("Smooth"), _("Smooth stroke"),
+                             horizontal, smoothing_options_create_view);
+}
+
+static void
+smoothing_options_create_view (GtkWidget *button, GtkWidget **result, GObject *config)
 {
-  GObject   *config = G_OBJECT (paint_options);
-  GtkWidget *frame;
   GtkWidget *vbox;
   GtkWidget *scale;
+  GList     *children;
 
   vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
-
+#if 0
   frame = gimp_prop_expanding_frame_new (config, "use-smoothing",
                                          _("Smooth stroke"),
                                          vbox, NULL);
-
+#endif
   scale = gimp_prop_spin_scale_new (config, "smoothing-quality",
                                     _("Quality"),
-                                    1, 10, 1);
-  gtk_box_pack_start (GTK_BOX (vbox), scale, FALSE, FALSE, 0);
+                                    1, 20, 0);
+  gtk_box_pack_start (GTK_BOX (vbox), scale, TRUE, TRUE, 0);
   gtk_widget_show (scale);
 
   scale = gimp_prop_spin_scale_new (config, "smoothing-factor",
                                     _("Weight"),
                                     1, 10, 1);
-  gtk_box_pack_start (GTK_BOX (vbox), scale, FALSE, FALSE, 0);
+  gtk_box_pack_start (GTK_BOX (vbox), scale, TRUE, TRUE, 0);
   gtk_widget_show (scale);
 
-  return frame;
+  children = gtk_container_get_children (GTK_CONTAINER (vbox));
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
+  *result = vbox;
+}
+
+static GtkWidget *
+texture_options_gui (GimpPaintOptions         *paint_options,
+                     GType                       tool_type,
+                     gboolean                    horizontal)
+{
+  return gimp_tool_options_toggle_gui_with_popup (G_OBJECT (paint_options), tool_type,
+                             "use-texture", _("Texture"), _("Use texture"),
+                             horizontal, texture_options_create_view);
 }
 
 static void
-gimp_paint_options_gui_reset_size (GtkWidget        *button,
-                                   GimpPaintOptions *paint_options)
+texture_options_create_view (GtkWidget *button, GtkWidget **result, GObject *config)
 {
- GimpBrush *brush = gimp_context_get_brush (GIMP_CONTEXT (paint_options));
+  GtkWidget *vbox;
+  GtkWidget *widget;
+  GList     *children;
+
+  vbox   = gtk_vbox_new (FALSE, 2);
+  widget = gimp_prop_pattern_box_new (NULL, GIMP_CONTEXT (config),
+                                      NULL, 2,
+                                      "pattern-view-type", "pattern-view-size");
+  gtk_box_pack_start (GTK_BOX (vbox), widget, TRUE, TRUE, 0);
+  gtk_widget_show (widget);
 
+  children = gtk_container_get_children (GTK_CONTAINER (vbox));
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
+  *result = vbox;
+#if 0
  if (brush)
    gimp_paint_options_set_default_brush_size (paint_options, brush);
+#endif
 }
 
 static void
diff -Naur gimp-2.8.14/app/tools/gimppaintoptions-gui.h gimp-2.8.14-new/app/tools/gimppaintoptions-gui.h
--- gimp-2.8.14/app/tools/gimppaintoptions-gui.h	2015-01-27 17:28:36.896833809 +0800
+++ gimp-2.8.14-new/app/tools/gimppaintoptions-gui.h	2015-01-27 17:48:55.391751578 +0800
@@ -20,6 +20,8 @@
 
 
 GtkWidget * gimp_paint_options_gui (GimpToolOptions *tool_options);
+GtkWidget * gimp_paint_options_gui_horizontal (GimpToolOptions *tool_options);
+GtkWidget * gimp_paint_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal);
 
 
 #endif /* __GIMP_PAINT_OPTIONS_GUI_H__ */
diff -Naur gimp-2.8.14/app/tools/gimppenciltool.c gimp-2.8.14-new/app/tools/gimppenciltool.c
--- gimp-2.8.14/app/tools/gimppenciltool.c	2015-01-27 17:28:36.898833808 +0800
+++ gimp-2.8.14-new/app/tools/gimppenciltool.c	2015-01-27 17:48:55.391751578 +0800
@@ -44,6 +44,7 @@
   (* callback) (GIMP_TYPE_PENCIL_TOOL,
                 GIMP_TYPE_PENCIL_OPTIONS,
                 gimp_paint_options_gui,
+                gimp_paint_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK |
                 GIMP_CONTEXT_GRADIENT_MASK,
                 "gimp-pencil-tool",
diff -Naur gimp-2.8.14/app/tools/gimpperspectiveclonetool.c gimp-2.8.14-new/app/tools/gimpperspectiveclonetool.c
--- gimp-2.8.14/app/tools/gimpperspectiveclonetool.c	2015-01-27 17:28:36.895833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpperspectiveclonetool.c	2015-01-27 17:48:55.391751578 +0800
@@ -39,6 +39,7 @@
 #include "display/gimpdisplay.h"
 
 #include "gimpperspectiveclonetool.h"
+#include "gimptooloptions-gui.h"
 #include "gimppaintoptions-gui.h"
 #include "gimptoolcontrol.h"
 
@@ -113,6 +114,14 @@
 
 static GtkWidget   * gimp_perspective_clone_options_gui                 (GimpToolOptions *tool_options);
 
+static GtkWidget   * gimp_perspective_clone_options_gui_full            (GimpToolOptions *tool_options,
+                                                                          gboolean horizontal);
+
+static GtkWidget   * gimp_perspective_clone_options_gui_horizontal      (GimpToolOptions *tool_options);
+static void          gimp_perspective_clone_options_create_view         (GtkWidget *source,  
+                                                                          GtkWidget **result, 
+                                                                          GObject *config);
+
 
 G_DEFINE_TYPE (GimpPerspectiveCloneTool, gimp_perspective_clone_tool,
                GIMP_TYPE_BRUSH_TOOL)
@@ -127,6 +136,7 @@
   (* callback) (GIMP_TYPE_PERSPECTIVE_CLONE_TOOL,
                 GIMP_TYPE_PERSPECTIVE_CLONE_OPTIONS,
                 gimp_perspective_clone_options_gui,
+                gimp_perspective_clone_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK |
                 GIMP_CONTEXT_PATTERN_MASK,
                 "gimp-perspective-clone-tool",
@@ -872,20 +882,23 @@
 /*  tool options stuff  */
 
 static GtkWidget *
-gimp_perspective_clone_options_gui (GimpToolOptions *tool_options)
+gimp_perspective_clone_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
-  GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox;
+  GtkWidget *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget *paint_options;
   GtkWidget *frame;
   GtkWidget *mode;
+  GType      tool_type = G_TYPE_NONE;
+  GObject   *config = G_OBJECT (tool_options);
+#if 0
   GtkWidget *button;
   GtkWidget *hbox;
   GtkWidget *label;
   GtkWidget *combo;
+#endif
 
-  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
-  paint_options = gimp_paint_options_gui (tool_options);
+  vbox = gimp_tool_options_gui_full (tool_options, horizontal);
+  paint_options = gimp_paint_options_gui_full (tool_options, horizontal);
 
   /* radio buttons to set if you are modifying perspe plane or painting */
   mode = gimp_prop_enum_radio_box_new (config, "clone-mode", 0, 0);
@@ -894,7 +907,37 @@
 
   gtk_box_pack_start (GTK_BOX (vbox), paint_options, FALSE, FALSE, 0);
   gtk_widget_show (paint_options);
+  
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Options"),
+                                                  horizontal, gimp_perspective_clone_options_create_view);
+  gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 0);
+  gtk_widget_show (frame);
+
+  if (horizontal)
+    {
+      GList *children;
+      children = gtk_container_get_children (GTK_CONTAINER (vbox));  
+      gimp_tool_options_setup_popup_layout (children, FALSE);
+    }  
+
+  return vbox;
+}
 
+  
+static void
+gimp_perspective_clone_options_create_view (GtkWidget *source, GtkWidget **result, GObject *config)
+{
+  GimpToolOptions *tool_options = GIMP_TOOL_OPTIONS (config);
+  GtkWidget *vbox;
+  GtkWidget *frame;
+  GtkWidget *button;
+  GtkWidget *hbox;
+  GtkWidget *table;
+  GtkWidget *combo;
+  GtkWidget *label;
+
+  vbox = gtk_vbox_new (FALSE, 6);
   frame = gimp_prop_enum_radio_frame_new (config, "clone-type",
                                           _("Source"), 0, 0);
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
@@ -923,5 +966,17 @@
   gtk_box_pack_start (GTK_BOX (hbox), combo, TRUE, TRUE, 0);
   gtk_widget_show (combo);
 
-  return vbox;
+  *result = vbox;
+}
+
+static GtkWidget *
+gimp_perspective_clone_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_perspective_clone_options_gui_full (tool_options, FALSE);
+}
+
+static GtkWidget *
+gimp_perspective_clone_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_perspective_clone_options_gui_full (tool_options, TRUE);
 }
diff -Naur gimp-2.8.14/app/tools/gimpperspectivetool.c gimp-2.8.14-new/app/tools/gimpperspectivetool.c
--- gimp-2.8.14/app/tools/gimpperspectivetool.c	2015-01-27 17:28:36.901833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpperspectivetool.c	2015-01-27 17:48:55.391751578 +0800
@@ -77,6 +77,7 @@
   (* callback) (GIMP_TYPE_PERSPECTIVE_TOOL,
                 GIMP_TYPE_TRANSFORM_OPTIONS,
                 gimp_transform_options_gui,
+                gimp_transform_options_gui_horizontal,
                 GIMP_CONTEXT_BACKGROUND_MASK,
                 "gimp-perspective-tool",
                 _("Perspective"),
diff -Naur gimp-2.8.14/app/tools/gimpposterizetool.c gimp-2.8.14-new/app/tools/gimpposterizetool.c
--- gimp-2.8.14/app/tools/gimpposterizetool.c	2015-01-27 17:28:36.899833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpposterizetool.c	2015-01-27 17:48:55.392751578 +0800
@@ -78,7 +78,7 @@
                               gpointer                  data)
 {
   (* callback) (GIMP_TYPE_POSTERIZE_TOOL,
-                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL,
+                GIMP_TYPE_IMAGE_MAP_OPTIONS, NULL, NULL,
                 0,
                 "gimp-posterize-tool",
                 _("Posterize"),
diff -Naur gimp-2.8.14/app/tools/gimprectangleoptions.c gimp-2.8.14-new/app/tools/gimprectangleoptions.c
--- gimp-2.8.14/app/tools/gimprectangleoptions.c	2015-01-27 17:28:36.891833809 +0800
+++ gimp-2.8.14-new/app/tools/gimprectangleoptions.c	2015-01-27 17:48:55.392751578 +0800
@@ -65,7 +65,11 @@
 
 static void     gimp_number_pair_entry_history_add            (GtkWidget                     *entry,
                                                                GtkTreeModel                  *model);
-
+static void     gimp_rectangle_options_create_view            (GtkWidget *source, 
+                                                               GtkWidget **result, 
+                                                               GObject *config);
+static void     gimp_rectangle_options_destroy_view           (GtkWidget *widget, 
+                                                               gpointer   data);
 
 GType
 gimp_rectangle_options_interface_get_type (void)
@@ -825,15 +829,47 @@
 GtkWidget *
 gimp_rectangle_options_gui (GimpToolOptions *tool_options)
 {
+  return gimp_rectangle_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_rectangle_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_rectangle_options_gui_full (tool_options, TRUE);
+}
+
+GtkWidget *
+gimp_rectangle_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
+{
+  GtkWidget *frame;
+  GObject   *config    = G_OBJECT (tool_options);
+  GType      tool_type = G_TYPE_NONE;
+
+  /* Detail Options */
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Selection details..."),
+                                                  horizontal, gimp_rectangle_options_create_view);
+  gtk_widget_show (frame);
+
+  return frame;
+}
+
+static void
+gimp_rectangle_options_create_view (GtkWidget *source, GtkWidget **result, GObject *config)
+{
+  GimpToolOptions             *tool_options = GIMP_TOOL_OPTIONS (config);
   GimpRectangleOptionsPrivate *private;
-  GObject                     *config = G_OBJECT (tool_options);
-  GtkWidget                   *vbox   = gimp_tool_options_gui (tool_options);
+  GtkWidget                   *vbox         = gimp_tool_options_gui_full (tool_options, FALSE);
   GtkWidget                   *button;
   GtkWidget                   *combo;
   GtkWidget                   *frame;
 
   private = GIMP_RECTANGLE_OPTIONS_GET_PRIVATE (tool_options);
 
+  g_signal_connect (vbox, "destroy",
+                    G_CALLBACK (gimp_rectangle_options_destroy_view),
+                    config);
+
   /* Fixed Center */
   button = gimp_prop_check_button_new (config, "fixed-center",
                                        _("Expand from center"));
@@ -1054,9 +1090,41 @@
   /* Setup initial fixed rule widgets */
   gimp_rectangle_options_fixed_rule_changed (NULL, private);
 
-  return vbox;
+  *result = vbox;
 }
 
+static void
+gimp_rectangle_options_destroy_view (GtkWidget *widget, 
+                                     gpointer   data)
+{
+  GimpRectangleOptions *options = GIMP_RECTANGLE_OPTIONS (data);
+  GimpRectangleOptionsPrivate *private;
+  private = GIMP_RECTANGLE_OPTIONS_GET_PRIVATE (options);
+
+/* FIXME: following code should be executed */
+/*
+  g_signal_handlers_disconnect_by_func (config, 
+                                        G_CALLBACK (gimp_rectangle_options_string_current_updates),
+                                        entry);
+*/
+  if (private)
+    {
+      private->x_entry = NULL;
+      private->y_entry = NULL;
+      private->width_entry = NULL;
+      private->height_entry = NULL;
+      private->aspect_button_box = NULL;
+      private->size_button_box = NULL;
+      private->fixed_width_entry = NULL;
+      private->fixed_height_entry = NULL;
+      private->fixed_aspect_hbox = NULL;
+      private->fixed_size_hbox = NULL;
+      private->auto_shrink_button = NULL;
+    }
+
+}
+
+
 /**
  * gimp_rectangle_options_fixed_rule_active:
  * @rectangle_options:
diff -Naur gimp-2.8.14/app/tools/gimprectangleoptions.h gimp-2.8.14-new/app/tools/gimprectangleoptions.h
--- gimp-2.8.14/app/tools/gimprectangleoptions.h	2015-01-27 17:28:36.902833808 +0800
+++ gimp-2.8.14-new/app/tools/gimprectangleoptions.h	2015-01-27 17:48:55.393751578 +0800
@@ -143,6 +143,9 @@
 
 GType       gimp_rectangle_options_interface_get_type (void) G_GNUC_CONST;
 
+GtkWidget * gimp_rectangle_options_gui_full           (GimpToolOptions      *tool_options,
+                                                       gboolean              horizontal);
+GtkWidget * gimp_rectangle_options_gui_horizontal     (GimpToolOptions      *tool_options);
 GtkWidget * gimp_rectangle_options_gui                (GimpToolOptions      *tool_options);
 
 gboolean    gimp_rectangle_options_fixed_rule_active  (GimpRectangleOptions *rectangle_options,
diff -Naur gimp-2.8.14/app/tools/gimprectangleselectoptions.c gimp-2.8.14-new/app/tools/gimprectangleselectoptions.c
--- gimp-2.8.14/app/tools/gimprectangleselectoptions.c	2015-01-27 17:28:36.898833808 +0800
+++ gimp-2.8.14-new/app/tools/gimprectangleselectoptions.c	2015-01-27 17:48:55.393751578 +0800
@@ -146,11 +146,11 @@
     }
 }
 
-GtkWidget *
-gimp_rectangle_select_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_rectangle_select_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_selection_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_selection_options_gui_full (tool_options, horizontal);
 
   /*  the round corners frame  */
   if (tool_options->tool_info->tool_type == GIMP_TYPE_RECTANGLE_SELECT_TOOL)
@@ -180,10 +180,23 @@
   {
     GtkWidget *vbox_rectangle;
 
-    vbox_rectangle = gimp_rectangle_options_gui (tool_options);
+    vbox_rectangle = gimp_rectangle_options_gui_full (tool_options, horizontal);
     gtk_box_pack_start (GTK_BOX (vbox), vbox_rectangle, FALSE, FALSE, 0);
     gtk_widget_show (vbox_rectangle);
   }
 
   return vbox;
 }
+
+GtkWidget *
+gimp_rectangle_select_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_rectangle_select_options_gui_full (tool_options, FALSE);
+}
+
+
+GtkWidget *
+gimp_rectangle_select_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_rectangle_select_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimprectangleselectoptions.h gimp-2.8.14-new/app/tools/gimprectangleselectoptions.h
--- gimp-2.8.14/app/tools/gimprectangleselectoptions.h	2015-01-27 17:28:36.897833808 +0800
+++ gimp-2.8.14-new/app/tools/gimprectangleselectoptions.h	2015-01-27 17:48:55.393751578 +0800
@@ -42,9 +42,10 @@
 };
 
 
-GType       gimp_rectangle_select_options_get_type (void) G_GNUC_CONST;
+GType       gimp_rectangle_select_options_get_type       (void) G_GNUC_CONST;
 
-GtkWidget * gimp_rectangle_select_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_rectangle_select_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_rectangle_select_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif /* __GIMP_RECTANGLE_SELECT_OPTIONS_H__ */
diff -Naur gimp-2.8.14/app/tools/gimprectangleselecttool.c gimp-2.8.14-new/app/tools/gimprectangleselecttool.c
--- gimp-2.8.14/app/tools/gimprectangleselecttool.c	2015-01-27 17:28:36.903833808 +0800
+++ gimp-2.8.14-new/app/tools/gimprectangleselecttool.c	2015-01-27 17:48:55.394751578 +0800
@@ -163,6 +163,7 @@
   (* callback) (GIMP_TYPE_RECTANGLE_SELECT_TOOL,
                 GIMP_TYPE_RECTANGLE_SELECT_OPTIONS,
                 gimp_rectangle_select_options_gui,
+                gimp_rectangle_select_options_gui_horizontal,
                 0,
                 "gimp-rect-select-tool",
                 _("Rectangle Select"),
diff -Naur gimp-2.8.14/app/tools/gimpregionselectoptions.c gimp-2.8.14-new/app/tools/gimpregionselectoptions.c
--- gimp-2.8.14/app/tools/gimpregionselectoptions.c	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpregionselectoptions.c	2015-01-27 17:48:55.394751578 +0800
@@ -188,11 +188,11 @@
   GIMP_TOOL_OPTIONS_CLASS (parent_class)->reset (tool_options);
 }
 
-GtkWidget *
-gimp_region_select_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_region_select_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject   *config  = G_OBJECT (tool_options);
-  GtkWidget *vbox    = gimp_selection_options_gui (tool_options);
+  GtkWidget *vbox    = gimp_selection_options_gui_full (tool_options, horizontal);
   GtkWidget *button;
   GtkWidget *scale;
   GtkWidget *hbox;
@@ -233,3 +233,16 @@
 
   return vbox;
 }
+
+
+GtkWidget *
+gimp_region_select_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_region_select_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_region_select_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_region_select_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpregionselectoptions.h gimp-2.8.14-new/app/tools/gimpregionselectoptions.h
--- gimp-2.8.14/app/tools/gimpregionselectoptions.h	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpregionselectoptions.h	2015-01-27 17:48:55.394751578 +0800
@@ -44,9 +44,10 @@
 };
 
 
-GType       gimp_region_select_options_get_type (void) G_GNUC_CONST;
+GType       gimp_region_select_options_get_type       (void) G_GNUC_CONST;
 
-GtkWidget * gimp_region_select_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_region_select_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_region_select_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_REGION_SELECT_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimprotatetool.c gimp-2.8.14-new/app/tools/gimprotatetool.c
--- gimp-2.8.14/app/tools/gimprotatetool.c	2015-01-27 17:28:36.893833809 +0800
+++ gimp-2.8.14-new/app/tools/gimprotatetool.c	2015-01-27 17:48:55.394751578 +0800
@@ -88,6 +88,7 @@
   (* callback) (GIMP_TYPE_ROTATE_TOOL,
                 GIMP_TYPE_TRANSFORM_OPTIONS,
                 gimp_transform_options_gui,
+                gimp_transform_options_gui_horizontal,
                 GIMP_CONTEXT_BACKGROUND_MASK,
                 "gimp-rotate-tool",
                 _("Rotate"),
diff -Naur gimp-2.8.14/app/tools/gimpscaletool.c gimp-2.8.14-new/app/tools/gimpscaletool.c
--- gimp-2.8.14/app/tools/gimpscaletool.c	2015-01-27 17:28:36.905833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpscaletool.c	2015-01-27 17:48:55.395751578 +0800
@@ -84,6 +84,7 @@
   (* callback) (GIMP_TYPE_SCALE_TOOL,
                 GIMP_TYPE_TRANSFORM_OPTIONS,
                 gimp_transform_options_gui,
+                gimp_transform_options_gui_horizontal,
                 GIMP_CONTEXT_BACKGROUND_MASK,
                 "gimp-scale-tool",
                 _("Scale"),
diff -Naur gimp-2.8.14/app/tools/gimpselectionoptions.c gimp-2.8.14-new/app/tools/gimpselectionoptions.c
--- gimp-2.8.14/app/tools/gimpselectionoptions.c	2015-01-27 17:28:36.890833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpselectionoptions.c	2015-01-27 17:48:55.395751578 +0800
@@ -24,6 +24,8 @@
 
 #include "tools-types.h"
 
+#include "core/gimptoolinfo.h"
+
 #include "widgets/gimppropwidgets.h"
 #include "widgets/gimpwidgets-utils.h"
 
@@ -51,6 +53,9 @@
                                                    guint         property_id,
                                                    GValue       *value,
                                                    GParamSpec   *pspec);
+static void   feather_radius_options_create_view  (GtkWidget *button, 
+                                                   GtkWidget **result, 
+                                                   GObject *config);
 
 
 G_DEFINE_TYPE (GimpSelectionOptions, gimp_selection_options,
@@ -194,11 +199,11 @@
 }
 
 GtkWidget *
-gimp_selection_options_gui (GimpToolOptions *tool_options)
+gimp_selection_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject              *config  = G_OBJECT (tool_options);
   GimpSelectionOptions *options = GIMP_SELECTION_OPTIONS (tool_options);
-  GtkWidget            *vbox    = gimp_tool_options_gui (tool_options);
+  GtkWidget            *vbox    = gimp_tool_options_gui_full (tool_options, horizontal);
   GtkWidget            *button;
 
   /*  the selection operation radio buttons  */
@@ -259,6 +264,7 @@
     g_list_free (children);
   }
 
+#if 0
   /*  the antialias toggle button  */
   button = gimp_prop_check_button_new (config, "antialias",
                                        _("Antialiasing"));
@@ -266,23 +272,54 @@
   gtk_widget_show (button);
 
   options->antialias_toggle = button;
-
+#endif
   /*  the feather frame  */
   {
     GtkWidget *frame;
-    GtkWidget *scale;
-
-    /*  the feather radius scale  */
-    scale = gimp_prop_spin_scale_new (config, "feather-radius",
-                                      _("Radius"),
-                                      1.0, 10.0, 1);
-
-    frame = gimp_prop_expanding_frame_new (config, "feather",
-                                           _("Feather edges"),
-                                           scale, NULL);
+    GType      tool_type;
+    tool_type = tool_options->tool_info->tool_type;
+    frame = gimp_tool_options_toggle_gui_with_popup (config, tool_type,
+                                                     "antialias",
+                                                     _("Antialiasing"),
+                                                     _("Antialiasing"),
+                                                     horizontal,
+                                                     feather_radius_options_create_view);
     gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
     gtk_widget_show (frame);
+
+    options->antialias_toggle = frame;
   }
 
   return vbox;
 }
+
+static void
+feather_radius_options_create_view (GtkWidget *button, GtkWidget **result, GObject *config)
+{
+  GtkWidget *scale;
+  GtkWidget *vbox  = gtk_vbox_new (FALSE, 2);
+  GList     *children;
+
+  /*  the feather radius scale  */
+  scale = gimp_prop_spin_scale_new (config, "feather-radius",
+                                    _("Radius"),
+                                    1.0, 10.0, 1);
+  gtk_box_pack_start (GTK_BOX (vbox), scale, TRUE, TRUE, 0);
+  gtk_widget_show (scale);
+  *result = vbox;
+
+  children = gtk_container_get_children (GTK_CONTAINER (vbox));
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+}
+
+GtkWidget *
+gimp_selection_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_selection_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_selection_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_selection_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpselectionoptions.h gimp-2.8.14-new/app/tools/gimpselectionoptions.h
--- gimp-2.8.14/app/tools/gimpselectionoptions.h	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpselectionoptions.h	2015-01-27 17:48:55.395751578 +0800
@@ -47,9 +47,12 @@
 };
 
 
-GType       gimp_selection_options_get_type (void) G_GNUC_CONST;
+GType       gimp_selection_options_get_type       (void) G_GNUC_CONST;
 
-GtkWidget * gimp_selection_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_selection_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_selection_options_gui_horizontal (GimpToolOptions *tool_options);
+GtkWidget * gimp_selection_options_gui_full       (GimpToolOptions *tool_options,
+                                                   gboolean horizontal);
 
 
 #endif  /*  __GIMP_SELECTION_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpsheartool.c gimp-2.8.14-new/app/tools/gimpsheartool.c
--- gimp-2.8.14/app/tools/gimpsheartool.c	2015-01-27 17:28:36.903833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpsheartool.c	2015-01-27 17:48:55.395751578 +0800
@@ -78,6 +78,7 @@
   (* callback) (GIMP_TYPE_SHEAR_TOOL,
                 GIMP_TYPE_TRANSFORM_OPTIONS,
                 gimp_transform_options_gui,
+                gimp_transform_options_gui_horizontal,
                 0,
                 "gimp-shear-tool",
                 _("Shear"),
diff -Naur gimp-2.8.14/app/tools/gimpsmudgetool.c gimp-2.8.14-new/app/tools/gimpsmudgetool.c
--- gimp-2.8.14/app/tools/gimpsmudgetool.c	2015-01-27 17:28:36.896833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpsmudgetool.c	2015-01-27 17:48:55.396751578 +0800
@@ -29,6 +29,7 @@
 #include "widgets/gimppropwidgets.h"
 
 #include "gimpsmudgetool.h"
+#include "gimptooloptions-gui.h"
 #include "gimppaintoptions-gui.h"
 #include "gimptoolcontrol.h"
 
@@ -36,6 +37,8 @@
 
 
 static GtkWidget * gimp_smudge_options_gui (GimpToolOptions *tool_options);
+static GtkWidget * gimp_smudge_options_gui_horizontal (GimpToolOptions *tool_options);
+static GtkWidget * gimp_smudge_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal);
 
 
 G_DEFINE_TYPE (GimpSmudgeTool, gimp_smudge_tool, GIMP_TYPE_BRUSH_TOOL)
@@ -48,6 +51,7 @@
   (* callback) (GIMP_TYPE_SMUDGE_TOOL,
                 GIMP_TYPE_SMUDGE_OPTIONS,
                 gimp_smudge_options_gui,
+                gimp_smudge_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK,
                 "gimp-smudge-tool",
                 _("Smudge"),
@@ -82,9 +86,22 @@
 static GtkWidget *
 gimp_smudge_options_gui (GimpToolOptions *tool_options)
 {
+  return gimp_smudge_options_gui_full (tool_options, FALSE);
+}
+
+static GtkWidget *
+gimp_smudge_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_smudge_options_gui_full (tool_options, TRUE);
+}
+
+static GtkWidget *
+gimp_smudge_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
+{
   GObject   *config = G_OBJECT (tool_options);
-  GtkWidget *vbox   = gimp_paint_options_gui (tool_options);
+  GtkWidget *vbox   = gimp_paint_options_gui_full (tool_options, horizontal);
   GtkWidget *scale;
+  GList     *children;
 
   /*  the rate scale  */
   scale = gimp_prop_spin_scale_new (config, "rate",
@@ -93,5 +110,8 @@
   gtk_box_pack_start (GTK_BOX (vbox), scale, FALSE, FALSE, 0);
   gtk_widget_show (scale);
 
+  children = gtk_container_get_children (GTK_CONTAINER (vbox));  
+  gimp_tool_options_setup_popup_layout (children, FALSE);
+
   return vbox;
 }
diff -Naur gimp-2.8.14/app/tools/gimptextoptions.c gimp-2.8.14-new/app/tools/gimptextoptions.c
--- gimp-2.8.14/app/tools/gimptextoptions.c	2015-01-27 17:28:36.899833808 +0800
+++ gimp-2.8.14-new/app/tools/gimptextoptions.c	2015-01-27 17:48:55.396751578 +0800
@@ -76,6 +76,7 @@
                                                    guint            property_id,
                                                    const GValue    *value,
                                                    GParamSpec      *pspec);
+
 static void  gimp_text_options_get_property       (GObject         *object,
                                                    guint            property_id,
                                                    GValue          *value,
@@ -96,6 +97,10 @@
                                                    GParamSpec      *pspec,
                                                    GimpContext     *context);
 
+/* gimp-painter-2.7 */
+static void  gimp_text_options_create_view        (GtkWidget *source, 
+                                                   GtkWidget **result, 
+                                                   GObject *config);
 
 G_DEFINE_TYPE_WITH_CODE (GimpTextOptions, gimp_text_options,
                          GIMP_TYPE_TOOL_OPTIONS,
@@ -490,22 +495,26 @@
                            options, 0);
 }
 
-GtkWidget *
-gimp_text_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_text_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject         *config    = G_OBJECT (tool_options);
   GimpTextOptions *options   = GIMP_TEXT_OPTIONS (tool_options);
-  GtkWidget       *main_vbox = gimp_tool_options_gui (tool_options);
+  GtkWidget       *main_vbox = gimp_tool_options_gui_full (tool_options, horizontal);
+  GtkWidget       *frame;
   GtkWidget       *table;
   GtkWidget       *vbox;
   GtkWidget       *hbox;
   GtkWidget       *button;
   GtkWidget       *entry;
+/*
   GtkWidget       *box;
   GtkWidget       *spinbutton;
   GtkWidget       *combo;
   GtkSizeGroup    *size_group;
+*/
   gint             row = 0;
+  GType            tool_type = G_TYPE_NONE;
 
   hbox = gimp_prop_font_box_new (NULL, GIMP_CONTEXT (tool_options),
                                  _("Font"), 2,
@@ -528,7 +537,7 @@
 
   options->size_entry = entry;
 
-  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
+  vbox = gimp_tool_options_gui_full (tool_options, horizontal);
   gtk_box_pack_start (GTK_BOX (main_vbox), vbox, FALSE, FALSE, 0);
   gtk_widget_show (vbox);
 
@@ -540,6 +549,51 @@
   gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
   gtk_widget_show (button);
 
+  if (horizontal)
+    {
+      button = gimp_prop_color_button_new (config, "foreground", _("Text Color"),
+                                           40, 24, GIMP_COLOR_AREA_FLAT);
+      gimp_color_panel_set_context (GIMP_COLOR_PANEL (button),
+                                    GIMP_CONTEXT (options));
+      gtk_box_pack_start (GTK_BOX (main_vbox), button, FALSE, FALSE, 0);
+      gtk_widget_show (button);
+    }
+
+  /* Detail Options */
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Details..."),
+                                                  horizontal, gimp_text_options_create_view);
+  gtk_box_pack_start (GTK_BOX (main_vbox), frame, TRUE, TRUE, 0);
+  gtk_widget_show (frame);
+
+  if (horizontal)
+    {
+      GList *children;
+      children = gtk_container_get_children (GTK_CONTAINER (vbox));  
+      gimp_tool_options_setup_popup_layout (children, FALSE);
+    }  
+  
+  return main_vbox;
+}
+  
+static void
+gimp_text_options_create_view (GtkWidget *source, GtkWidget **result, GObject *config)
+{
+  GimpToolOptions *tool_options = GIMP_TOOL_OPTIONS (config);
+  GimpTextOptions *options      = GIMP_TEXT_OPTIONS (tool_options);
+  GtkWidget       *main_vbox    = gimp_tool_options_gui_full (tool_options, FALSE);
+  GtkWidget       *table;
+  GtkWidget       *vbox;
+  GtkWidget       *hbox;
+  GtkWidget       *button;
+  GtkWidget       *entry;
+  GtkWidget       *box;
+  GtkWidget       *label;
+  GtkWidget       *spinbutton;
+  GtkWidget       *combo;
+  GtkSizeGroup    *size_group;
+  gint             row = 0;
+
   table = gtk_table_new (6, 3, FALSE);
   gtk_table_set_col_spacings (GTK_TABLE (table), 2);
   gtk_table_set_row_spacings (GTK_TABLE (table), 2);
@@ -617,7 +671,19 @@
   }
 #endif
 
-  return main_vbox;
+  *result = main_vbox;
+}
+
+GtkWidget *
+gimp_text_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_text_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_text_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_text_options_gui_full (tool_options, TRUE);
 }
 
 static void
diff -Naur gimp-2.8.14/app/tools/gimptextoptions.h gimp-2.8.14-new/app/tools/gimptextoptions.h
--- gimp-2.8.14/app/tools/gimptextoptions.h	2015-01-27 17:28:36.892833809 +0800
+++ gimp-2.8.14-new/app/tools/gimptextoptions.h	2015-01-27 17:48:55.396751578 +0800
@@ -64,7 +64,8 @@
 void        gimp_text_options_connect_text (GimpTextOptions *options,
                                             GimpText        *text);
 
-GtkWidget * gimp_text_options_gui          (GimpToolOptions *tool_options);
+GtkWidget * gimp_text_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_text_options_gui_horizontal (GimpToolOptions *tool_options);
 
 GtkWidget * gimp_text_options_editor_new   (GtkWindow       *parent,
                                             Gimp            *gimp,
diff -Naur gimp-2.8.14/app/tools/gimptexttool.c gimp-2.8.14-new/app/tools/gimptexttool.c
--- gimp-2.8.14/app/tools/gimptexttool.c	2015-01-27 17:28:36.899833808 +0800
+++ gimp-2.8.14-new/app/tools/gimptexttool.c	2015-01-27 17:48:55.397751578 +0800
@@ -184,6 +184,7 @@
   (* callback) (GIMP_TYPE_TEXT_TOOL,
                 GIMP_TYPE_TEXT_OPTIONS,
                 gimp_text_options_gui,
+                gimp_text_options_gui_horizontal,
                 GIMP_CONTEXT_FOREGROUND_MASK |
                 GIMP_CONTEXT_FONT_MASK       |
                 GIMP_CONTEXT_PALETTE_MASK /* for the color popup's palette tab */,
diff -Naur gimp-2.8.14/app/tools/gimpthresholdtool.c gimp-2.8.14-new/app/tools/gimpthresholdtool.c
--- gimp-2.8.14/app/tools/gimpthresholdtool.c	2015-01-27 17:28:36.901833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpthresholdtool.c	2015-01-27 17:48:55.397751578 +0800
@@ -85,6 +85,7 @@
   (* callback) (GIMP_TYPE_THRESHOLD_TOOL,
                 GIMP_TYPE_HISTOGRAM_OPTIONS,
                 gimp_histogram_options_gui,
+                NULL,
                 0,
                 "gimp-threshold-tool",
                 _("Threshold"),
diff -Naur gimp-2.8.14/app/tools/gimptool.c gimp-2.8.14-new/app/tools/gimptool.c
--- gimp-2.8.14/app/tools/gimptool.c	2015-01-27 17:28:36.898833808 +0800
+++ gimp-2.8.14-new/app/tools/gimptool.c	2015-01-27 17:48:55.397751578 +0800
@@ -178,6 +178,7 @@
 {
   tool->tool_info             = NULL;
   tool->ID                    = global_tool_ID++;
+  tool->want_full_motion_tracking = FALSE;
   tool->control               = g_object_new (GIMP_TYPE_TOOL_CONTROL, NULL);
   tool->display               = NULL;
   tool->drawable              = NULL;
@@ -708,8 +709,8 @@
   g_return_if_fail (GIMP_IS_TOOL (tool));
   g_return_if_fail (coords != NULL);
   g_return_if_fail (GIMP_IS_DISPLAY (display));
-  g_return_if_fail (gimp_tool_control_is_active (tool->control) == TRUE);
-
+  g_return_if_fail (gimp_tool_control_is_active (tool->control) == TRUE ||
+                    tool->want_full_motion_tracking);
   tool->got_motion_event = TRUE;
   gimp_tool_check_click_distance (tool, coords, time, display);
 
diff -Naur gimp-2.8.14/app/tools/gimptool.h gimp-2.8.14-new/app/tools/gimptool.h
--- gimp-2.8.14/app/tools/gimptool.h	2015-01-27 17:28:36.903833808 +0800
+++ gimp-2.8.14-new/app/tools/gimptool.h	2015-01-27 17:48:55.398751578 +0800
@@ -41,6 +41,7 @@
   GimpToolInfo    *tool_info;
 
   gint             ID;          /*  unique tool ID                         */
+  gboolean         want_full_motion_tracking; /* gimp-painter: set to true to grab all motion-notify-event */
 
   GimpToolControl *control;
 
diff -Naur gimp-2.8.14/app/tools/gimptooloptions-gui.c gimp-2.8.14-new/app/tools/gimptooloptions-gui.c
--- gimp-2.8.14/app/tools/gimptooloptions-gui.c	2015-01-27 17:28:36.894833809 +0800
+++ gimp-2.8.14-new/app/tools/gimptooloptions-gui.c	2015-01-27 17:48:55.399751578 +0800
@@ -17,27 +17,669 @@
 
 #include "config.h"
 
+#include <glib-object.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "libgimpwidgets/gimpwidgets.h"
 
 #include "tools-types.h"
 
+#include "libgimpwidgets/gimpwidgets.h"
+
 #include "core/gimptooloptions.h"
 
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpspinscale.h"
+
 #include "gimptooloptions-gui.h"
 
 
 /*  public functions  */
-
 GtkWidget *
 gimp_tool_options_gui (GimpToolOptions *tool_options)
 {
+  return gimp_tool_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_tool_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
+{
   GtkWidget *vbox;
 
   g_return_val_if_fail (GIMP_IS_TOOL_OPTIONS (tool_options), NULL);
 
-  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 4);
+  if (horizontal)
+    {
+      vbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 4);
+    }
+  else
+    {
+      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 4);
+    }
+  g_object_set (vbox, "homogeneous", FALSE, NULL);
 
   return vbox;
 }
+
+GtkWidget * gimp_tool_options_table (gint num_items, gboolean horizontal)
+{
+  GtkWidget *table;
+  
+  g_return_val_if_fail (num_items > 0, NULL);
+  
+  if (horizontal)
+    {
+      table = gtk_table_new (1, num_items * 3, FALSE);
+    }
+  else
+    {
+      table = gtk_table_new (num_items, 3, FALSE);
+    }
+  
+  return table;
+}
+
+GimpToolOptionsTableIncrement gimp_tool_options_table_increment (gboolean horizontal)
+{
+  GimpToolOptionsTableIncrement result;
+  result.table_col = result.table_row = 0;
+  result.horizontal = horizontal;
+  return result;
+}
+
+inline 
+gint gimp_tool_options_table_increment_get_col (GimpToolOptionsTableIncrement* inc)
+{
+  return inc->table_col;
+}
+
+inline 
+gint gimp_tool_options_table_increment_get_row (GimpToolOptionsTableIncrement* inc)
+{
+  return inc->table_row;
+}
+
+inline
+void gimp_tool_options_table_increment_next (GimpToolOptionsTableIncrement* inc)
+{
+  if (inc->horizontal)
+    inc->table_col += 3;
+  else
+    inc->table_row ++;
+}
+
+void
+gimp_tool_options_setup_popup_layout (GList *children, gboolean hide_label)
+{
+  while (children)
+    {
+      GtkWidget *widget = GTK_WIDGET (children->data);
+      GList *next = g_list_next (children);
+      if (hide_label && GTK_IS_LABEL (widget))
+        {
+          gtk_widget_destroy (widget);
+        }
+      else if (GTK_IS_HSCALE (widget) || GIMP_IS_SPIN_SCALE (widget))
+        {
+          gtk_widget_set_size_request (widget, 100, -1);
+        }
+      children = next;
+    }
+
+}
+
+
+typedef struct _GimpCreateViewInternal GimpCreateViewInternal;
+
+struct _GimpCreateViewInternal 
+{
+  GObject                        *config;
+  GimpPopupCreateViewCallbackExt  create_view;
+  gpointer                        data;
+  GClosure                       *closure;
+  void  (*destroy_data) (gpointer data);
+};
+
+static void
+create_view_internal_destroy (gpointer data, GClosure *closure)
+{
+  GimpCreateViewInternal *state = (GimpCreateViewInternal*)data;
+  if (!state)
+    return;
+
+  g_print ("tooloptions-gui:destroy\n");
+
+  if (state->config)
+    {
+      g_signal_handlers_disconnect_matched (state->config, G_SIGNAL_MATCH_CLOSURE,
+                                            0, (GQuark)0, closure, NULL, NULL);
+
+      g_object_unref (state->config);
+      state->config = NULL;
+    }
+  if (state->data && state->destroy_data)
+    {
+      (*state->destroy_data) (state->data);
+      state->data = NULL;
+    }
+  g_free (state);
+}
+
+static void
+create_view_internal_callback (GtkWidget *button, GtkWidget **result, GimpCreateViewInternal *state)
+{
+  g_return_if_fail (state && state->create_view);
+  g_return_if_fail (G_IS_OBJECT (state->config));
+  
+  *result = NULL;
+  state->create_view (button, result, state->config, state->data);  
+}
+
+static GClosure *
+generate_create_view_internal_closure (GObject *config, 
+                              GimpPopupCreateViewCallbackExt create_view,
+                              gpointer data, 
+                              void (*destroy_data) (gpointer data))
+{
+  GClosure *closure;
+  GimpCreateViewInternal *state = g_new0 (GimpCreateViewInternal, 1);
+  state->config = config;
+  g_object_ref (config);
+  state->data         = data;
+  state->destroy_data = destroy_data;
+  state->create_view  = create_view;
+  
+  closure = g_cclosure_new (G_CALLBACK (create_view_internal_callback),
+                            state, create_view_internal_destroy);
+  state->closure = closure;
+  return closure;
+}
+
+GtkWidget * 
+gimp_tool_options_button_with_popup (GObject                       *config,
+                                     GtkWidget                     *label_widget,
+                                     GimpPopupCreateViewCallbackExt create_view,
+                                     gpointer                       data,
+                                     void (*destroy_data) (gpointer data))
+{
+  GtkWidget *result = NULL;
+  GClosure  *closure;
+
+  gtk_widget_show (label_widget);
+  result = gimp_popup_button_new (label_widget);
+  
+  closure = generate_create_view_internal_closure (config, create_view, data, destroy_data);
+  g_signal_connect_closure (result, "create-view", closure, 0);
+
+  return result;
+}
+
+typedef struct _GimpCreateScaleEntry   GimpCreateScaleEntry;
+struct _GimpCreateScaleEntry
+{
+  gchar  *property_name;
+  gchar  *text;
+  gdouble       step_increment;
+  gdouble       page_increment;
+  gint          digits;
+  gboolean      limit_scale;
+  gdouble       lower_limit;
+  gdouble       upper_limit;
+  gboolean      logarithm;
+  gboolean      opacity;
+  gboolean      erase_label;
+};
+
+static void
+scale_entry_destroy (gpointer data)
+{
+  GimpCreateScaleEntry *entry_state = (GimpCreateScaleEntry*)data;
+  g_free (entry_state->property_name);
+  g_free (entry_state->text);
+}
+
+static void
+create_view_for_scale_entry (GtkWidget *button, GtkWidget **result, GimpCreateViewInternal *state)
+{
+  GtkWidget *table;
+  GimpCreateScaleEntry *entry_state = (GimpCreateScaleEntry*)(state->data);
+  GList     *children;
+
+  g_return_if_fail (state != NULL);
+  g_return_if_fail (G_IS_OBJECT (state->config));
+  g_return_if_fail (entry_state != NULL);
+  
+  table = gtk_table_new (1, 3, FALSE);
+  if (entry_state->opacity)
+    {
+      GtkObject *adj;
+      adj   = gimp_prop_opacity_entry_new (state->config, entry_state->property_name,
+                                           GTK_TABLE (table), 0, 0,
+                                           entry_state->text);
+    }
+  else
+    {
+      GtkObject *adj;
+      adj = gimp_prop_scale_entry_new (state->config, entry_state->property_name,
+                                       GTK_TABLE (table), 
+                                       0, 0,
+                                       entry_state->text,
+                                       entry_state->step_increment, 
+                                       entry_state->page_increment,
+                                       entry_state->digits,
+                                       entry_state->limit_scale, 
+                                       entry_state->lower_limit, 
+                                       entry_state->upper_limit);
+      if (entry_state->logarithm)
+        gimp_scale_entry_set_logarithmic (GTK_OBJECT (adj), TRUE);    
+    }
+
+  children = gtk_container_get_children (GTK_CONTAINER (table));  
+  gimp_tool_options_setup_popup_layout (children, entry_state->erase_label);
+
+  *result = table;
+}
+
+static GClosure *
+generate_create_scale_entry_closure (GObject *config, 
+                                     const gchar  *property_name,
+                                     const gchar  *text,
+                                     gdouble       step_increment,
+                                     gdouble       page_increment,
+                                     gint          digits,
+                                     gboolean      limit_scale,
+                                     gdouble       lower_limit,
+                                     gdouble       upper_limit,
+                                     gboolean      logarithm,
+                                     gboolean      opacity,
+                                     gboolean erase_label)
+{
+  GimpCreateViewInternal *state = g_new0 (GimpCreateViewInternal, 1);
+  GimpCreateScaleEntry* entry_state = g_new0 (GimpCreateScaleEntry, 1);
+  entry_state->property_name  = g_strdup (property_name);
+  entry_state->text           = g_strdup (text);
+  entry_state->step_increment = step_increment;
+  entry_state->page_increment = page_increment;
+  entry_state->digits         = digits;
+  entry_state->limit_scale    = limit_scale;
+  entry_state->lower_limit    = lower_limit;
+  entry_state->upper_limit    = upper_limit;
+  entry_state->logarithm      = logarithm;
+  entry_state->opacity        = opacity;
+  entry_state->erase_label    = TRUE;
+
+  state->data = entry_state;
+  state->config = config;
+  g_object_ref (config);
+
+  state->destroy_data = scale_entry_destroy;
+  
+  return g_cclosure_new (G_CALLBACK (create_view_for_scale_entry),
+                         state, create_view_internal_destroy);
+}
+
+GtkWidget *
+gimp_tool_options_frame_gui_with_popup (GObject                    *config,
+                                        GType                       tool_type, 
+                                        gchar                      *label,
+                                        gboolean                    horizontal,
+                                        GimpPopupCreateViewCallback create_view)
+{
+  GtkWidget *result = NULL;
+
+  if (horizontal)
+    {
+      GtkWidget  *button_label;
+      GtkWidget  *button;
+      GtkBox     *hbox;
+      
+      hbox          = GTK_BOX (gtk_hbox_new (FALSE, 0));
+      button_label  = gtk_label_new (label);
+      gtk_box_pack_start (GTK_BOX (hbox), button_label, TRUE, TRUE, 0);      
+      gtk_widget_show (button_label);
+      button_label  = gtk_arrow_new (GTK_ARROW_DOWN, GTK_SHADOW_ETCHED_IN);
+      gtk_box_pack_end (GTK_BOX (hbox), button_label, FALSE, FALSE, 0);
+      gtk_widget_show (button_label);
+      gtk_widget_show (GTK_WIDGET (hbox));
+
+      button        = gimp_popup_button_new (GTK_WIDGET (hbox));
+      gtk_button_set_relief (GTK_BUTTON (button), GTK_RELIEF_NONE);
+      gtk_widget_show (button);
+      
+      g_signal_connect_object (button, "create-view", G_CALLBACK (create_view), config, 0);
+      
+      result = GTK_WIDGET (button);
+    }
+  else
+    {
+      GtkWidget *table = NULL;
+      result = gimp_frame_new (label);
+      if (create_view)
+        {
+          (*create_view)(NULL, &table, config);
+          gtk_container_add (GTK_CONTAINER (result), table);
+          gtk_widget_show (table);
+        }
+      gtk_widget_show (result);
+    }
+
+  return result;
+}
+
+GtkWidget *
+gimp_tool_options_expander_gui_with_popup (GObject                    *config,
+                                           GType                       tool_type, 
+                                           gchar                      *prop_name,
+                                           gchar                      *short_label,
+                                           gchar                      *long_label,
+                                           gboolean                    horizontal,
+                                           GimpPopupCreateViewCallback create_view)
+{
+  GtkWidget *result  = NULL;
+  GtkWidget *content = NULL;
+  if (horizontal)
+    return gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                    short_label, horizontal,
+                                                    create_view);
+  else
+    {
+      result = gimp_prop_expander_new (config, prop_name,
+                                       long_label);
+
+      if (create_view)
+        {
+          (*create_view)(NULL, &content, config);
+          gtk_container_add (GTK_CONTAINER (result), content);
+          gtk_widget_show (content);
+        }
+      gtk_widget_show (result);
+    }
+  return result;
+}
+
+static void
+update_toggle_option (GtkWidget *toggle,
+                      gpointer data)
+{
+  GtkWidget       *widget         = GTK_WIDGET (data);
+  GtkToggleButton *toggled_button = GTK_TOGGLE_BUTTON (toggle);
+  gboolean         is_active;
+  
+  is_active = gtk_toggle_button_get_active (toggled_button);
+  
+  gtk_widget_set_sensitive (widget, is_active);
+}
+
+GtkWidget *
+gimp_tool_options_toggle_gui_with_popup (GObject                    *config,
+                                         GType                       tool_type, 
+                                         gchar                      *property_name,
+                                         gchar                      *short_label,
+                                         gchar                      *long_label,
+                                         gboolean                    horizontal,
+                                         GimpPopupCreateViewCallback create_view)
+{
+  GtkWidget *result;
+
+  if (horizontal)
+    {
+      GtkWidget  *button_label;
+      GtkWidget  *button;
+      GtkWidget  *toggle;
+      GtkBox     *hbox;
+      
+      hbox          = GTK_BOX (gtk_hbox_new (FALSE, 0));
+      button_label  = gtk_arrow_new (GTK_ARROW_DOWN, GTK_SHADOW_ETCHED_IN);
+      
+      toggle        = gimp_prop_check_button_new (config, property_name, short_label);
+      gtk_box_pack_start (GTK_BOX (hbox), toggle, FALSE, FALSE, 0);
+      gtk_widget_show (toggle);
+
+      button        = gimp_popup_button_new_with_parent (button_label, GTK_WIDGET (hbox));
+      gtk_button_set_relief (GTK_BUTTON (button), GTK_RELIEF_NONE);
+      gtk_box_pack_start (hbox, button, FALSE, TRUE, 0);
+      gtk_widget_show (button);
+      
+      g_signal_connect (toggle, "toggled", G_CALLBACK (update_toggle_option), button);
+      
+      g_signal_connect_object (button, "create-view", G_CALLBACK (create_view), config, 0);
+      update_toggle_option (toggle, button);
+      
+      result = GTK_WIDGET (hbox);
+    }
+  else
+    {
+      GtkWidget *frame;
+      GtkWidget *table;
+      if (create_view)
+        (*create_view)(NULL, &table, config);
+
+      frame = gimp_prop_expanding_frame_new (config, property_name,
+                                             long_label,
+                                             table, NULL);
+      result = frame;
+    }
+
+  return result;
+}
+
+static void
+config_notify_label (GObject *config, 
+                     GParamSpec *param_spec,
+                     GtkWidget  *label)
+{
+  gdouble value;
+  gchar str[40];
+  gint digits = 1;
+
+  if (G_IS_PARAM_SPEC_INT (param_spec))
+    {
+      gint int_value;
+
+      g_object_get (config, param_spec->name, &int_value, NULL);
+
+      value = int_value;
+    }
+  else if (G_IS_PARAM_SPEC_UINT (param_spec))
+    {
+      guint uint_value;
+
+      g_object_get (config, param_spec->name, &uint_value, NULL);
+
+      value = uint_value;
+    }
+  else if (G_IS_PARAM_SPEC_LONG (param_spec))
+    {
+      glong long_value;
+
+      g_object_get (config, param_spec->name, &long_value, NULL);
+
+      value = long_value;
+    }
+  else if (G_IS_PARAM_SPEC_ULONG (param_spec))
+    {
+      gulong ulong_value;
+
+      g_object_get (config, param_spec->name, &ulong_value, NULL);
+
+      value = ulong_value;
+    }
+  else if (G_IS_PARAM_SPEC_INT64 (param_spec))
+    {
+      gint64 int64_value;
+
+      g_object_get (config, param_spec->name, &int64_value, NULL);
+
+      value = int64_value;
+    }
+  else if (G_IS_PARAM_SPEC_UINT64 (param_spec))
+    {
+      guint64 uint64_value;
+
+      g_object_get (config, param_spec->name, &uint64_value, NULL);
+
+#if defined _MSC_VER && (_MSC_VER < 1300)
+      value = (gint64) uint64_value;
+#else
+      value = uint64_value;
+#endif
+    }
+  else if (G_IS_PARAM_SPEC_DOUBLE (param_spec))
+    {
+      g_object_get (config, param_spec->name, &value, NULL);
+
+      if (GPOINTER_TO_INT (g_object_get_data (G_OBJECT (label),
+                                              "percentage")))
+        value *= 100.0;
+
+    }
+  else
+    {
+      g_warning ("%s: unhandled param spec of type %s",
+                 G_STRFUNC, G_PARAM_SPEC_TYPE_NAME (param_spec));
+      return;
+    }
+    
+    digits = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (label), "digits"));
+    g_sprintf (str, "%1.*f", digits, value);
+    gtk_label_set_text (GTK_LABEL (label), str);
+}
+
+static void
+gimp_tool_options_scale_entry_new_internal (GObject      *config,
+                                            const gchar *property_name,
+                                            GtkTable     *table,
+                                            gint          column,
+                                            gint          row,
+                                            const gchar *text,
+                                            gdouble       step_increment,
+                                            gdouble       page_increment,
+                                            gint          digits,
+                                            gboolean      limit_scale,
+                                            gdouble       lower_limit,
+                                            gdouble       upper_limit,
+                                            gboolean      logarithm,
+                                            gboolean      opacity,
+                                            gboolean      horizontal)
+{
+  if (horizontal)
+    {
+      gchar      *signal_detail;
+      GtkWidget  *button_label;
+      GtkWidget  *label;
+      GtkWidget  *button;
+      GParamSpec *param_spec;
+      GClosure   *closure;
+      
+      button_label  = gtk_label_new ("");
+      button        = gimp_popup_button_new (button_label);
+      param_spec    = g_object_class_find_property (G_OBJECT_GET_CLASS (config),
+                                                    property_name);
+      label         = gtk_label_new (text);
+
+      if (opacity)
+        g_object_set_data (G_OBJECT (button_label), "percentage", GINT_TO_POINTER (opacity));
+
+      g_object_set_data (G_OBJECT (button_label), "digits", GINT_TO_POINTER (digits));
+      
+      if (param_spec)
+        config_notify_label (config, param_spec, button_label);
+
+      gtk_widget_show (button);
+      gtk_widget_show (label);
+      
+      gtk_table_attach (GTK_TABLE (table), label,
+	                      column    , column + 1, row, row + 1,
+	                      GTK_FILL, GTK_FILL, 0, 0);
+	    
+      gtk_table_attach (GTK_TABLE (table), button,
+	                      column + 1, column + 3, row, row + 1,
+	                      GTK_FILL, GTK_FILL, 0, 0);
+
+      signal_detail = g_strconcat ("notify::", property_name, NULL);
+      g_signal_connect_object (config, signal_detail, 
+	                             G_CALLBACK (config_notify_label), button_label, 0);
+	    g_free (signal_detail);
+
+      closure = generate_create_scale_entry_closure (config, property_name,
+                                                     text, step_increment, page_increment,
+                                                     digits, limit_scale, lower_limit, upper_limit,
+                                                     logarithm, opacity, TRUE);
+
+      g_signal_connect_closure (button, "create-view", closure, 0);
+    }
+  else
+    {
+      if (opacity)
+        {
+          GtkObject *adj;
+          adj   = gimp_prop_opacity_entry_new (config, property_name,
+                                               GTK_TABLE (table), column, row,
+                                               text);
+        }
+      else
+        {
+          GtkObject *adj;
+          adj = gimp_prop_scale_entry_new (config, property_name,
+                                           GTK_TABLE (table), 
+                                           column, row,
+                                           text,
+                                           step_increment, 
+                                           page_increment,
+                                           digits,
+                                           limit_scale, 
+                                           lower_limit, 
+                                           upper_limit);
+          if (logarithm)
+            gimp_scale_entry_set_logarithmic (GTK_OBJECT (adj), TRUE);    
+        }
+    }
+}
+
+void
+gimp_tool_options_scale_entry_new (GObject      *config,
+                                   const gchar *property_name,
+                                   GtkTable     *table,
+                                   gint          column,
+                                   gint          row,
+                                   const gchar *text,
+                                   gdouble       step_increment,
+                                   gdouble       page_increment,
+                                   gint          digits,
+                                   gboolean      limit_scale,
+                                   gdouble       lower_limit,
+                                   gdouble       upper_limit,
+                                   gboolean      logarithm,
+                                   gboolean      horizontal)
+{
+  gimp_tool_options_scale_entry_new_internal (config,
+                                              property_name,
+                                              table, column, row,
+                                              text,
+                                              step_increment, page_increment,
+                                              digits, 
+                                              limit_scale, lower_limit, upper_limit,
+                                              logarithm, FALSE, horizontal);                                              
+}
+
+void
+gimp_tool_options_opacity_entry_new (GObject     *config,
+                   const gchar *property_name,
+                   GtkTable    *table,
+                   gint         column,
+                   gint         row,
+                   const gchar       *text,
+                   gboolean     horizontal)
+{
+  gimp_tool_options_scale_entry_new_internal (config,
+                                              property_name,
+                                              table, column, row,
+                                              text,
+                                              0, 1,
+                                              1, 
+                                              TRUE, 0, 100,
+                                              FALSE, TRUE, horizontal);
+}
+
diff -Naur gimp-2.8.14/app/tools/gimptooloptions-gui-cxx.cpp gimp-2.8.14-new/app/tools/gimptooloptions-gui-cxx.cpp
--- gimp-2.8.14/app/tools/gimptooloptions-gui-cxx.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimptooloptions-gui-cxx.cpp	2015-01-27 17:48:55.398751578 +0800
@@ -0,0 +1,50 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <glib-object.h>
+#include <glib/gprintf.h>
+#include <gtk/gtk.h>
+
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "tools-types.h"
+
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "core/gimptooloptions.h"
+
+#include "widgets/gimppropwidgets.h"
+#include "widgets/gimppopupbutton.h"
+#include "widgets/gimpspinscale.h"
+
+#include "base/glib-cxx-utils.hpp"
+#include "gimptooloptions-gui-cxx.hpp"
+
+GtkWidget * 
+gimp_tool_options_button_with_popup (GtkWidget*                label_widget,
+                                     PopupCreateViewDelegator* create_view)
+{
+  GtkWidget *result = NULL;
+
+  gtk_widget_show (label_widget);
+  result = gimp_popup_button_new (label_widget);
+  g_signal_connect_delegator (G_OBJECT(result), "create-view", create_view);
+
+  return result;
+}
diff -Naur gimp-2.8.14/app/tools/gimptooloptions-gui-cxx.hpp gimp-2.8.14-new/app/tools/gimptooloptions-gui-cxx.hpp
--- gimp-2.8.14/app/tools/gimptooloptions-gui-cxx.hpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/tools/gimptooloptions-gui-cxx.hpp	2015-01-27 17:48:55.398751578 +0800
@@ -0,0 +1,107 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_TOOL_OPTIONS_GUI_CXX_HPP__
+#define __GIMP_TOOL_OPTIONS_GUI_CXX_HPP__
+
+#include "base/delegators.hpp"
+
+typedef Delegator::Delegator<void (*)(GObject*,GtkWidget**)> PopupCreateViewDelegator;
+
+GtkWidget * gimp_tool_options_button_with_popup (GtkWidget                *label_widget,
+                                                 PopupCreateViewDelegator* create_view);
+
+template<typename CXXType>
+GtkWidget * gimp_tool_options_button_with_popup (GtkWidget                *label_widget,
+                                                 PopupCreateViewDelegator* create_view,
+                                                 CXXType*                  object) {
+  GtkWidget* result = gimp_tool_options_button_with_popup (label_widget, create_view);
+  g_object_set_cxx_object( G_OBJECT(result), "behaviour", object);
+  return result;
+}                                                
+
+class ComplexBindAction {
+protected:
+  GObject* receiver;
+
+  template<typename Delegator>
+  void bind_to_full(GObject* target, const gchar* signal_name, Delegator* delegator) {
+    StringHolder object_id(g_strdup_printf("behavior-%s-action", signal_name));
+    g_signal_connect_delegator (G_OBJECT(target), signal_name, delegator);
+    g_object_set_cxx_object(G_OBJECT(target), object_id, this);
+  };
+
+public:
+  ComplexBindAction(GObject* receiver_) : receiver(receiver_) {
+  };
+  virtual ~ComplexBindAction() {}
+  
+};
+
+class SimpleBindAction : public ComplexBindAction {
+protected:
+  virtual void emit(GObject* event_target) {};
+
+  void bind_to(GObject* target, const gchar* signal_name) {
+    bind_to_full(target, signal_name, Delegator::delegator(this, &SimpleBindAction::emit));
+  };
+
+public:
+  SimpleBindAction(GObject* target_, GObject* receiver_, const gchar* signal_name) : ComplexBindAction(receiver_) {
+    bind_to(target_, signal_name);
+  };
+  ~SimpleBindAction() {}
+  
+};
+
+class ToggleWidgetAction : public SimpleBindAction {
+public:
+  ToggleWidgetAction(GObject* target, GObject* receiver) : SimpleBindAction(target, receiver, "clicked") {};
+  ~ToggleWidgetAction() {}
+
+  void emit(GObject* event_target) {
+    gboolean visible = gtk_widget_get_visible(GTK_WIDGET(receiver));
+    gtk_widget_set_visible(GTK_WIDGET(receiver), !visible);
+  };
+};
+
+class PageRemindAction : public ComplexBindAction {
+protected:
+  guint last_page;
+  
+  void emit (GObject *object, GtkWidget* page, guint page_num) {
+    last_page = page_num;
+    g_print("PageRemindAction::switch page=%d\n", page_num);
+  }
+public:
+  PageRemindAction(GObject* receiver) : 
+    ComplexBindAction(receiver), last_page(0)
+  {
+  }
+
+  void bind_to(GtkNotebook* notebook) 
+  {
+    g_return_if_fail (GTK_IS_NOTEBOOK(notebook));
+    g_return_if_fail (gtk_notebook_get_n_pages(notebook) >= last_page);
+    gtk_notebook_set_current_page(notebook, last_page);
+    g_signal_connect_delegator(G_OBJECT(notebook), "switch-page", Delegator::delegator(this, &PageRemindAction::emit));
+    g_print("PageRemindAction::set page=%d\n", last_page);
+  };
+};
+
+
+#endif  /*  __GIMP_TOOL_OPTIONS_GUI_CXX_HPP__  */
diff -Naur gimp-2.8.14/app/tools/gimptooloptions-gui.h gimp-2.8.14-new/app/tools/gimptooloptions-gui.h
--- gimp-2.8.14/app/tools/gimptooloptions-gui.h	2015-01-27 17:28:36.891833809 +0800
+++ gimp-2.8.14-new/app/tools/gimptooloptions-gui.h	2015-01-27 17:48:55.399751578 +0800
@@ -18,8 +18,73 @@
 #ifndef __GIMP_TOOL_OPTIONS_GUI_H__
 #define __GIMP_TOOL_OPTIONS_GUI_H__
 
+typedef struct _GimpToolOptionsTableIncrement GimpToolOptionsTableIncrement;
+typedef void (*GimpPopupCreateViewCallback) (GtkWidget *button, GtkWidget** result, GObject *config);
+typedef void (*GimpPopupCreateViewCallbackExt) (GtkWidget *button, GtkWidget** result, GObject *config, gpointer data);
 
-GtkWidget * gimp_tool_options_gui (GimpToolOptions *tool_options);
+struct _GimpToolOptionsTableIncrement
+{
+  gint table_col;
+  gint table_row;
+  gboolean horizontal;
+};
 
+GtkWidget * gimp_tool_options_gui        (GimpToolOptions *tool_options);
+GtkWidget * gimp_tool_options_gui_full   (GimpToolOptions *tool_options, gboolean horizontal);
+GtkWidget * gimp_tool_options_table (gint num_items, gboolean horizontal);
+GimpToolOptionsTableIncrement gimp_tool_options_table_increment (gboolean horizontal);
+gint gimp_tool_options_table_increment_get_col (GimpToolOptionsTableIncrement* inc);
+gint gimp_tool_options_table_increment_get_row (GimpToolOptionsTableIncrement* inc);
+void gimp_tool_options_table_increment_next (GimpToolOptionsTableIncrement* inc);
+
+void gimp_tool_options_setup_popup_layout (GList *children, gboolean hide_label);
+GtkWidget * gimp_tool_options_frame_gui_with_popup (GObject                    *config,
+                                                    GType                       tool_type, 
+                                                    gchar                      *label,
+                                                    gboolean                    horizontal,
+                                                    GimpPopupCreateViewCallback create_view);
+GtkWidget * gimp_tool_options_expander_gui_with_popup (GObject                    *config,
+                                                       GType                       tool_type, 
+                                                       gchar                      *prop_name,
+                                                       gchar                      *short_label,
+                                                       gchar                      *long_label,
+                                                       gboolean                    horizontal,
+                                                       GimpPopupCreateViewCallback create_view);
+GtkWidget * gimp_tool_options_toggle_gui_with_popup (GObject                    *config,
+                                                     GType                       tool_type, 
+                                                     gchar                      *property_name,
+                                                     gchar                      *short_label,
+                                                     gchar                      *long_label,
+                                                     gboolean                    horizontal,
+                                                     GimpPopupCreateViewCallback create_view);
+
+GtkWidget * gimp_tool_options_button_with_popup (GObject                    *config,
+                                                 GtkWidget                  *label_widget,
+                                                 GimpPopupCreateViewCallbackExt create_view,
+                                                 gpointer                    data,
+                                                 void (*destroy_data) (gpointer data));
+
+void gimp_tool_options_scale_entry_new  (GObject      *config,
+                                          const gchar  *property_name,
+                                          GtkTable     *table,
+                                          gint          column,
+                                          gint          row,
+                                          const gchar  *label,
+                                          gdouble       step_increment,
+                                          gdouble       page_increment,
+                                          gint          digits,
+                                          gboolean      limit_scale,
+                                          gdouble       lower_limit,
+                                          gdouble       upper_limit,
+                                          gboolean      logarithm,
+                                          gboolean      horizontal);
+
+void gimp_tool_options_opacity_entry_new  (GObject      *config,
+                                           const gchar   *property_name,
+                                           GtkTable      *table,
+                                           gint           column,
+                                           gint           row,
+                                           const gchar   *label,
+                                           gboolean      horizontal);
 
 #endif  /*  __GIMP_TOOL_OPTIONS_GUI_H__  */
diff -Naur gimp-2.8.14/app/tools/gimp-tools.c gimp-2.8.14-new/app/tools/gimp-tools.c
--- gimp-2.8.14/app/tools/gimp-tools.c	2015-01-27 17:28:36.896833809 +0800
+++ gimp-2.8.14-new/app/tools/gimp-tools.c	2015-01-27 17:48:55.364751580 +0800
@@ -82,6 +82,8 @@
 #include "gimpsmudgetool.h"
 #include "gimptexttool.h"
 #include "gimpvectortool.h"
+#include "core/gimptoolpreset-load.h" /* gimp-painter-2.7 */
+#include "gimpmypainttool.h" /* gimp-painter-2.7 */
 
 #include "gimp-intl.h"
 
@@ -91,6 +93,7 @@
 static void   gimp_tools_register (GType                   tool_type,
                                    GType                   tool_options_type,
                                    GimpToolOptionsGUIFunc  options_gui_func,
+                                   GimpToolOptionsGUIFunc  options_gui_horizontal_func,
                                    GimpContextPropMask     context_props,
                                    const gchar            *identifier,
                                    const gchar            *blurb,
@@ -145,6 +148,7 @@
     gimp_blend_tool_register,
     gimp_bucket_fill_tool_register,
     gimp_text_tool_register,
+    gimp_mypaint_tool_register,
 
     /*  transform tools  */
 
@@ -234,10 +238,18 @@
     {
       GimpToolInfo *tool_info = list->data;
       GtkWidget    *options_gui;
+      GtkWidget    *toolbar_gui;
 
       options_gui = gimp_tools_get_tool_options_gui (tool_info->tool_options);
+      toolbar_gui = g_object_get_data (G_OBJECT (tool_info->tool_options),
+                                       "gimp-tool-options-toolbar-gui");
+
       gtk_widget_destroy (options_gui);
+      gtk_widget_destroy (toolbar_gui);
+
       gimp_tools_set_tool_options_gui (tool_info->tool_options, NULL);
+      g_object_set_data (G_OBJECT (tool_info->tool_options),
+                         "gimp-tool-options-toolbar-gui", NULL);
     }
 
   tool_manager_exit (gimp);
@@ -317,7 +329,9 @@
     {
       GimpToolInfo           *tool_info = GIMP_TOOL_INFO (list->data);
       GimpToolOptionsGUIFunc  options_gui_func;
+      GimpToolOptionsGUIFunc  toolbar_gui_func;
       GtkWidget              *options_gui;
+      GtkWidget              *toolbar_gui;
 
       /*  copy all context properties except those the tool actually
        *  uses, because the subsequent deserialize() on the tool
@@ -359,6 +373,35 @@
 
       gimp_tools_set_tool_options_gui (tool_info->tool_options,
                                        g_object_ref_sink (options_gui));
+
+      toolbar_gui_func = g_object_get_data (G_OBJECT (tool_info),
+                                            "gimp-tool-options-gui-horizontal-func");
+      if (toolbar_gui_func)
+        {
+          toolbar_gui = (* toolbar_gui_func) (tool_info->tool_options);
+        }
+      else
+        {
+          GtkWidget *label;
+
+          toolbar_gui = gimp_tool_options_gui_full (tool_info->tool_options, TRUE);
+
+          label = gtk_label_new (_("This tool has\nno options."));
+          gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_CENTER);
+          gimp_label_set_attributes (GTK_LABEL (label),
+                                     PANGO_ATTR_STYLE, PANGO_STYLE_ITALIC,
+                                     -1);
+          gtk_box_pack_start (GTK_BOX (toolbar_gui), label, FALSE, FALSE, 6);
+          gtk_widget_show (label);
+        }
+
+      g_object_set_data_full (G_OBJECT (tool_info->tool_options),
+                              "gimp-tool-options-toolbar-gui",
+                              g_object_ref_sink (toolbar_gui),
+                              (GDestroyNotify) g_object_unref);
+
+//      if (tool_info->presets)
+//        gimp_tool_preset_load (tool_info->presets, NULL);
     }
 }
 
@@ -451,6 +494,7 @@
 gimp_tools_register (GType                   tool_type,
                      GType                   tool_options_type,
                      GimpToolOptionsGUIFunc  options_gui_func,
+                     GimpToolOptionsGUIFunc  options_gui_horizontal_func,
                      GimpContextPropMask     context_props,
                      const gchar            *identifier,
                      const gchar            *blurb,
@@ -547,6 +591,9 @@
   g_object_set_data (G_OBJECT (tool_info), "gimp-tool-options-gui-func",
                      options_gui_func);
 
+  g_object_set_data (G_OBJECT (tool_info), "gimp-tool-options-gui-horizontal-func",
+                     options_gui_horizontal_func);
+
   gimp_container_add (gimp->tool_info_list, GIMP_OBJECT (tool_info));
   g_object_unref (tool_info);
 
diff -Naur gimp-2.8.14/app/tools/gimptransformoptions.c gimp-2.8.14-new/app/tools/gimptransformoptions.c
--- gimp-2.8.14/app/tools/gimptransformoptions.c	2015-01-27 17:28:36.896833809 +0800
+++ gimp-2.8.14-new/app/tools/gimptransformoptions.c	2015-01-27 17:48:55.399751578 +0800
@@ -71,6 +71,12 @@
                                                      GValue          *target_value,
                                                      gpointer         user_data);
 
+static GtkWidget * gimp_transform_options_gui_full (GimpToolOptions *tool_options, 
+                                                     gboolean horizontal);
+
+static void        gimp_transform_options_create_view (GtkWidget *source, 
+                                                        GtkWidget **result, 
+                                                        GObject *config);
 
 G_DEFINE_TYPE (GimpTransformOptions, gimp_transform_options,
                GIMP_TYPE_TOOL_OPTIONS)
@@ -247,6 +253,20 @@
   GIMP_TOOL_OPTIONS_CLASS (parent_class)->reset (tool_options);
 }
 
+GtkWidget *
+gimp_transform_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_transform_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_transform_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_transform_options_gui_full (tool_options, TRUE);
+}
+
+/*  private functions  */
+
 /**
  * gimp_transform_options_gui:
  * @tool_options: a #GimpToolOptions
@@ -255,11 +275,12 @@
  *
  * Return value: a container holding the transform tool options
  **/
-GtkWidget *
-gimp_transform_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_transform_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject     *config = G_OBJECT (tool_options);
-  GtkWidget   *vbox   = gimp_tool_options_gui (tool_options);
+  GtkWidget   *vbox    = gimp_tool_options_gui_full (tool_options, horizontal);
+  GType        tool_type = G_TYPE_NONE;
   GtkWidget   *hbox;
   GtkWidget   *box;
   GtkWidget   *label;
@@ -267,8 +288,10 @@
   GtkWidget   *combo;
   GtkWidget   *scale;
   GtkWidget   *grid_box;
+#if 0
   const gchar *constrain_label = NULL;
   const gchar *constrain_tip   = NULL;
+#endif
 
   hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
   gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
@@ -282,11 +305,46 @@
   gtk_box_pack_start (GTK_BOX (hbox), box, FALSE, FALSE, 0);
   gtk_widget_show (box);
 
-  frame = gimp_prop_enum_radio_frame_new (config, "direction",
-                                          _("Direction"), 0, 0);
+  frame = gimp_prop_enum_radio_frame_new_with_orientation (config, "direction",
+                                                           _("Direction"), 0, 0,
+                                                           horizontal ? GTK_ORIENTATION_HORIZONTAL:
+                                                           GTK_ORIENTATION_VERTICAL);
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
   gtk_widget_show (frame);
 
+  /* Detail Options */
+  frame = gimp_tool_options_frame_gui_with_popup (config, tool_type,
+                                                  _("Transformation details..."),
+                                                  horizontal, gimp_transform_options_create_view);
+  gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 0);
+  gtk_widget_show (frame);
+
+  if (horizontal)
+    {
+      GList *children;
+      children = gtk_container_get_children (GTK_CONTAINER (vbox));  
+      gimp_tool_options_setup_popup_layout (children, FALSE);
+    }  
+  
+  return vbox;
+}
+  
+static void
+gimp_transform_options_create_view (GtkWidget *source, GtkWidget **result, GObject *config)
+{
+  GimpToolOptions      *tool_options = GIMP_TOOL_OPTIONS (config);
+  GimpTransformOptions *options      = GIMP_TRANSFORM_OPTIONS (tool_options);
+  GtkWidget            *vbox         = gimp_tool_options_gui_full (tool_options, FALSE);
+  GtkWidget            *frame;
+  GtkWidget            *hbox;
+  GtkWidget            *combo;
+  GtkWidget            *scale;
+  GtkWidget            *preview_box;
+  GtkWidget            *label;
+  GtkWidget            *grid_box;
+  const gchar          *constrain_label = NULL;
+  const gchar          *constrain_tip   = NULL;
+
   /*  the interpolation menu  */
   frame = gimp_frame_new (_("Interpolation:"));
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
@@ -314,6 +372,31 @@
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
   gtk_widget_show (frame);
 
+  /* gimp-painter-2.7 */
+  /*  the preview type menu  */
+  hbox = gtk_hbox_new (FALSE, 2);
+  gtk_frame_set_label_widget (GTK_FRAME (frame), hbox);
+  gtk_widget_show (hbox);
+
+  label = gtk_label_new (_("Preview:"));
+  gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
+  gtk_widget_show (label);
+
+  combo = gimp_prop_enum_combo_box_new (config, "preview-type", 0, 0);
+  gtk_box_pack_start (GTK_BOX (hbox), combo, TRUE, TRUE, 0);
+  gtk_widget_show (combo);
+
+  preview_box = gtk_vbox_new (FALSE, 2);
+//  preview_box = gimp_tool_options_gui_full (tool_options, horizontal);
+  gtk_container_add (GTK_CONTAINER (frame), preview_box);
+  gtk_widget_show (preview_box);
+
+  /*  the preview opacity scale  */
+  scale = gimp_prop_opacity_spin_scale_new (config, "preview-opacity",
+                                            _("Opacity"));
+  gtk_box_pack_start (GTK_BOX (preview_box), scale, FALSE, FALSE, 0);
+  gtk_widget_show (scale);
+
   /*  the guides frame  */
   frame = gimp_frame_new (_("Guides"));
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
@@ -372,9 +455,16 @@
       g_free (label);
     }
 
-  return vbox;
+  *result = vbox;
 }
 
+#if 0
+/*gimp-painter-2.7 */
+static void
+gimp_transform_options_preview_notify (GimpTransformOptions *options,
+                                       GParamSpec           *pspec,
+                                       GtkWidget            *widget)
+#endif
 gboolean
 gimp_transform_options_show_preview (GimpTransformOptions *options)
 {
diff -Naur gimp-2.8.14/app/tools/gimptransformoptions.h gimp-2.8.14-new/app/tools/gimptransformoptions.h
--- gimp-2.8.14/app/tools/gimptransformoptions.h	2015-01-27 17:28:36.892833809 +0800
+++ gimp-2.8.14-new/app/tools/gimptransformoptions.h	2015-01-27 17:48:55.400751578 +0800
@@ -56,5 +56,7 @@
 
 gboolean    gimp_transform_options_show_preview (GimpTransformOptions *options);
 
+GtkWidget * gimp_transform_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_transform_options_gui_horizontal (GimpToolOptions *tool_options);
 
 #endif /* __GIMP_TRANSFORM_OPTIONS_H__ */
diff -Naur gimp-2.8.14/app/tools/gimpvectoroptions.c gimp-2.8.14-new/app/tools/gimpvectoroptions.c
--- gimp-2.8.14/app/tools/gimpvectoroptions.c	2015-01-27 17:28:36.899833808 +0800
+++ gimp-2.8.14-new/app/tools/gimpvectoroptions.c	2015-01-27 17:48:55.400751578 +0800
@@ -140,19 +140,21 @@
   g_free (str);
 }
 
-GtkWidget *
-gimp_vector_options_gui (GimpToolOptions *tool_options)
+static GtkWidget *
+gimp_vector_options_gui_full (GimpToolOptions *tool_options, gboolean horizontal)
 {
   GObject           *config  = G_OBJECT (tool_options);
   GimpVectorOptions *options = GIMP_VECTOR_OPTIONS (tool_options);
-  GtkWidget         *vbox    = gimp_tool_options_gui (tool_options);
+  GtkWidget         *vbox    = gimp_tool_options_gui_full (tool_options, horizontal);
   GtkWidget         *frame;
   GtkWidget         *button;
   gchar             *str;
 
   /*  tool toggle  */
-  frame = gimp_prop_enum_radio_frame_new (config, "vectors-edit-mode",
-                                          _("Edit Mode"), 0, 0);
+  frame = gimp_prop_enum_radio_frame_new_with_orientation (config, "vectors-edit-mode",
+                                                           _("Edit Mode"), 0, 0,
+                                                           horizontal ? GTK_ORIENTATION_HORIZONTAL : 
+                                                           GTK_ORIENTATION_VERTICAL);
   gtk_box_pack_start (GTK_BOX (vbox), frame, FALSE, FALSE, 0);
   gtk_widget_show (frame);
 
@@ -206,3 +208,16 @@
 
   return vbox;
 }
+
+
+GtkWidget *
+gimp_vector_options_gui (GimpToolOptions *tool_options)
+{
+  return gimp_vector_options_gui_full (tool_options, FALSE);
+}
+
+GtkWidget *
+gimp_vector_options_gui_horizontal (GimpToolOptions *tool_options)
+{
+  return gimp_vector_options_gui_full (tool_options, TRUE);
+}
diff -Naur gimp-2.8.14/app/tools/gimpvectoroptions.h gimp-2.8.14-new/app/tools/gimpvectoroptions.h
--- gimp-2.8.14/app/tools/gimpvectoroptions.h	2015-01-27 17:28:36.896833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpvectoroptions.h	2015-01-27 17:48:55.400751578 +0800
@@ -46,9 +46,10 @@
 };
 
 
-GType       gimp_vector_options_get_type (void) G_GNUC_CONST;
+GType       gimp_vector_options_get_type       (void) G_GNUC_CONST;
 
-GtkWidget * gimp_vector_options_gui      (GimpToolOptions *tool_options);
+GtkWidget * gimp_vector_options_gui            (GimpToolOptions *tool_options);
+GtkWidget * gimp_vector_options_gui_horizontal (GimpToolOptions *tool_options);
 
 
 #endif  /*  __GIMP_VECTOR_OPTIONS_H__  */
diff -Naur gimp-2.8.14/app/tools/gimpvectortool.c gimp-2.8.14-new/app/tools/gimpvectortool.c
--- gimp-2.8.14/app/tools/gimpvectortool.c	2015-01-27 17:28:36.895833809 +0800
+++ gimp-2.8.14-new/app/tools/gimpvectortool.c	2015-01-27 17:48:55.400751578 +0800
@@ -153,6 +153,7 @@
   (* callback) (GIMP_TYPE_VECTOR_TOOL,
                 GIMP_TYPE_VECTOR_OPTIONS,
                 gimp_vector_options_gui,
+                gimp_vector_options_gui_horizontal,
                 GIMP_PAINT_OPTIONS_CONTEXT_MASK |
                 GIMP_CONTEXT_PATTERN_MASK |
                 GIMP_CONTEXT_GRADIENT_MASK, /* for stroking */
diff -Naur gimp-2.8.14/app/tools/Makefile.am gimp-2.8.14-new/app/tools/Makefile.am
--- gimp-2.8.14/app/tools/Makefile.am	2015-01-27 17:28:36.891833809 +0800
+++ gimp-2.8.14-new/app/tools/Makefile.am	2015-01-27 17:48:55.364751580 +0800
@@ -24,6 +24,8 @@
 	\
 	gimpairbrushtool.c		\
 	gimpairbrushtool.h		\
+	gimpbrushoptions-gui.c		\
+	gimpbrushoptions-gui.h		\
 	gimpalignoptions.c		\
 	gimpalignoptions.h		\
 	gimpaligntool.c			\
@@ -74,6 +76,8 @@
 	gimpdodgeburntool.h		\
 	gimpdrawtool.c			\
 	gimpdrawtool.h			\
+	gimpdynamicsoptions-gui.c	\
+	gimpdynamicsoptions-gui.h	\
 	gimpeditselectiontool.c		\
 	gimpeditselectiontool.h		\
 	gimpellipseselecttool.c		\
@@ -195,7 +199,19 @@
 	gimpvectoroptions.c		\
 	gimpvectoroptions.h		\
 	gimpvectortool.c		\
-	gimpvectortool.h
+	gimpvectortool.h   		\
+	gimpmypainttool.cpp		\
+	gimpmypainttool.h		\
+	gimpmypaintoptions-gui.cpp	\
+	gimpmypaintoptions-gui.h  	\
+	gimpmypaintbrushoptions-gui.cpp	\
+	gimpmypaintbrushoptions-gui.h	\
+	gimptooloptions-gui-cxx.cpp	\
+	gimptooloptions-gui-cxx.hpp		\
+	gimpmypaintbrusheditor.cpp		\
+	gimpmypaintbrusheditor.hpp		\
+	gimpmypaint-gui-base.hpp
+
 
 libapptools_a_built_sources = tools-enums.c
 
diff -Naur gimp-2.8.14/app/tools/tools-types.h gimp-2.8.14-new/app/tools/tools-types.h
--- gimp-2.8.14/app/tools/tools-types.h	2015-01-27 17:28:36.904833808 +0800
+++ gimp-2.8.14-new/app/tools/tools-types.h	2015-01-27 17:48:55.401751578 +0800
@@ -38,6 +38,7 @@
 typedef struct _GimpPaintTool                GimpPaintTool;
 typedef struct _GimpTransformTool            GimpTransformTool;
 typedef struct _GimpTransformToolUndo        GimpTransformToolUndo;
+typedef struct _GimpMypaintTool              GimpMypaintTool;
 
 typedef struct _GimpColorOptions             GimpColorOptions;
 typedef struct _GimpImageMapOptions          GimpImageMapOptions;
@@ -50,6 +51,7 @@
 typedef void (* GimpToolRegisterCallback) (GType                     tool_type,
                                            GType                     tool_option_type,
                                            GimpToolOptionsGUIFunc    options_gui_func,
+                                           GimpToolOptionsGUIFunc    options_gui_horizontal_func,
                                            GimpContextPropMask       context_props,
                                            const gchar              *identifier,
                                            const gchar              *blurb,
diff -Naur gimp-2.8.14/app/widgets/gimpcurveview.c gimp-2.8.14-new/app/widgets/gimpcurveview.c
--- gimp-2.8.14/app/widgets/gimpcurveview.c	2015-01-27 17:28:36.922833807 +0800
+++ gimp-2.8.14-new/app/widgets/gimpcurveview.c	2015-01-27 17:48:55.401751578 +0800
@@ -223,7 +223,7 @@
 
   view->x_axis_label = NULL;
   view->y_axis_label = NULL;
-
+  
   gtk_widget_set_can_focus (GTK_WIDGET (view), TRUE);
   gtk_widget_add_events (GTK_WIDGET (view),
                          GDK_BUTTON_PRESS_MASK   |
@@ -775,6 +775,7 @@
   gdouble        y;
   gint           closest_point;
   gint           i;
+  gint           n_points = 0;
 
   if (! curve || bevent->button != 1)
     return TRUE;
@@ -830,7 +831,6 @@
         }
 
       gimp_curve_view_set_selected (view, closest_point);
-
       gimp_curve_set_point (curve, view->selected, x, 1.0 - y);
       break;
 
@@ -1345,6 +1345,28 @@
 }
 
 void
+gimp_curve_view_get_range_x (GimpCurveView *view,
+                             gdouble       *min,
+                             gdouble       *max)
+{
+  g_return_if_fail (GIMP_IS_CURVE_VIEW (view));
+
+  *min = view->range_x_min;
+  *max = view->range_x_max;
+}
+
+void
+gimp_curve_view_get_range_y (GimpCurveView *view,
+                             gdouble       *min,
+                             gdouble       *max)
+{
+  g_return_if_fail (GIMP_IS_CURVE_VIEW (view));
+
+  *min = view->range_y_min;
+  *max = view->range_y_max;
+}
+
+void
 gimp_curve_view_set_xpos (GimpCurveView *view,
                           gdouble        x)
 {
diff -Naur gimp-2.8.14/app/widgets/gimpcurveview.h gimp-2.8.14-new/app/widgets/gimpcurveview.h
--- gimp-2.8.14/app/widgets/gimpcurveview.h	2015-01-27 17:28:36.946833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpcurveview.h	2015-01-27 17:48:55.402751578 +0800
@@ -109,6 +109,12 @@
 void        gimp_curve_view_set_range_y       (GimpCurveView *view,
                                                gdouble        min,
                                                gdouble        max);
+void        gimp_curve_view_get_range_x       (GimpCurveView *view,
+                                               gdouble       *min,
+                                               gdouble       *max);
+void        gimp_curve_view_get_range_y       (GimpCurveView *view,
+                                               gdouble       *min,
+                                               gdouble       *max);
 void        gimp_curve_view_set_xpos          (GimpCurveView *view,
                                                gdouble        x);
 
@@ -117,5 +123,4 @@
 void        gimp_curve_view_set_y_axis_label  (GimpCurveView *view,
                                                const gchar   *label);
 
-
 #endif /* __GIMP_CURVE_VIEW_H__ */
diff -Naur gimp-2.8.14/app/widgets/gimpdatafactoryview.c gimp-2.8.14-new/app/widgets/gimpdatafactoryview.c
--- gimp-2.8.14/app/widgets/gimpdatafactoryview.c	2015-01-27 17:28:36.950833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpdatafactoryview.c	2015-01-27 17:48:55.402751578 +0800
@@ -220,6 +220,7 @@
                                    factory_view->priv->action_group,
                                    str, NULL);
   g_free (str);
+  g_print("%s: edit_button=%lx\n", factory_view->priv->action_group, factory_view->priv->edit_button);
 
   if (gimp_data_factory_view_has_data_new_func (factory_view))
     {
diff -Naur gimp-2.8.14/app/widgets/gimpdeviceinfo-coords.c gimp-2.8.14-new/app/widgets/gimpdeviceinfo-coords.c
--- gimp-2.8.14/app/widgets/gimpdeviceinfo-coords.c	2015-01-27 17:28:36.935833806 +0800
+++ gimp-2.8.14-new/app/widgets/gimpdeviceinfo-coords.c	2015-01-27 17:48:55.402751578 +0800
@@ -78,6 +78,10 @@
                                                         GDK_AXIS_PRESSURE,
                                                         coords->pressure);
         }
+      else
+        {
+          coords->pressure = (event->motion.state & GDK_BUTTON1_MASK)? 1.0: 0.0;
+        }
 
       if (gdk_event_get_axis (event, GDK_AXIS_XTILT, &coords->xtilt))
         {
diff -Naur gimp-2.8.14/app/widgets/gimpdockable.c gimp-2.8.14-new/app/widgets/gimpdockable.c
--- gimp-2.8.14/app/widgets/gimpdockable.c	2015-01-27 17:28:36.927833806 +0800
+++ gimp-2.8.14-new/app/widgets/gimpdockable.c	2015-01-27 17:48:55.403751578 +0800
@@ -497,6 +497,9 @@
                                PANGO_ATTR_WEIGHT, PANGO_WEIGHT_SEMIBOLD,
                                -1);
 
+  if (label && !dnd)
+    gtk_label_set_angle (GTK_LABEL (label), 90);
+
   switch (tab_style)
     {
     case GIMP_TAB_STYLE_ICON:
@@ -513,7 +516,10 @@
     case GIMP_TAB_STYLE_ICON_BLURB:
     case GIMP_TAB_STYLE_PREVIEW_NAME:
     case GIMP_TAB_STYLE_PREVIEW_BLURB:
-      tab_widget = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, dnd ? 6 : 2);
+      if (dnd)
+        tab_widget = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+      else
+        tab_widget = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
 
       gtk_box_pack_start (GTK_BOX (tab_widget), icon, FALSE, FALSE, 0);
       gtk_widget_show (icon);
diff -Naur gimp-2.8.14/app/widgets/gimpdockbook.c gimp-2.8.14-new/app/widgets/gimpdockbook.c
--- gimp-2.8.14/app/widgets/gimpdockbook.c	2015-01-27 17:28:36.951833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpdockbook.c	2015-01-27 17:48:55.404751578 +0800
@@ -99,7 +99,10 @@
    */
   GList          *dockables;
 
+  /* implementation for gimp-painter-2.7 */
   GtkWidget      *menu_button;
+  
+  gboolean        horizontal;
 };
 
 
@@ -264,11 +267,13 @@
                                              GimpDockbookPrivate);
 
   /* Various init */
+  dockbook->p->horizontal = FALSE;
+  
   gtk_notebook_popup_enable (notebook);
   gtk_notebook_set_scrollable (notebook, TRUE);
   gtk_notebook_set_show_border (notebook, FALSE);
   gtk_notebook_set_show_tabs (notebook, TRUE);
-
+  
   gtk_drag_dest_set (GTK_WIDGET (dockbook),
                      0,
                      dialog_target_table, G_N_ELEMENTS (dialog_target_table),
@@ -294,6 +299,14 @@
   g_signal_connect_swapped (dockbook->p->menu_button, "button-press-event",
                             G_CALLBACK (gimp_dockbook_menu_button_press),
                             dockbook);
+
+  gtk_notebook_set_action_widget (notebook,
+                                  dockbook->p->menu_button,
+                                  GTK_PACK_END);
+  gtk_widget_show (dockbook->p->menu_button);
+
+  if (!dockbook->p->horizontal)
+    gtk_notebook_set_tab_pos (notebook, GTK_POS_LEFT);
 }
 
 static void
@@ -671,6 +684,41 @@
 }
 
 /**
+ * gimp_dockbook_get_dockable_tab_height:
+ * @dockable:
+ * @tab_style:
+ *
+ * Returns: Height of tab when the dockable is using the specified tab
+ *          style.
+ **/
+static gint
+gimp_dockbook_get_dockable_tab_height (GimpDockbook *dockbook,
+                                      GimpDockable *dockable,
+                                      GimpTabStyle  tab_style)
+{
+  GtkRequisition  dockable_request;
+  GtkWidget      *tab_widget;
+
+  tab_widget =
+    gimp_dockable_create_event_box_tab_widget (dockable,
+                                               gimp_dock_get_context (dockbook->p->dock),
+                                               tab_style,
+                                               gimp_dockbook_get_tab_icon_size (dockbook));
+
+  /* So font-scale is applied. We can't apply styles without having a
+   * GdkScreen :(
+   */
+  gimp_dock_temp_add (dockbook->p->dock, tab_widget);
+
+  gtk_widget_size_request (tab_widget, &dockable_request);
+
+  /* Also destroys the widget */
+  gimp_dock_temp_remove (dockbook->p->dock, tab_widget);
+
+  return dockable_request.height;
+}
+
+/**
  * gimp_dockbook_tab_style_to_prefered:
  * @tab_style:
  * @dockable:
@@ -741,10 +789,13 @@
 
           style_to_use = gimp_dockbook_tab_style_to_prefered (candidate,
                                                               dockable);
-          size_with_candidate +=
-            gimp_dockbook_get_dockable_tab_width (dockbook,
-                                                  dockable,
-                                                  style_to_use);
+          size_with_candidate += dockbook->p->horizontal ? 
+            gimp_dockbook_get_dockable_tab_width  (dockbook,
+                                                   dockable,
+                                                   style_to_use) :
+            gimp_dockbook_get_dockable_tab_height (dockbook,
+                                                   dockable,
+                                                   style_to_use);
         }
 
       dockbook->p->min_width_for_style[i] =
@@ -777,8 +828,8 @@
   GimpTabStyle  tab_style           = 0;
   int           i                   = 0;
   gint          available_space     = 0;
-  guint         tab_hborder         = 0;
-  gint          xthickness          = 0;
+  guint         tab_border          = 0;
+  gint          thickness           = 0;
   gint          tab_curvature       = 0;
   gint          focus_width         = 0;
   gint          tab_overlap         = 0;
@@ -786,10 +837,21 @@
   gint          border_loss         = 0;
   gint          action_widget_size  = 0;
 
-  xthickness = gtk_widget_get_style (widget)->xthickness;
-  g_object_get (widget,
-                "tab-hborder", &tab_hborder,
-                NULL);
+  if (dockbook->p->horizontal)
+    {
+      thickness = gtk_widget_get_style (widget)->xthickness;
+      g_object_get (widget,
+                    "tab-hborder", &tab_border,
+                    NULL);
+     }
+   else
+     {
+      thickness = gtk_widget_get_style (widget)->ythickness;
+      g_object_get (widget,
+                    "tab-vborder", &tab_border,
+                    NULL);
+     }
+
   gtk_widget_style_get (widget,
                         "tab-curvature",    &tab_curvature,
                         "focus-line-width", &focus_width,
@@ -808,14 +870,19 @@
   border_loss = gtk_container_get_border_width (GTK_CONTAINER (dockbook)) * 2;
 
   /* Space taken by action widget */
-  action_widget_size = button_allocation.width + xthickness;
+  action_widget_size = 
+    (dockbook->p->horizontal ? 
+     button_allocation.width : button_allocation.height) + 
+    thickness;
 
   /* Space taken by the tabs but not the tab widgets themselves */
   tab_padding = gtk_notebook_get_n_pages (GTK_NOTEBOOK (dockbook)) *
-                (2 * (xthickness + tab_curvature + focus_width + tab_hborder) -
+                (2 * (thickness + tab_curvature + focus_width + tab_border) -
                  tab_overlap);
 
-  available_space = dockbook_allocation.width
+  available_space = 
+    (dockbook->p->horizontal ? 
+      dockbook_allocation.width : dockbook_allocation.height)
     - border_loss
     - action_widget_size
     - tab_padding
diff -Naur gimp-2.8.14/app/widgets/gimpdock.c gimp-2.8.14-new/app/widgets/gimpdock.c
--- gimp-2.8.14/app/widgets/gimpdock.c	2015-01-27 17:28:36.939833806 +0800
+++ gimp-2.8.14-new/app/widgets/gimpdock.c	2015-01-27 17:48:55.403751578 +0800
@@ -20,6 +20,8 @@
 
 #include "config.h"
 
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include <gdk-pixbuf/gdk-pixdata.h>
 #include <gtk/gtk.h>
 
 #include "libgimpwidgets/gimpwidgets.h"
@@ -43,6 +45,8 @@
 #include "gimpuimanager.h"
 #include "gimpwidgets-utils.h"
 
+#include "gimptitlebaricon-pixbuf.h"
+
 #include "gimp-intl.h"
 
 
@@ -59,6 +63,14 @@
 };
 
 
+typedef struct _GimpDockTitlebar GimpDockTitlebar;
+struct _GimpDockTitlebar
+{
+  GtkWidget *box;
+  GtkWidget *label;
+  GtkWidget *button;
+};
+
 struct _GimpDockPrivate
 {
   GtkWidget         *temp_vbox;
@@ -68,6 +80,13 @@
   GList             *dockbooks;
 
   gint               ID;
+  gchar             *name;
+  GimpDockTitlebar  titlebar;
+  GimpDockTitlebar  shaded_titlebar;
+  GtkWidget         *content_hbox;
+  
+  gboolean           shaded;
+  gint               orig_w, orig_h;
 };
 
 
@@ -86,6 +105,16 @@
                                                     gint          insert_index,
                                                     gpointer      data);
 
+/* Gimp-painter-2.7: Functions for title bar implementation */
+static void              gimp_dock_titlebar_init          (GimpDockTitlebar *titlebar, 
+                                                            gboolean           shaded, 
+                                                            GObject           *dock);
+#if 0
+static GimpDockColumns * gimp_dock_get_dock_columns       (GimpDock     *dock);
+#endif
+static void              gimp_dock_titlebar_set_shaded (GimpDock *dock, gboolean shaded);
+static void              gimp_dock_titlebar_button_clicked (GtkWidget   *source, GimpDock *data);
+static void              gimp_dock_titlebar_update_description (GimpDockTitlebar* titlebar, GimpDock *dock);
 
 G_DEFINE_TYPE (GimpDock, gimp_dock, GTK_TYPE_BOX)
 
@@ -173,6 +202,7 @@
                                          GIMP_TYPE_DOCK,
                                          GimpDockPrivate);
   dock->p->ID             = dock_ID++;
+  dock->p->shaded         = FALSE;
 
   name = g_strdup_printf ("gimp-internal-dock-%d", dock->p->ID);
   gtk_widget_set_name (GTK_WIDGET (dock), name);
@@ -186,15 +216,108 @@
   gtk_box_pack_start (GTK_BOX (dock), dock->p->main_vbox, TRUE, TRUE, 0);
   gtk_widget_show (dock->p->main_vbox);
 
+  /* Titlebar */
+  gimp_dock_titlebar_init (&dock->p->titlebar, FALSE, G_OBJECT (dock));
+  gtk_box_pack_start (GTK_BOX (dock->p->main_vbox), dock->p->titlebar.box, FALSE, TRUE, 0);
+  gtk_widget_show (dock->p->titlebar.box);
+
+  /* Contents holder */
+  dock->p->content_hbox = gtk_hbox_new (FALSE, 0);
+  gtk_box_pack_start (GTK_BOX (dock->p->main_vbox), dock->p->content_hbox, TRUE, TRUE, 0);
+  gtk_widget_show (dock->p->content_hbox);
+
+  /* Shaded titlebar */
+  gimp_dock_titlebar_init (&dock->p->shaded_titlebar, TRUE, G_OBJECT (dock));
+  gtk_box_pack_start (GTK_BOX (dock->p->content_hbox), dock->p->shaded_titlebar.box, FALSE, TRUE, 0);
+  gtk_widget_hide (dock->p->shaded_titlebar.box);
+
+  dock->p->orig_w = -1;
+  dock->p->orig_h = -1;
+
+  /* Contents */
+
   dock->p->paned_vbox = gimp_paned_box_new (FALSE, 0, GTK_ORIENTATION_VERTICAL);
   gimp_paned_box_set_dropped_cb (GIMP_PANED_BOX (dock->p->paned_vbox),
                                  gimp_dock_dropped_cb,
                                  dock);
-  gtk_box_pack_start (GTK_BOX (dock->p->main_vbox), dock->p->paned_vbox,
-                      TRUE, TRUE, 0);
+
+  gtk_container_add (GTK_CONTAINER (dock->p->content_hbox), dock->p->paned_vbox);
   gtk_widget_show (dock->p->paned_vbox);
 }
 
+static GtkWidget *
+gimp_dock_create_icon_from_data (const GdkPixdata* data)
+{
+  GdkPixbuf *pixbuf = gdk_pixbuf_from_pixdata (data, TRUE, NULL);
+  GtkWidget *image   = gtk_image_new_from_pixbuf (pixbuf);
+  return image;
+}
+
+static void
+gimp_dock_titlebar_init (GimpDockTitlebar *titlebar, gboolean shaded, GObject *dock)
+{
+  GtkWidget *box;
+  GtkWidget *image;
+  GtkWidget *frame;
+  GdkColor   fg_color = { 0, 0xffff, 0xffff, 0xffff};
+  GdkColor   bg_color = { 0, 0x8000, 0x8000, 0x8000};
+  
+  titlebar->box = gtk_event_box_new ();
+  frame         = gtk_frame_new (NULL);
+  gtk_container_add (GTK_CONTAINER(titlebar->box), frame); 
+  gtk_widget_show (frame);
+
+  gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_ETCHED_OUT);
+  
+  if (!shaded)
+    {
+      box           = gtk_hbox_new (FALSE, 3);
+      gtk_container_add (GTK_CONTAINER(frame), box);
+      gtk_widget_show (box);
+
+      titlebar->label    = gtk_label_new (gtk_widget_get_name (GTK_WIDGET (dock)));
+      gtk_box_pack_start (GTK_BOX (box), titlebar->label, TRUE, TRUE, 0);
+      gtk_misc_set_alignment (GTK_MISC (titlebar->label), 0.0, 0.5);
+      gtk_widget_show (titlebar->label);
+      
+      titlebar->button = gtk_button_new ();
+      gtk_button_set_relief (GTK_BUTTON (titlebar->button), GTK_RELIEF_NONE);
+      image = gimp_dock_create_icon_from_data (&gimp_dock_titlebar_minimize);
+      gtk_button_set_image (GTK_BUTTON (titlebar->button), image);
+      gtk_box_pack_end (GTK_BOX (box), titlebar->button, FALSE, FALSE, 0);
+      g_signal_connect_object (G_OBJECT (titlebar->button), "clicked", 
+                               G_CALLBACK(gimp_dock_titlebar_button_clicked), 
+                               G_OBJECT (dock), 0);
+      gtk_widget_show (titlebar->button);
+    }
+  else
+    {
+      box           = gtk_vbox_new (FALSE, 3);
+      gtk_container_add (GTK_CONTAINER(frame), box);
+      gtk_widget_show (box);
+      
+      titlebar->button = gtk_button_new ();
+      gtk_button_set_relief (GTK_BUTTON (titlebar->button), GTK_RELIEF_NONE);
+      image = gimp_dock_create_icon_from_data (&gimp_dock_titlebar_maximize);
+      gtk_button_set_image (GTK_BUTTON (titlebar->button), image);
+      gtk_box_pack_start (GTK_BOX (box), titlebar->button, FALSE, TRUE, 0);
+      g_signal_connect_object (G_OBJECT (titlebar->button), "clicked", 
+                               G_CALLBACK(gimp_dock_titlebar_button_clicked), 
+                               G_OBJECT (dock), 0);
+      gtk_widget_show (titlebar->button);
+
+      titlebar->label    = gtk_label_new (gtk_widget_get_name (GTK_WIDGET (dock)));
+      gtk_box_pack_start (GTK_BOX (box), titlebar->label, TRUE, TRUE, 0);
+      gtk_widget_show (titlebar->label);
+      gtk_misc_set_alignment (GTK_MISC (titlebar->label), 0.5, 0.0);
+      gtk_label_set_angle (GTK_LABEL (titlebar->label), 90);
+    }
+    
+    gtk_widget_modify_bg (titlebar->box, GTK_STATE_NORMAL, &bg_color);
+    gtk_widget_modify_fg (titlebar->label, GTK_STATE_NORMAL, &fg_color);
+  
+}
+
 static void
 gimp_dock_dispose (GObject *object)
 {
@@ -337,6 +460,11 @@
 gimp_dock_invalidate_description (GimpDock *dock)
 {
   g_return_if_fail (GIMP_IS_DOCK (dock));
+  
+  if (dock->p->shaded)
+    gimp_dock_titlebar_update_description (&dock->p->shaded_titlebar, dock);
+  else
+    gimp_dock_titlebar_update_description (&dock->p->titlebar, dock);
 
   g_signal_emit (dock, dock_signals[DESCRIPTION_INVALIDATED], 0);
 }
@@ -769,3 +897,126 @@
 
   gtk_container_remove (GTK_CONTAINER (dock->p->temp_vbox), child);
 }
+
+static void
+gimp_dock_titlebar_set_shaded (GimpDock *dock, gboolean shaded)
+{
+  g_return_if_fail (GIMP_IS_DOCK (dock));
+  gint w, h;
+  GtkWidget *parent_paned = NULL;
+  GtkWidget *paned_child  = NULL;
+  gboolean   resize;
+   
+  if (dock->p->shaded == shaded)
+    return;
+  
+  dock->p->shaded = shaded;
+
+  parent_paned = gtk_widget_get_parent (GTK_WIDGET (dock));
+  paned_child  = GTK_WIDGET (dock);
+  while (parent_paned && !GTK_IS_PANED (parent_paned))
+    {
+      paned_child  = parent_paned;
+      parent_paned = gtk_widget_get_parent (parent_paned);
+    }
+ 
+  if (!dock->p->shaded)
+    {
+      if (parent_paned)
+        {
+          gtk_container_child_get (GTK_CONTAINER (parent_paned),
+                                   paned_child, "resize", &resize, NULL);
+          gtk_container_child_set (GTK_CONTAINER (parent_paned),
+                                   paned_child,
+                                   "resize", FALSE, NULL);
+        }
+      gtk_widget_show (dock->p->paned_vbox);
+      gtk_widget_hide (dock->p->shaded_titlebar.box);
+      gtk_widget_show (dock->p->titlebar.box);
+      gtk_widget_set_size_request (GTK_WIDGET (dock), dock->p->orig_w, dock->p->orig_h);
+      gtk_widget_queue_resize (GTK_WIDGET (dock));
+      gimp_dock_titlebar_update_description (&dock->p->titlebar, dock);
+    }
+  else
+    {
+      if (parent_paned)
+        {
+          gtk_container_child_get (GTK_CONTAINER (parent_paned),
+                                   paned_child, "resize", &resize, NULL);
+          gtk_container_child_set (GTK_CONTAINER (parent_paned),
+                                   paned_child,
+                                   "resize", FALSE, NULL);
+          g_object_set (G_OBJECT (parent_paned), "position-set", FALSE, NULL);
+          
+          paned_child = NULL;
+          while (parent_paned)
+            {
+              if (GTK_IS_PANED (parent_paned))
+                {
+                  if (paned_child)
+                    g_object_set (G_OBJECT (paned_child), "position-set", FALSE, NULL);
+                  paned_child = parent_paned;
+                }
+              parent_paned = gtk_widget_get_parent (parent_paned);
+            }
+/*  
+          if (paned_child)
+            g_object_set (G_OBJECT (paned_child), "position-set", FALSE, NULL);
+*/
+      }
+
+      parent_paned = GTK_WIDGET (dock);
+      while (parent_paned)
+        {
+          if (GIMP_IS_DOCK_WINDOW (parent_paned))
+              gtk_window_resize (GTK_WINDOW (parent_paned), 1, 1);
+
+          parent_paned = gtk_widget_get_parent (parent_paned);
+        }
+      gimp_dock_titlebar_update_description (&dock->p->shaded_titlebar, dock);
+
+      gtk_widget_hide (dock->p->paned_vbox);
+      gtk_widget_show (dock->p->shaded_titlebar.box);
+      gtk_widget_hide (dock->p->titlebar.box);
+      gtk_widget_get_size_request (GTK_WIDGET (dock), &dock->p->orig_w, &dock->p->orig_h);
+      gtk_widget_get_size_request (dock->p->shaded_titlebar.box, &w, &h);
+      gtk_widget_set_size_request (GTK_WIDGET (dock), w, h);
+      gtk_widget_queue_resize (GTK_WIDGET (dock));
+    }
+}
+
+/**
+ * gimp_dock_minimize_button_clicked:
+ */
+static void
+gimp_dock_titlebar_button_clicked (GtkWidget   *source, 
+                                   GimpDock *dock)
+{
+  g_return_if_fail (GIMP_IS_DOCK (dock));
+
+  gimp_dock_titlebar_set_shaded (dock, !dock->p->shaded);
+}
+
+static void
+gimp_dock_titlebar_update_description (GimpDockTitlebar* titlebar, GimpDock *dock)
+{
+  gchar *desc = gimp_dock_get_description (dock, TRUE);
+  gtk_label_set_label (GTK_LABEL (titlebar->label), desc);
+  g_free (desc);
+}
+
+gboolean
+gimp_dock_is_shaded (GimpDock *dock)
+{
+  if (!GIMP_IS_DOCK (dock))
+    return FALSE;
+  return dock->p->shaded;
+}
+
+void
+gimp_dock_set_shaded (GimpDock *dock, gboolean shaded)
+{
+  g_return_if_fail (GIMP_IS_DOCK (dock));
+
+  gimp_dock_titlebar_set_shaded (dock, shaded);
+}
diff -Naur gimp-2.8.14/app/widgets/gimpdock.h gimp-2.8.14-new/app/widgets/gimpdock.h
--- gimp-2.8.14/app/widgets/gimpdock.h	2015-01-27 17:28:36.952833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpdock.h	2015-01-27 17:48:55.403751578 +0800
@@ -115,6 +115,9 @@
                                                        GtkWidget      *widget);
 void                gimp_dock_temp_remove             (GimpDock       *dock,
                                                        GtkWidget      *widget);
+gboolean            gimp_dock_is_shaded               (GimpDock       *dock); /* gimp-painter-2.7 */
+void                gimp_dock_set_shaded              (GimpDock       *dock,
+                                                       gboolean        shaded); /* gimp-painter-2.7 */
 
 
 #endif /* __GIMP_DOCK_H__ */
diff -Naur gimp-2.8.14/app/widgets/gimpdynamicsoutputeditor.c gimp-2.8.14-new/app/widgets/gimpdynamicsoutputeditor.c
--- gimp-2.8.14/app/widgets/gimpdynamicsoutputeditor.c	2015-01-27 17:28:36.944833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpdynamicsoutputeditor.c	2015-01-27 17:48:55.404751578 +0800
@@ -126,6 +126,9 @@
                                                           GimpDynamicsOutputEditor *editor);
 
 
+static void     gimp_dynamics_output_editor_destroy       (GimpDynamicsOutputEditor *editor,
+                                                            gpointer data);
+
 G_DEFINE_TYPE (GimpDynamicsOutputEditor, gimp_dynamics_output_editor,
                GTK_TYPE_BOX)
 
@@ -285,6 +288,12 @@
                     G_CALLBACK (gimp_dynamics_output_editor_input_selected),
                     editor);
 
+#if 0
+   g_signal_connect (editor, "destroy",
+                     G_CALLBACK (gimp_dynamics_output_editor_destroy), NULL);
+
+  return object;
+#endif
   g_signal_connect (private->output, "notify",
                     G_CALLBACK (gimp_dynamics_output_editor_notify_output),
                     editor);
@@ -491,6 +500,21 @@
     }
 }
 
+#if 0
+static void
+gimp_dynamics_output_editor_destroy (GimpDynamicsOutputEditor *editor,
+                                     gpointer data)
+{
+  GimpDynamicsOutputEditorPrivate *private;
+  
+  private = GIMP_DYNAMICS_OUTPUT_EDITOR_GET_PRIVATE (G_OBJECT (editor));
+
+   g_signal_handlers_disconnect_by_func (private->output,
+                                         gimp_dynamics_output_editor_notify_output,
+                                         editor);
+}
+#endif
+
 
 /*  public functions  */
 
diff -Naur gimp-2.8.14/app/widgets/gimpfgbgeditor.c gimp-2.8.14-new/app/widgets/gimpfgbgeditor.c
--- gimp-2.8.14/app/widgets/gimpfgbgeditor.c	2015-01-27 17:28:36.954833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpfgbgeditor.c	2015-01-27 17:48:55.405751577 +0800
@@ -31,10 +31,14 @@
 
 #include "core/gimpcontext.h"
 #include "core/gimpmarshal.h"
+#include "core/gimppalette.h"
 
 #include "gimpdnd.h"
+#include "gimpview.h"
+#include "gimppaletteview.h"
+#include "gimppopupbutton.h"
 #include "gimpfgbgeditor.h"
-
+#include "gimpviewrendererpalette.h"
 
 enum
 {
@@ -53,11 +57,16 @@
 {
   INVALID_AREA,
   FOREGROUND_AREA,
+  FOREGROUND_POPUP_AREA,
   BACKGROUND_AREA,
+  BACKGROUND_POPUP_AREA,
   SWAP_AREA,
   DEFAULT_AREA
 } FgBgTarget;
 
+#define GIMP_COLOR_CELL_SIZE  16
+#define GIMP_COLOR_CELL_COLS  10
+#define GIMP_COLOR_ARROW_SIZE 12
 
 static void     gimp_fg_bg_editor_dispose         (GObject        *object);
 static void     gimp_fg_bg_editor_set_property    (GObject        *object,
@@ -90,6 +99,8 @@
                                                    const GimpRGB  *color,
                                                    gpointer        data);
 
+static void     gimp_fg_bg_editor_popup_palette (GtkWidget        *widget,
+                                                   FgBgTarget       target);             
 
 G_DEFINE_TYPE (GimpFgBgEditor, gimp_fg_bg_editor, GTK_TYPE_DRAWING_AREA)
 
@@ -314,6 +325,12 @@
       cairo_fill (cr);
     }
 
+  gtk_paint_arrow (style, window,
+                   GTK_STATE_NORMAL,
+                   GTK_SHADOW_NONE, NULL, widget, NULL,
+                   GTK_ARROW_DOWN, TRUE,
+                   width - rect_w, (height - 8), 8, 8);
+
   gtk_paint_shadow (style, window, GTK_STATE_NORMAL,
                     editor->active_color == GIMP_ACTIVE_COLOR_FOREGROUND ?
                     GTK_SHADOW_OUT : GTK_SHADOW_IN,
@@ -336,6 +353,13 @@
       cairo_fill (cr);
     }
 
+  gtk_paint_arrow (style, window,
+                   GTK_STATE_NORMAL,
+                   GTK_SHADOW_NONE, NULL, widget, NULL,
+                   GTK_ARROW_DOWN, TRUE,
+                   0, (rect_h - GIMP_COLOR_ARROW_SIZE), 
+                   GIMP_COLOR_ARROW_SIZE, GIMP_COLOR_ARROW_SIZE);
+
   gtk_paint_shadow (style, window, GTK_STATE_NORMAL,
                     editor->active_color == GIMP_ACTIVE_COLOR_BACKGROUND ?
                     GTK_SHADOW_OUT : GTK_SHADOW_IN,
@@ -364,8 +388,13 @@
   width  = allocation.width;
   height = allocation.height;
 
-  if (x > 0 && x < rect_w && y > 0 && y < rect_h)
+  if (x > 0 && x < GIMP_COLOR_ARROW_SIZE && y > rect_h - GIMP_COLOR_ARROW_SIZE && y < rect_h)
+    return FOREGROUND_POPUP_AREA;
+  else if (x > 0 && x < rect_w && y > 0 && y < rect_h)
     return FOREGROUND_AREA;
+  else if (x > (width - rect_w)  && x < width - rect_w + GIMP_COLOR_ARROW_SIZE  &&
+           y > (height - GIMP_COLOR_ARROW_SIZE) && y < height)
+    return BACKGROUND_POPUP_AREA;
   else if (x > (width - rect_w)  && x < width  &&
            y > (height - rect_h) && y < height)
     return BACKGROUND_AREA;
@@ -407,6 +436,11 @@
                                           GIMP_ACTIVE_COLOR_BACKGROUND);
           editor->click_target = BACKGROUND_AREA;
           break;
+          
+        case FOREGROUND_POPUP_AREA:
+        case BACKGROUND_POPUP_AREA:
+          gimp_fg_bg_editor_popup_palette (widget, target);
+          break;
 
         case SWAP_AREA:
           if (editor->context)
@@ -595,3 +629,185 @@
         }
     }
 }
+
+static void
+gimp_fg_bg_palette_changed (GimpContext *context,
+                            GimpPalette *palette,
+                            GtkWidget   *widget)
+{
+  GimpView *view;
+  gint cols;
+  gint rows = 0;
+  
+  g_return_if_fail (palette && GIMP_IS_PALETTE (palette));
+  g_return_if_fail (widget);
+
+  view = GIMP_VIEW (widget);
+  
+  cols = MIN (MAX(GIMP_COLOR_CELL_COLS, palette->n_columns), palette->n_colors);
+  if (cols)
+    rows = MAX (1, (palette->n_colors + cols - 1) / cols);
+  gtk_widget_set_size_request (widget, GIMP_COLOR_CELL_SIZE * cols + 1, GIMP_COLOR_CELL_SIZE * rows + 1);
+  gimp_view_set_viewable (view, GIMP_VIEWABLE (palette));
+}
+
+static void
+gimp_fg_entry_clicked (GimpPaletteView   *view,
+                       GimpPaletteEntry  *entry,
+                       GdkModifierType    state,
+                       gpointer           data)
+{
+  GimpFgBgEditor *editor  = GIMP_FG_BG_EDITOR (data);
+  gimp_context_set_foreground (editor->context, &entry->color);
+}
+
+static void
+gimp_bg_entry_clicked (GimpPaletteView   *view,
+                       GimpPaletteEntry  *entry,
+                       GdkModifierType    state,
+                       gpointer           data)
+{
+  GimpFgBgEditor *editor  = GIMP_FG_BG_EDITOR (data);
+  gimp_context_set_background (editor->context, &entry->color);
+}
+
+static void
+gimp_fg_bg_editor_entry_activated (GtkWidget *widget, 
+                                   GimpPaletteEntry *entry, 
+                                   gpointer data)
+{
+  GimpFgBgEditor *editor = GIMP_FG_BG_EDITOR (data);
+  gimp_popup_close (GIMP_POPUP (editor->popup));
+  editor->popup = NULL;
+}
+
+static void
+gimp_fg_color_add_clicked (GtkWidget *widget, gpointer data)
+{
+  GimpFgBgEditor   *editor = GIMP_FG_BG_EDITOR (data);
+  GimpPalette      *palette = gimp_context_get_palette (editor->context);
+  GimpRGB           color;
+  gint              pos   = palette->n_colors;
+  GimpPaletteEntry *entry;
+
+  gimp_context_get_foreground (editor->context, &color);  
+  entry = gimp_palette_add_entry (palette, pos, NULL, &color);
+
+//  gimp_palette_view_select_entry (GIMP_PALETTE_VIEW (editor->view), entry);
+}
+
+static void     
+gimp_fg_bg_editor_popup_palette (GtkWidget        *widget,
+                                 FgBgTarget        target)
+{
+  GimpFgBgEditor *editor = GIMP_FG_BG_EDITOR (widget);
+  
+  GtkWidget     *vbox;
+  GtkWidget     *view = NULL;
+  GtkWidget     *button;
+  gint           orig_x;
+  gint           orig_y;
+  gint           x;
+  gint           y;
+  GdkScreen     *screen;
+
+  GtkRequisition requisition;
+  GtkAllocation  allocation;
+  gint          width;
+  gint          height;
+  gint          rect_w = editor->rect_width;
+  gint          rect_h = editor->rect_height;
+  
+  g_return_if_fail (GIMP_IS_FG_BG_EDITOR (editor));
+  g_return_if_fail (GIMP_IS_CONTEXT (editor->context));
+
+  gtk_widget_get_allocation (widget, &allocation);
+
+  width  = allocation.width;
+  height = allocation.height;
+  
+  vbox   = gtk_vbox_new (FALSE, 2);
+  gtk_widget_show (vbox);
+  
+  button = gimp_button_new ();
+  gtk_button_set_label (GTK_BUTTON (button), "Add Color to the Palette.");
+  gtk_box_pack_start (GTK_BOX (vbox), button, TRUE, TRUE, 0);
+  gtk_widget_show (button);
+  
+  switch (target)
+    {
+    case FOREGROUND_POPUP_AREA:
+      view = gimp_view_new_full_by_types (editor->context,
+                                          GIMP_TYPE_PALETTE_VIEW,
+                                          GIMP_TYPE_PALETTE,
+                                          GIMP_COLOR_CELL_SIZE * GIMP_COLOR_CELL_COLS,
+                                          100, 0,
+                                          TRUE, TRUE, TRUE);
+      g_signal_connect (view, "entry-clicked",
+                        G_CALLBACK (gimp_fg_entry_clicked),
+                        editor);
+      g_signal_connect (button, "clicked", G_CALLBACK (gimp_fg_color_add_clicked), editor);
+      x    = 0;
+      y    = 0;
+      break;
+
+    case BACKGROUND_POPUP_AREA:
+      view = gimp_view_new_full_by_types (editor->context,
+                                          GIMP_TYPE_PALETTE_VIEW,
+                                          GIMP_TYPE_PALETTE,
+                                          GIMP_COLOR_CELL_SIZE * GIMP_COLOR_CELL_COLS,
+                                          100, 0,
+                                          TRUE, TRUE, TRUE);
+      g_signal_connect (view, "entry-clicked",
+                        G_CALLBACK (gimp_bg_entry_clicked),
+                        editor);
+      x    = width - rect_w;
+      y    = height - rect_h;
+      break;
+
+    default:
+      break;
+    }
+
+  g_return_if_fail (view);
+    
+  gimp_view_set_expand (GIMP_VIEW (view), TRUE);
+  gimp_view_renderer_palette_set_cell_size
+    (GIMP_VIEW_RENDERER_PALETTE (GIMP_VIEW (view)->renderer),
+    GIMP_COLOR_CELL_SIZE);
+  gimp_view_renderer_palette_set_draw_grid
+    (GIMP_VIEW_RENDERER_PALETTE (GIMP_VIEW (view)->renderer),
+     TRUE);
+  g_signal_connect (view, "entry-confirmed",
+                    G_CALLBACK (gimp_fg_bg_editor_entry_activated),
+                    editor);
+  gtk_box_pack_start (GTK_BOX (vbox), view, TRUE, TRUE, 0);
+  gtk_widget_show (view);
+
+  gimp_fg_bg_palette_changed (editor->context,
+                              gimp_context_get_palette (editor->context),
+                              view);
+  editor->popup = gimp_popup_new (vbox);
+
+  gtk_widget_size_request (editor->popup, &requisition);
+  gdk_window_get_origin (gtk_widget_get_window (widget), &orig_x, &orig_y);
+
+  if (! gtk_widget_get_has_window (widget))
+    {
+      orig_x += allocation.x + x;
+      orig_y += allocation.y + y;
+    }
+  else
+    {
+      orig_x += x;
+      orig_y += y;
+    }
+
+  screen = gtk_widget_get_screen (widget);
+
+  gimp_popup_show (GIMP_POPUP (editor->popup), screen, orig_x, orig_y, 
+                   orig_x + rect_w, orig_y + rect_h, 
+                   GTK_CORNER_BOTTOM_LEFT);
+}
+
+
diff -Naur gimp-2.8.14/app/widgets/gimpfgbgeditor.h gimp-2.8.14-new/app/widgets/gimpfgbgeditor.h
--- gimp-2.8.14/app/widgets/gimpfgbgeditor.h	2015-01-27 17:28:36.948833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpfgbgeditor.h	2015-01-27 17:48:55.405751577 +0800
@@ -41,6 +41,8 @@
 
   GdkPixbuf       *default_icon;
   GdkPixbuf       *swap_icon;
+  
+  GtkWidget       *popup;
 
   gint             rect_width;
   gint             rect_height;
diff -Naur gimp-2.8.14/app/widgets/gimphelp-ids.h gimp-2.8.14-new/app/widgets/gimphelp-ids.h
--- gimp-2.8.14/app/widgets/gimphelp-ids.h	2015-01-27 17:28:36.945833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimphelp-ids.h	2015-01-27 17:48:55.405751577 +0800
@@ -282,6 +282,7 @@
 #define GIMP_HELP_TOOL_THRESHOLD                  "gimp-tool-threshold"
 #define GIMP_HELP_TOOL_VECTORS                    "gimp-tool-vectors"
 #define GIMP_HELP_TOOL_ZOOM                       "gimp-tool-zoom"
+#define GIMP_HELP_TOOL_MYPAINT                    "gimp-tool-mypaint"
 
 #define GIMP_HELP_FILTER_REPEAT                   "gimp-filter-repeat"
 #define GIMP_HELP_FILTER_RESHOW                   "gimp-filter-reshow"
@@ -381,6 +382,18 @@
 #define GIMP_HELP_FONT_DIALOG                     "gimp-font-dialog"
 #define GIMP_HELP_FONT_REFRESH                    "gimp-font-refresh"
 
+#define GIMP_HELP_MYPAINT_BRUSH_DIALOG                    "gimp-mypaint-brush-dialog"
+#define GIMP_HELP_MYPAINT_BRUSH_EDIT                      "gimp-mypaint-brush-edit"
+#define GIMP_HELP_MYPAINT_BRUSH_OPEN_AS_IMAGE             "gimp-mypaint-brush-open-as-image"
+#define GIMP_HELP_MYPAINT_BRUSH_NEW                       "gimp-mypaint-brush-new"
+#define GIMP_HELP_MYPAINT_BRUSH_DUPLICATE                 "gimp-mypaint-brush-duplicate"
+#define GIMP_HELP_MYPAINT_BRUSH_COPY_LOCATION             "gimp-mypaint-brush-copy-location"
+#define GIMP_HELP_MYPAINT_BRUSH_DELETE                    "gimp-mypaint-brush-delete"
+#define GIMP_HELP_MYPAINT_BRUSH_REFRESH                   "gimp-mypaint-brush-refresh"
+
+#define GIMP_HELP_MYPAINT_BRUSH_EDITOR_DIALOG             "gimp-mypaint-brush-editor-dialog"
+#define GIMP_HELP_MYPAINT_BRUSH_EDITOR_EDIT_ACTIVE        "gimp-mypaint-brush-editor-edit-active"
+
 #define GIMP_HELP_BUFFER_DIALOG                   "gimp-buffer-dialog"
 #define GIMP_HELP_BUFFER_CUT                      "gimp-buffer-cut"
 #define GIMP_HELP_BUFFER_COPY                     "gimp-buffer-copy"
diff -Naur gimp-2.8.14/app/widgets/gimpmypaintbrusheditor.cpp gimp-2.8.14-new/app/widgets/gimpmypaintbrusheditor.cpp
--- gimp-2.8.14/app/widgets/gimpmypaintbrusheditor.cpp	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimpmypaintbrusheditor.cpp	2015-01-27 17:48:55.406751577 +0800
@@ -0,0 +1,453 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimpmypaint_brusheditor.c
+ * Copyright 1998 Jay Cox <jaycox@earthlink.net>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+extern "C" {
+#include "config.h"
+
+#include <string.h>
+
+#include <gtk/gtk.h>
+
+#include "libgimpmath/gimpmath.h"
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "widgets-types.h"
+
+#include "core/gimp.h"
+#include "core/gimpcontext.h"
+#include "core/mypaintbrush-brushsettings.h"
+#include "core/gimpmypaintbrush.h"
+
+#include "gimpmypaintbrusheditor.h"
+#include "gimpdocked.h"
+#include "gimpspinscale.h"
+#include "gimpview.h"
+#include "gimpviewrenderer.h"
+#include "gimppropwidgets.h"
+#include "gimpspinscale.h"
+#include "gimpwidgets-constructors.h"
+
+#include "gimp-intl.h"
+#include "paint/gimpmypaintoptions.h"
+
+extern "C++" {
+#include "base/scopeguard.hpp"
+#include "base/delegators.hpp"
+}
+
+#define MYPAINT_BRUSH_VIEW_SIZE 32
+
+
+/*  local function prototypes  */
+
+static void   gimp_mypaint_brush_editor_docked_iface_init (GimpDockedInterface *face);
+
+static void   gimp_mypaint_brush_editor_constructed    (GObject            *object);
+
+static void   gimp_mypaint_brush_editor_set_data       (GimpDataEditor     *editor,
+                                                GimpData           *data);
+
+static void   gimp_mypaint_brush_editor_set_context    (GimpDocked         *docked,
+                                                GimpContext        *context);
+
+static void   gimp_mypaint_brush_editor_update_mypaint_brush   (GtkAdjustment      *adjustment,
+                                                GimpMypaintBrushEditor    *editor);
+static void   gimp_mypaint_brush_editor_update_shape   (GtkWidget          *widget,
+                                                GimpMypaintBrushEditor    *editor);
+static void   gimp_mypaint_brush_editor_notify_mypaint_brush   (GimpMypaintBrush *mypaint_brush,
+                                                GParamSpec         *pspec,
+                                                GimpMypaintBrushEditor    *editor);
+
+
+G_DEFINE_TYPE_WITH_CODE (GimpMypaintBrushEditor, gimp_mypaint_brush_editor,
+                         GIMP_TYPE_DATA_EDITOR,
+                         G_IMPLEMENT_INTERFACE (GIMP_TYPE_DOCKED,
+                                                gimp_mypaint_brush_editor_docked_iface_init))
+
+#define parent_class gimp_mypaint_brush_editor_parent_class
+
+static GimpDockedInterface *parent_docked_iface = NULL;
+
+
+static void
+gimp_mypaint_brush_editor_class_init (GimpMypaintBrushEditorClass *klass)
+{
+  GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+  GimpDataEditorClass *editor_class = GIMP_DATA_EDITOR_CLASS (klass);
+
+  object_class->constructed = gimp_mypaint_brush_editor_constructed;
+
+  editor_class->set_data    = gimp_mypaint_brush_editor_set_data;
+  editor_class->title       = _("Mypaint Brush Editor");
+}
+
+static void
+gimp_mypaint_brush_editor_docked_iface_init (GimpDockedInterface *iface)
+{
+  parent_docked_iface = 
+    reinterpret_cast<GimpDockedInterface*>(g_type_interface_peek_parent (iface));
+
+  if (! parent_docked_iface)
+    parent_docked_iface = 
+      reinterpret_cast<GimpDockedInterface*>(g_type_default_interface_peek (GIMP_TYPE_DOCKED));
+
+  iface->set_context = gimp_mypaint_brush_editor_set_context;
+}
+
+static void
+gimp_mypaint_brush_editor_init (GimpMypaintBrushEditor *editor)
+{
+
+}
+
+static void
+gimp_mypaint_brush_editor_constructed (GObject *object)
+{
+  GimpDataEditor *data_editor = GIMP_DATA_EDITOR (object);
+  GimpMypaintBrushEditor* editor = GIMP_MYPAINT_BRUSH_EDITOR (object);
+
+  if (G_OBJECT_CLASS (parent_class)->constructed)
+    G_OBJECT_CLASS (parent_class)->constructed (object);
+
+  GtkWidget      *frame;
+  GtkWidget      *hbox;
+  GtkWidget      *label;
+  GtkWidget      *box;
+  GtkWidget      *scale;
+
+  frame = gtk_frame_new (NULL);
+  gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_IN);
+  gtk_box_pack_start (GTK_BOX (editor), frame, TRUE, TRUE, 0);
+  gtk_widget_show (frame);
+
+  data_editor->view = gimp_view_new_full_by_types (NULL,
+                                                   GIMP_TYPE_VIEW,
+                                                   GIMP_TYPE_MYPAINT_BRUSH,
+                                                   MYPAINT_BRUSH_VIEW_SIZE,
+                                                   MYPAINT_BRUSH_VIEW_SIZE, 0,
+                                                   FALSE, FALSE, TRUE);
+  gtk_widget_set_size_request (data_editor->view, -1, MYPAINT_BRUSH_VIEW_SIZE);
+  gimp_view_set_expand (GIMP_VIEW (data_editor->view), TRUE);
+  gtk_container_add (GTK_CONTAINER (frame), data_editor->view);
+  gtk_widget_show (data_editor->view);
+
+  GList* setting_groups;
+  setting_groups = mypaint_brush_get_setting_group_list();
+  GimpContext* context;
+  g_object_get(object, "context", &context, NULL);
+  
+  GtkWidget* brushsetting_vbox = gtk_vbox_new(FALSE, 0);
+
+  editor->options_box = gtk_notebook_new();
+  gtk_box_pack_start (GTK_BOX (editor), editor->options_box, FALSE, FALSE, 0);
+  gtk_widget_show (editor->options_box);
+
+  gtk_notebook_set_show_tabs(GTK_NOTEBOOK(editor->options_box), FALSE);
+  gtk_notebook_insert_page(GTK_NOTEBOOK(editor->options_box), brushsetting_vbox, label, 0);
+//  gtk_notebook_insert_page(GTK_NOTEBOOK(editor->options_box), brushinputs, label, 1);
+//  gtk_notebook_insert_page(GTK_NOTEBOOK(editor->options_box), brushicon, label, 2);
+    
+
+  for (GList* iter = setting_groups; iter; iter = iter->next) {
+    MypaintBrushSettingGroup* group =
+      (MypaintBrushSettingGroup*)iter->data;
+//    self.visible_settings = self.visible_settings + group['settings']
+
+    ScopeGuard<gchar, void(gpointer)> bold_title(
+      g_strdup_printf("<b>%s</b>", group->display_name), g_free);    
+    GtkWidget* group_expander = gtk_expander_new(bold_title.ptr());
+    gtk_expander_set_use_markup(GTK_EXPANDER(group_expander), TRUE);
+
+    GtkWidget* table = gtk_table_new(3, g_list_length(group->setting_list), FALSE);
+
+    if (strcmp(group->name, "basic") == 0)
+	gtk_expander_set_expanded (GTK_EXPANDER(group_expander), TRUE);
+
+    int count = 0;
+    for (GList* iter2 = group->setting_list; iter2; iter2 = iter2->next, count ++) {
+      MyPaintBrushSettings* s = (MyPaintBrushSettings*)iter2->data;
+//      gtk_misc_set_alignment(GTK_MISC(l), 0, 0.5);
+
+      GtkWidget* h = gimp_prop_spin_scale_new(G_OBJECT(context),s->internal_name,
+                               s->displayed_name,
+                               0.1, 1.0, 2);
+      gtk_widget_set_tooltip_text(h, s->tooltip);
+
+      GtkWidget* button = gimp_stock_button_new (GIMP_STOCK_RESET, NULL);
+      gtk_button_set_relief (GTK_BUTTON (button), GTK_RELIEF_NONE);
+      gtk_image_set_from_stock (GTK_IMAGE (gtk_bin_get_child (GTK_BIN (button))),
+                                GIMP_STOCK_RESET, GTK_ICON_SIZE_MENU);
+      gtk_widget_show (button);
+      gtk_widget_set_tooltip_text(button, _("Reset to default value"));
+      
+      //g_signal_connect_...(button, "clicked,...);
+      GtkWidget* button2;
+      if (s->constant) {
+        button2 = gtk_label_new("");
+	gtk_widget_set_tooltip_text(button2, _("No additional configuration"));
+	gtk_misc_set_alignment(GTK_MISC(button2), 0.5, 0.5);
+      } else {
+        button2 = gtk_button_new_with_label("...");
+	gtk_widget_set_tooltip_text(button2, _("Add input value mapping"));
+        //g_signal_connect...(button2, "clicked", self.details_clicked_cb, adj, s)
+      }
+      gtk_table_attach(GTK_TABLE(table), h, 0, 1, count, count+1, 
+                       GtkAttachOptions(GTK_EXPAND | GTK_FILL), 
+                       GtkAttachOptions(GTK_EXPAND | GTK_FILL), 0, 0);
+      gtk_table_attach(GTK_TABLE(table), button, 1, 2, count, count+1, 
+                       GtkAttachOptions(GTK_EXPAND | GTK_FILL), 
+                       GtkAttachOptions(GTK_EXPAND | GTK_FILL), 0, 0);
+      gtk_table_attach(GTK_TABLE(table), button2, 2, 3, count, count+1, 
+                       GtkAttachOptions(GTK_EXPAND | GTK_FILL), 
+                       GtkAttachOptions(GTK_EXPAND | GTK_FILL), 0, 0);
+
+      gtk_container_add(GTK_CONTAINER(group_expander), table);
+      gtk_box_pack_start(GTK_BOX(brushsetting_vbox) ,group_expander,FALSE,TRUE,0);
+    }
+  }
+
+#if 0
+  /*  mypaint_brush angle scale  */
+  editor->angle_data =
+    GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 180.0, 0.1, 1.0, 0.0));
+  scale = gimp_spin_scale_new (editor->angle_data, _("Angle"), 1);
+  gtk_box_pack_start (GTK_BOX (editor->options_box), scale, FALSE, FALSE, 0);
+  gtk_widget_show (scale);
+
+  gimp_help_set_help_data (scale, _("Percentage of width of mypaint_brush"), NULL);
+
+  g_signal_connect (editor->angle_data, "value-changed",
+                    G_CALLBACK (gimp_mypaint_brush_editor_update_mypaint_brush),
+                    editor);
+#endif
+  
+  gimp_docked_set_show_button_bar (GIMP_DOCKED (object), FALSE);
+}
+
+static void
+gimp_mypaint_brush_editor_set_data (GimpDataEditor *editor,
+                            GimpData       *data)
+{
+  GimpMypaintBrushEditor         *mypaint_brush_editor = GIMP_MYPAINT_BRUSH_EDITOR (editor);
+
+  GimpContext* context;
+  g_object_get(G_OBJECT(editor), "context", &context, NULL);
+
+  GimpMypaintBrush* brush;
+  brush = gimp_mypaint_options_get_current_brush (GIMP_MYPAINT_OPTIONS(context));
+
+  GIMP_DATA_EDITOR_CLASS (parent_class)->set_data (editor, GIMP_DATA(brush));
+
+  gimp_view_set_viewable (GIMP_VIEW (editor->view), GIMP_VIEWABLE (brush));
+
+  gtk_widget_set_sensitive (mypaint_brush_editor->options_box,
+                            editor->data_editable);
+}
+
+static void
+gimp_mypaint_brush_editor_set_context (GimpDocked  *docked,
+                               GimpContext *context)
+{
+  GimpDataEditor *data_editor = GIMP_DATA_EDITOR (docked);
+
+  parent_docked_iface->set_context (docked, context);
+
+  gimp_view_renderer_set_context (GIMP_VIEW (data_editor->view)->renderer,
+                                  context);
+}
+
+
+/*  public functions  */
+
+GtkWidget *
+gimp_mypaint_brush_editor_new (GimpContext     *context,
+                       GimpMenuFactory *menu_factory)
+{
+  g_return_val_if_fail (GIMP_IS_CONTEXT (context), NULL);
+  g_return_val_if_fail (GIMP_IS_MYPAINT_OPTIONS(context), NULL);
+
+  GimpMypaintOptions* options = NULL;
+  GIMP_MYPAINT_OPTIONS(context);
+
+  gpointer result = g_object_new (GIMP_TYPE_MYPAINT_BRUSH_EDITOR,
+                       "menu-factory",    menu_factory,
+                       "menu-identifier", "<MypaintBrushEditor>",
+                       "ui-path",         "/mypaint_brush-editor-popup",
+                       "data-factory",    context->gimp->mypaint_brush_factory,
+                       "context",         context,
+                       "data",            gimp_mypaint_options_get_current_brush (options),
+                       NULL);
+  return GTK_WIDGET(result);
+}
+
+
+/*  private functions  */
+
+static void
+gimp_mypaint_brush_editor_update_mypaint_brush (GtkAdjustment   *adjustment,
+                                GimpMypaintBrushEditor *editor)
+{
+#if 0
+  GimpMypaintBrushGenerated *mypaint_brush;
+  gdouble             radius;
+  gint                spikes;
+  gdouble             hardness;
+  gdouble             ratio;
+  gdouble             angle;
+  gdouble             spacing;
+
+  if (! GIMP_IS_MYPAINT_BRUSH_GENERATED (GIMP_DATA_EDITOR (editor)->data))
+    return;
+
+  mypaint_brush = GIMP_MYPAINT_BRUSH_GENERATED (GIMP_DATA_EDITOR (editor)->data);
+
+  radius   = gtk_adjustment_get_value (editor->radius_data);
+  spikes   = ROUND (gtk_adjustment_get_value (editor->spikes_data));
+  hardness = gtk_adjustment_get_value (editor->hardness_data);
+  ratio    = gtk_adjustment_get_value (editor->aspect_ratio_data);
+  angle    = gtk_adjustment_get_value (editor->angle_data);
+  spacing  = gtk_adjustment_get_value (editor->spacing_data);
+
+  if (radius   != gimp_mypaint_brush_generated_get_radius       (mypaint_brush) ||
+      spikes   != gimp_mypaint_brush_generated_get_spikes       (mypaint_brush) ||
+      hardness != gimp_mypaint_brush_generated_get_hardness     (mypaint_brush) ||
+      ratio    != gimp_mypaint_brush_generated_get_aspect_ratio (mypaint_brush) ||
+      angle    != gimp_mypaint_brush_generated_get_angle        (mypaint_brush) ||
+      spacing  != gimp_mypaint_brush_get_spacing                (GIMP_MYPAINT_BRUSH (mypaint_brush)))
+    {
+      g_signal_handlers_block_by_func (mypaint_brush,
+                                       gimp_mypaint_brush_editor_notify_mypaint_brush,
+                                       editor);
+
+      gimp_data_freeze (GIMP_DATA (mypaint_brush));
+      g_object_freeze_notify (G_OBJECT (mypaint_brush));
+
+      gimp_mypaint_brush_generated_set_radius       (mypaint_brush, radius);
+      gimp_mypaint_brush_generated_set_spikes       (mypaint_brush, spikes);
+      gimp_mypaint_brush_generated_set_hardness     (mypaint_brush, hardness);
+      gimp_mypaint_brush_generated_set_aspect_ratio (mypaint_brush, ratio);
+      gimp_mypaint_brush_generated_set_angle        (mypaint_brush, angle);
+      gimp_mypaint_brush_set_spacing                (GIMP_MYPAINT_BRUSH (mypaint_brush), spacing);
+
+      g_object_thaw_notify (G_OBJECT (mypaint_brush));
+      gimp_data_thaw (GIMP_DATA (mypaint_brush));
+
+      g_signal_handlers_unblock_by_func (mypaint_brush,
+                                         gimp_mypaint_brush_editor_notify_mypaint_brush,
+                                         editor);
+    }
+#endif
+}
+
+static void
+gimp_mypaint_brush_editor_update_shape (GtkWidget       *widget,
+                                GimpMypaintBrushEditor *editor)
+{
+#if 0
+  GimpMypaintBrushGenerated *mypaint_brush;
+
+  if (! GIMP_IS_MYPAINT_BRUSH_GENERATED (GIMP_DATA_EDITOR (editor)->data))
+    return;
+
+  mypaint_brush = GIMP_MYPAINT_BRUSH_GENERATED (GIMP_DATA_EDITOR (editor)->data);
+
+  if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
+    {
+      GimpMypaintBrushGeneratedShape shape;
+
+      shape = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (widget),
+                                                  "gimp-item-data"));
+
+      if (gimp_mypaint_brush_generated_get_shape (mypaint_brush) != shape)
+        gimp_mypaint_brush_generated_set_shape (mypaint_brush, shape);
+    }
+#endif
+}
+
+static void
+gimp_mypaint_brush_editor_notify_mypaint_brush (GimpMypaintBrush   *mypaint_brush,
+                                GParamSpec           *pspec,
+                                GimpMypaintBrushEditor      *editor)
+{
+#if 0
+  GtkAdjustment *adj   = NULL;
+  gdouble        value = 0.0;
+
+  if (! strcmp (pspec->name, "shape"))
+    {
+      g_signal_handlers_block_by_func (editor->shape_group,
+                                       gimp_mypaint_brush_editor_update_shape,
+                                       editor);
+
+      gimp_int_radio_group_set_active (GTK_RADIO_BUTTON (editor->shape_group),
+                                       mypaint_brush->shape);
+
+      g_signal_handlers_unblock_by_func (editor->shape_group,
+                                         gimp_mypaint_brush_editor_update_shape,
+                                         editor);
+
+      adj   = editor->radius_data;
+      value = mypaint_brush->radius;
+    }
+  else if (! strcmp (pspec->name, "radius"))
+    {
+      adj   = editor->radius_data;
+      value = mypaint_brush->radius;
+    }
+  else if (! strcmp (pspec->name, "spikes"))
+    {
+      adj   = editor->spikes_data;
+      value = mypaint_brush->spikes;
+    }
+  else if (! strcmp (pspec->name, "hardness"))
+    {
+      adj   = editor->hardness_data;
+      value = mypaint_brush->hardness;
+    }
+  else if (! strcmp (pspec->name, "angle"))
+    {
+      adj   = editor->angle_data;
+      value = mypaint_brush->angle;
+    }
+  else if (! strcmp (pspec->name, "aspect-ratio"))
+    {
+      adj   = editor->aspect_ratio_data;
+      value = mypaint_brush->aspect_ratio;
+    }
+  else if (! strcmp (pspec->name, "spacing"))
+    {
+      adj   = editor->spacing_data;
+      value = GIMP_MYPAINT_BRUSH (mypaint_brush)->spacing;
+    }
+
+  if (adj)
+    {
+      g_signal_handlers_block_by_func (adj,
+                                       gimp_mypaint_brush_editor_update_mypaint_brush,
+                                       editor);
+
+      gtk_adjustment_set_value (adj, value);
+
+      g_signal_handlers_unblock_by_func (adj,
+                                         gimp_mypaint_brush_editor_update_mypaint_brush,
+                                         editor);
+    }
+#endif
+}
+};
diff -Naur gimp-2.8.14/app/widgets/gimpmypaintbrusheditor.h gimp-2.8.14-new/app/widgets/gimpmypaintbrusheditor.h
--- gimp-2.8.14/app/widgets/gimpmypaintbrusheditor.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimpmypaintbrusheditor.h	2015-01-27 17:48:55.406751577 +0800
@@ -0,0 +1,58 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimpmypaint_brusheditor.h
+ * Copyright 1998 Jay Cox <jaycox@earthlink.net>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef  __GIMP_MYPAINT_BRUSH_EDITOR_H__
+#define  __GIMP_MYPAINT_BRUSH_EDITOR_H__
+
+
+#include "gimpdataeditor.h"
+#include "core/mypaintbrush-enum-settings.h"
+
+#define GIMP_TYPE_MYPAINT_BRUSH_EDITOR            (gimp_mypaint_brush_editor_get_type ())
+#define GIMP_MYPAINT_BRUSH_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MYPAINT_BRUSH_EDITOR, GimpMypaintBrushEditor))
+#define GIMP_MYPAINT_BRUSH_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MYPAINT_BRUSH_EDITOR, GimpMypaintBrushEditorClass))
+#define GIMP_IS_MYPAINT_BRUSH_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MYPAINT_BRUSH_EDITOR))
+#define GIMP_IS_MYPAINT_BRUSH_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MYPAINT_BRUSH_EDITOR))
+#define GIMP_MYPAINT_BRUSH_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MYPAINT_BRUSH_EDITOR, GimpMypaintBrushEditorClass))
+
+
+typedef struct _GimpMypaintBrushEditorClass GimpMypaintBrushEditorClass;
+
+struct _GimpMypaintBrushEditor
+{
+  GimpDataEditor  parent_instance;
+
+  GtkWidget      *options_box;
+  GtkWidget      *options_sliders[BRUSH_SETTINGS_COUNT];
+};
+
+struct _GimpMypaintBrushEditorClass
+{
+  GimpDataEditorClass  parent_class;
+};
+
+
+GType       gimp_mypaint_brush_editor_get_type (void) G_GNUC_CONST;
+
+GtkWidget * gimp_mypaint_brush_editor_new      (GimpContext     *context,
+                                        GimpMenuFactory *menu_factory);
+
+
+#endif  /*  __GIMP_MYPAINT_BRUSH_EDITOR_H__  */
diff -Naur gimp-2.8.14/app/widgets/gimpmypaintbrushfactoryview.c gimp-2.8.14-new/app/widgets/gimpmypaintbrushfactoryview.c
--- gimp-2.8.14/app/widgets/gimpmypaintbrushfactoryview.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimpmypaintbrushfactoryview.c	2015-01-27 17:48:55.406751577 +0800
@@ -0,0 +1,233 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimpmypaint_brushfactoryview.c
+ * Copyright (C) 2001 Michael Natterer <mitch@gimp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "widgets-types.h"
+
+#include "core/gimpcontainer.h"
+#include "core/gimpcontext.h"
+#include "core/gimpmypaintbrush.h"
+#include "core/gimpdatafactory.h"
+
+#include "gimpmypaintbrushfactoryview.h"
+#include "gimpcontainerview.h"
+#include "gimpmenufactory.h"
+#include "gimpspinscale.h"
+#include "gimpviewrenderer.h"
+
+#include "gimp-intl.h"
+
+
+static void   gimp_mypaint_brush_factory_view_dispose         (GObject              *object);
+
+static void   gimp_mypaint_brush_factory_view_select_item     (GimpContainerEditor  *editor,
+                                                       GimpViewable         *viewable);
+#if 0
+static void   gimp_mypaint_brush_factory_view_spacing_changed (GimpMypaintBrush            *mypaint_brush,
+                                                       GimpMypaintBrushFactoryView *view);
+static void   gimp_mypaint_brush_factory_view_spacing_update  (GtkAdjustment        *adjustment,
+                                                       GimpMypaintBrushFactoryView *view);
+#endif
+
+
+G_DEFINE_TYPE (GimpMypaintBrushFactoryView, gimp_mypaint_brush_factory_view,
+               GIMP_TYPE_DATA_FACTORY_VIEW)
+
+#define parent_class gimp_mypaint_brush_factory_view_parent_class
+
+
+static void
+gimp_mypaint_brush_factory_view_class_init (GimpMypaintBrushFactoryViewClass *klass)
+{
+  GObjectClass             *object_class = G_OBJECT_CLASS (klass);
+  GimpContainerEditorClass *editor_class = GIMP_CONTAINER_EDITOR_CLASS (klass);
+
+  object_class->dispose     = gimp_mypaint_brush_factory_view_dispose;
+
+  editor_class->select_item = gimp_mypaint_brush_factory_view_select_item;
+}
+
+static void
+gimp_mypaint_brush_factory_view_init (GimpMypaintBrushFactoryView *view)
+{
+#if 0
+  view->spacing_adjustment =
+    GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 1.0, 5000.0,
+                                        1.0, 10.0, 0.0));
+
+  view->spacing_scale = gimp_spin_scale_new (view->spacing_adjustment,
+                                             _("Spacing"), 1);
+  gimp_spin_scale_set_scale_limits (GIMP_SPIN_SCALE (view->spacing_scale),
+                                   1.0, 200.0);
+  gimp_help_set_help_data (view->spacing_scale,
+                           _("Percentage of width of mypaint_brush"),
+                           NULL);
+
+  g_signal_connect (view->spacing_adjustment, "value-changed",
+                    G_CALLBACK (gimp_mypaint_brush_factory_view_spacing_update),
+                    view);
+#endif
+}
+
+static void
+gimp_mypaint_brush_factory_view_dispose (GObject *object)
+{
+  GimpMypaintBrushFactoryView *view   = GIMP_MYPAINT_BRUSH_FACTORY_VIEW (object);
+  GimpContainerEditor  *editor = GIMP_CONTAINER_EDITOR (object);
+#if 0
+  if (view->spacing_changed_handler_id)
+    {
+      GimpDataFactory *factory;
+      GimpContainer   *container;
+
+      factory   = gimp_data_factory_view_get_data_factory (GIMP_DATA_FACTORY_VIEW (editor));
+      container = gimp_data_factory_get_container (factory);
+      gimp_container_remove_handler (container,
+                                     view->spacing_changed_handler_id);
+
+      view->spacing_changed_handler_id = 0;
+    }
+#endif
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+GtkWidget *
+gimp_mypaint_brush_factory_view_new (GimpViewType     view_type,
+                             GimpDataFactory *factory,
+                             GimpContext     *context,
+                             gint             view_size,
+                             gint             view_border_width,
+                             GimpMenuFactory *menu_factory)
+{
+  GimpMypaintBrushFactoryView *factory_view;
+  GimpContainerEditor  *editor;
+
+  g_return_val_if_fail (GIMP_IS_DATA_FACTORY (factory), NULL);
+  g_return_val_if_fail (GIMP_IS_CONTEXT (context), NULL);
+  g_return_val_if_fail (view_size > 0 &&
+                        view_size <= GIMP_VIEWABLE_MAX_PREVIEW_SIZE, NULL);
+  g_return_val_if_fail (view_border_width >= 0 &&
+                        view_border_width <= GIMP_VIEW_MAX_BORDER_WIDTH,
+                        NULL);
+  g_return_val_if_fail (menu_factory == NULL ||
+                        GIMP_IS_MENU_FACTORY (menu_factory), NULL);
+
+  factory_view = g_object_new (GIMP_TYPE_MYPAINT_BRUSH_FACTORY_VIEW,
+                               "view-type",         view_type,
+                               "data-factory",      factory,
+                               "context",           context,
+                               "view-size",         view_size,
+                               "view-border-width", view_border_width,
+                               "menu-factory",      menu_factory,
+                               "menu-identifier",   "<MypaintBrushes>",
+                               "ui-path",           "/mypaint-brushes-popup",
+                               "action-group",      "mypaint-brushes",
+                               NULL);
+
+
+  editor = GIMP_CONTAINER_EDITOR (factory_view);
+#if 0
+
+  gtk_box_pack_end (GTK_BOX (editor->view), factory_view->spacing_scale,
+                    FALSE, FALSE, 0);
+  factory_view->spacing_changed_handler_id =
+    gimp_container_add_handler (gimp_data_factory_get_container (factory), "spacing-changed",
+                                G_CALLBACK (gimp_mypaint_brush_factory_view_spacing_changed),
+                                factory_view);
+#endif
+  return GTK_WIDGET (factory_view);
+}
+
+static void
+gimp_mypaint_brush_factory_view_select_item (GimpContainerEditor *editor,
+                                     GimpViewable        *viewable)
+{
+  GimpMypaintBrushFactoryView *view = GIMP_MYPAINT_BRUSH_FACTORY_VIEW (editor);
+  GimpContainer        *container;
+
+  if (GIMP_CONTAINER_EDITOR_CLASS (parent_class)->select_item)
+    GIMP_CONTAINER_EDITOR_CLASS (parent_class)->select_item (editor, viewable);
+
+  container = gimp_container_view_get_container (editor->view);
+
+  if (viewable && gimp_container_have (container, GIMP_OBJECT (viewable)))
+    {
+      GimpMypaintBrush *mypaint_brush = GIMP_MYPAINT_BRUSH (viewable);
+
+
+    }
+}
+#if 0
+static void
+gimp_mypaint_brush_factory_view_spacing_changed (GimpMypaintBrush            *mypaint_brush,
+                                         GimpMypaintBrushFactoryView *view)
+{
+  GimpContainerEditor *editor = GIMP_CONTAINER_EDITOR (view);
+  GimpContext         *context;
+
+  context = gimp_container_view_get_context (editor->view);
+
+  if (mypaint_brush == gimp_context_get_mypaint_brush (context))
+    {
+      g_signal_handlers_block_by_func (view->spacing_adjustment,
+                                       gimp_mypaint_brush_factory_view_spacing_update,
+                                       view);
+
+      gtk_adjustment_set_value (view->spacing_adjustment,
+                                gimp_mypaint_brush_get_spacing (mypaint_brush));
+
+      g_signal_handlers_unblock_by_func (view->spacing_adjustment,
+                                         gimp_mypaint_brush_factory_view_spacing_update,
+                                         view);
+    }
+}
+
+static void
+gimp_mypaint_brush_factory_view_spacing_update (GtkAdjustment        *adjustment,
+                                        GimpMypaintBrushFactoryView *view)
+{
+  GimpContainerEditor *editor = GIMP_CONTAINER_EDITOR (view);
+  GimpContext         *context;
+  GimpMypaintBrush           *mypaint_brush;
+
+  context = gimp_container_view_get_context (editor->view);
+
+  mypaint_brush = gimp_context_get_mypaint_brush (context);
+
+  if (mypaint_brush && view->change_mypaint_brush_spacing)
+    {
+      g_signal_handlers_block_by_func (mypaint_brush,
+                                       gimp_mypaint_brush_factory_view_spacing_changed,
+                                       view);
+
+      gimp_mypaint_brush_set_spacing (mypaint_brush, gtk_adjustment_get_value (adjustment));
+
+      g_signal_handlers_unblock_by_func (mypaint_brush,
+                                         gimp_mypaint_brush_factory_view_spacing_changed,
+                                         view);
+    }
+}
+#endif
diff -Naur gimp-2.8.14/app/widgets/gimpmypaintbrushfactoryview.h gimp-2.8.14-new/app/widgets/gimpmypaintbrushfactoryview.h
--- gimp-2.8.14/app/widgets/gimpmypaintbrushfactoryview.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimpmypaintbrushfactoryview.h	2015-01-27 17:48:55.407751577 +0800
@@ -0,0 +1,65 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimpmypaint_brushfactoryview.h
+ * Copyright (C) 2001 Michael Natterer <mitch@gimp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_BRUSH_FACTORY_VIEW_H__
+#define __GIMP_MYPAINT_BRUSH_FACTORY_VIEW_H__
+
+#include "gimpdatafactoryview.h"
+
+
+#define GIMP_TYPE_MYPAINT_BRUSH_FACTORY_VIEW            (gimp_mypaint_brush_factory_view_get_type ())
+#define GIMP_MYPAINT_BRUSH_FACTORY_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MYPAINT_BRUSH_FACTORY_VIEW, GimpMypaintBrushFactoryView))
+#define GIMP_MYPAINT_BRUSH_FACTORY_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MYPAINT_BRUSH_FACTORY_VIEW, GimpMypaintBrushFactoryViewClass))
+#define GIMP_IS_MYPAINT_BRUSH_FACTORY_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MYPAINT_BRUSH_FACTORY_VIEW))
+#define GIMP_IS_MYPAINT_BRUSH_FACTORY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MYPAINT_BRUSH_FACTORY_VIEW))
+#define GIMP_MYPAINT_BRUSH_FACTORY_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MYPAINT_BRUSH_FACTORY_VIEW, GimpMypaintBrushFactoryViewClass))
+
+
+typedef struct _GimpMypaintBrushFactoryViewClass  GimpMypaintBrushFactoryViewClass;
+
+struct _GimpMypaintBrushFactoryView
+{
+  GimpDataFactoryView  parent_instance;
+#if 0
+  GtkWidget           *spacing_scale;
+  GtkAdjustment       *spacing_adjustment;
+
+  gboolean             change_mypaint_brush_spacing;
+  GQuark               spacing_changed_handler_id;
+#endif
+};
+
+struct _GimpMypaintBrushFactoryViewClass
+{
+  GimpDataFactoryViewClass  parent_class;
+};
+
+
+GType       gimp_mypaint_brush_factory_view_get_type (void) G_GNUC_CONST;
+
+GtkWidget * gimp_mypaint_brush_factory_view_new      (GimpViewType     view_type,
+                                              GimpDataFactory *factory,
+                                              GimpContext     *context,
+                                              gint             view_size,
+                                              gint             view_border_width,
+                                              GimpMenuFactory *menu_factory);
+
+
+#endif  /*  __GIMP_MYPAINT_BRUSH_FACTORY_VIEW_H__  */
diff -Naur gimp-2.8.14/app/widgets/gimpmypaintbrushselect.c gimp-2.8.14-new/app/widgets/gimpmypaintbrushselect.c
--- gimp-2.8.14/app/widgets/gimpmypaintbrushselect.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimpmypaintbrushselect.c	2015-01-27 17:48:55.407751577 +0800
@@ -0,0 +1,371 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimpmypaint_brushselect.c
+ * Copyright (C) 2004 Michael Natterer <mitch@gimp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "widgets-types.h"
+
+#include "base/temp-buf.h"
+
+#include "core/gimp.h"
+#include "core/gimpcontext.h"
+#include "core/gimpmypaintbrush.h"
+#include "core/gimpparamspecs.h"
+
+#include "pdb/gimppdb.h"
+
+#include "gimpmypaintbrushfactoryview.h"
+#include "gimpmypaintbrushselect.h"
+#include "gimpcontainerbox.h"
+#include "gimpspinscale.h"
+#include "gimpwidgets-constructors.h"
+
+#include "gimp-intl.h"
+
+
+enum
+{
+  PROP_0,
+  PROP_OPACITY,
+  PROP_PAINT_MODE,
+  PROP_SPACING
+};
+
+
+static void          gimp_mypaint_brush_select_constructed  (GObject         *object);
+static void          gimp_mypaint_brush_select_set_property (GObject         *object,
+                                                     guint            property_id,
+                                                     const GValue    *value,
+                                                     GParamSpec      *pspec);
+
+static GValueArray * gimp_mypaint_brush_select_run_callback (GimpPdbDialog   *dialog,
+                                                     GimpObject      *object,
+                                                     gboolean         closing,
+                                                     GError         **error);
+
+static void       gimp_mypaint_brush_select_opacity_changed (GimpContext     *context,
+                                                     gdouble          opacity,
+                                                     GimpMypaintBrushSelect *select);
+static void       gimp_mypaint_brush_select_mode_changed    (GimpContext     *context,
+                                                     GimpLayerModeEffects  paint_mode,
+                                                     GimpMypaintBrushSelect *select);
+
+static void       gimp_mypaint_brush_select_opacity_update  (GtkAdjustment   *adj,
+                                                     GimpMypaintBrushSelect *select);
+static void       gimp_mypaint_brush_select_mode_update     (GtkWidget       *widget,
+                                                     GimpMypaintBrushSelect *select);
+static void       gimp_mypaint_brush_select_spacing_update  (GtkAdjustment   *adj,
+                                                     GimpMypaintBrushSelect *select);
+
+
+G_DEFINE_TYPE (GimpMypaintBrushSelect, gimp_mypaint_brush_select, GIMP_TYPE_PDB_DIALOG)
+
+#define parent_class gimp_mypaint_brush_select_parent_class
+
+
+static void
+gimp_mypaint_brush_select_class_init (GimpMypaintBrushSelectClass *klass)
+{
+  GObjectClass       *object_class = G_OBJECT_CLASS (klass);
+  GimpPdbDialogClass *pdb_class    = GIMP_PDB_DIALOG_CLASS (klass);
+
+  object_class->constructed  = gimp_mypaint_brush_select_constructed;
+  object_class->set_property = gimp_mypaint_brush_select_set_property;
+
+  pdb_class->run_callback    = gimp_mypaint_brush_select_run_callback;
+#if 0
+  g_object_class_install_property (object_class, PROP_OPACITY,
+                                   g_param_spec_double ("opacity", NULL, NULL,
+                                                        GIMP_OPACITY_TRANSPARENT,
+                                                        GIMP_OPACITY_OPAQUE,
+                                                        GIMP_OPACITY_OPAQUE,
+                                                        GIMP_PARAM_WRITABLE |
+                                                        G_PARAM_CONSTRUCT));
+
+  g_object_class_install_property (object_class, PROP_PAINT_MODE,
+                                   g_param_spec_enum ("paint-mode", NULL, NULL,
+                                                      GIMP_TYPE_LAYER_MODE_EFFECTS,
+                                                      GIMP_NORMAL_MODE,
+                                                      GIMP_PARAM_WRITABLE |
+                                                      G_PARAM_CONSTRUCT));
+
+  g_object_class_install_property (object_class, PROP_SPACING,
+                                   g_param_spec_int ("spacing", NULL, NULL,
+                                                     -G_MAXINT, 1000, -1,
+                                                     GIMP_PARAM_WRITABLE |
+                                                     G_PARAM_CONSTRUCT));
+#endif
+}
+
+static void
+gimp_mypaint_brush_select_init (GimpMypaintBrushSelect *select)
+{
+}
+
+static void
+gimp_mypaint_brush_select_constructed (GObject *object)
+{
+  GimpPdbDialog   *dialog = GIMP_PDB_DIALOG (object);
+  GimpMypaintBrushSelect *select = GIMP_MYPAINT_BRUSH_SELECT (object);
+  GtkWidget       *content_area;
+  GtkWidget       *vbox;
+  GtkWidget       *scale;
+  GtkWidget       *hbox;
+  GtkWidget       *label;
+  GtkAdjustment   *spacing_adj;
+
+  if (G_OBJECT_CLASS (parent_class)->constructed)
+    G_OBJECT_CLASS (parent_class)->constructed (object);
+#if 0
+  gimp_context_set_opacity    (dialog->context, select->initial_opacity);
+  gimp_context_set_paint_mode (dialog->context, select->initial_mode);
+
+  g_signal_connect (dialog->context, "opacity-changed",
+                    G_CALLBACK (gimp_mypaint_brush_select_opacity_changed),
+                    dialog);
+  g_signal_connect (dialog->context, "paint-mode-changed",
+                    G_CALLBACK (gimp_mypaint_brush_select_mode_changed),
+                    dialog);
+#endif
+
+  dialog->view =
+    gimp_mypaint_brush_factory_view_new (GIMP_VIEW_TYPE_GRID,
+                                 dialog->context->gimp->mypaint_brush_factory,
+                                 dialog->context,
+                                 GIMP_VIEW_SIZE_MEDIUM, 1,
+                                 dialog->menu_factory);
+
+  gimp_container_box_set_size_request (GIMP_CONTAINER_BOX (GIMP_CONTAINER_EDITOR (dialog->view)->view),
+                                       5 * (GIMP_VIEW_SIZE_MEDIUM + 2),
+                                       5 * (GIMP_VIEW_SIZE_MEDIUM + 2));
+
+  gtk_container_set_border_width (GTK_CONTAINER (dialog->view), 12);
+
+  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
+  gtk_box_pack_start (GTK_BOX (content_area), dialog->view, TRUE, TRUE, 0);
+  gtk_widget_show (dialog->view);
+
+  vbox = GTK_WIDGET (GIMP_CONTAINER_EDITOR (dialog->view)->view);
+
+  /*  Create the opacity scale widget  */
+#if 0
+  select->opacity_data =
+    GTK_ADJUSTMENT (gtk_adjustment_new (gimp_context_get_opacity (dialog->context) * 100.0,
+                                        0.0, 100.0,
+                                        1.0, 10.0, 0.0));
+
+  scale = gimp_spin_scale_new (select->opacity_data,
+                               _("Opacity"), 1);
+  gtk_box_pack_end (GTK_BOX (vbox), scale, FALSE, FALSE, 0);
+  gtk_widget_show (scale);
+
+  g_signal_connect (select->opacity_data, "value-changed",
+                    G_CALLBACK (gimp_mypaint_brush_select_opacity_update),
+                    select);
+
+  /*  Create the paint mode option menu  */
+  hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 4);
+  gtk_box_pack_end (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
+  gtk_widget_show (hbox);
+
+  label = gtk_label_new (_("Mode:"));
+  gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
+  gtk_widget_show (label);
+
+  select->paint_mode_menu = gimp_paint_mode_menu_new (TRUE, FALSE);
+  gtk_box_pack_start (GTK_BOX (hbox), select->paint_mode_menu, TRUE, TRUE, 0);
+  gtk_widget_show (select->paint_mode_menu);
+
+  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (select->paint_mode_menu),
+                              gimp_context_get_paint_mode (dialog->context),
+                              G_CALLBACK (gimp_mypaint_brush_select_mode_update),
+                              select);
+
+  spacing_adj = GIMP_MYPAINT_BRUSH_FACTORY_VIEW (dialog->view)->spacing_adjustment;
+
+  /*  Use passed spacing instead of mypaint_brushes default  */
+  if (select->spacing >= 0)
+    gtk_adjustment_set_value (spacing_adj, select->spacing);
+
+  g_signal_connect (spacing_adj, "value-changed",
+                    G_CALLBACK (gimp_mypaint_brush_select_spacing_update),
+                    select);
+#endif
+}
+
+static void
+gimp_mypaint_brush_select_set_property (GObject      *object,
+                                guint         property_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  GimpPdbDialog   *dialog = GIMP_PDB_DIALOG (object);
+  GimpMypaintBrushSelect *select = GIMP_MYPAINT_BRUSH_SELECT (object);
+
+  switch (property_id)
+    {
+#if 0
+    case PROP_OPACITY:
+      if (dialog->view)
+        gimp_context_set_opacity (dialog->context, g_value_get_double (value));
+      else
+        select->initial_opacity = g_value_get_double (value);
+      break;
+    case PROP_PAINT_MODE:
+      if (dialog->view)
+        gimp_context_set_paint_mode (dialog->context, g_value_get_enum (value));
+      else
+        select->initial_mode = g_value_get_enum (value);
+      break;
+    case PROP_SPACING:
+      if (dialog->view)
+        {
+          if (g_value_get_int (value) >= 0)
+            gtk_adjustment_set_value (GIMP_MYPAINT_BRUSH_FACTORY_VIEW (dialog->view)->spacing_adjustment,
+                                      g_value_get_int (value));
+        }
+      else
+        {
+          select->spacing = g_value_get_int (value);
+        }
+      break;
+#endif
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+static GValueArray *
+gimp_mypaint_brush_select_run_callback (GimpPdbDialog  *dialog,
+                                GimpObject     *object,
+                                gboolean        closing,
+                                GError        **error)
+{
+  GimpMypaintBrush   *mypaint_brush = GIMP_MYPAINT_BRUSH (object);
+  GimpArray   *array;
+  GValueArray *return_vals;
+  g_print("gimp_mypaint_brush_select_run_callback\n");
+#if 0
+  array = gimp_array_new (temp_buf_get_data (mypaint_brush->mask),
+                          temp_buf_get_data_size (mypaint_brush->mask),
+                          TRUE);
+
+  return_vals =
+    gimp_pdb_execute_procedure_by_name (dialog->pdb,
+                                        dialog->caller_context,
+                                        NULL, error,
+                                        dialog->callback_name,
+                                        G_TYPE_STRING,        gimp_object_get_name (object),
+                                        G_TYPE_DOUBLE,        100,//gimp_context_get_opacity (dialog->context) * 100.0,
+                                        GIMP_TYPE_INT32,      1,//GIMP_MYPAINT_BRUSH_SELECT (dialog)->spacing,
+                                        GIMP_TYPE_INT32,      gimp_context_get_paint_mode (dialog->context),
+                                        GIMP_TYPE_INT32,      1,//mypaint_brush->mask->width,
+                                        GIMP_TYPE_INT32,      1,//mypaint_brush->mask->height,
+                                        GIMP_TYPE_INT32,      array->length,
+                                        GIMP_TYPE_INT8_ARRAY, array,
+                                        GIMP_TYPE_INT32,      closing,
+                                        G_TYPE_NONE);
+
+  gimp_array_free (array);
+#else
+  return_vals = NULL;
+#endif
+
+  return return_vals;
+}
+#if 0
+static void
+gimp_mypaint_brush_select_opacity_changed (GimpContext     *context,
+                                   gdouble          opacity,
+                                   GimpMypaintBrushSelect *select)
+{
+  g_signal_handlers_block_by_func (select->opacity_data,
+                                   gimp_mypaint_brush_select_opacity_update,
+                                   select);
+
+  gtk_adjustment_set_value (select->opacity_data, opacity * 100.0);
+
+  g_signal_handlers_unblock_by_func (select->opacity_data,
+                                     gimp_mypaint_brush_select_opacity_update,
+                                     select);
+
+  gimp_pdb_dialog_run_callback (GIMP_PDB_DIALOG (select), FALSE);
+}
+
+static void
+gimp_mypaint_brush_select_mode_changed (GimpContext          *context,
+                                GimpLayerModeEffects  paint_mode,
+                                GimpMypaintBrushSelect      *select)
+{
+  g_signal_handlers_block_by_func (select->paint_mode_menu,
+                                   gimp_mypaint_brush_select_mode_update,
+                                   select);
+
+  gimp_int_combo_box_set_active (GIMP_INT_COMBO_BOX (select->paint_mode_menu),
+                                 paint_mode);
+
+  g_signal_handlers_unblock_by_func (select->paint_mode_menu,
+                                     gimp_mypaint_brush_select_mode_update,
+                                     select);
+
+  gimp_pdb_dialog_run_callback (GIMP_PDB_DIALOG (select), FALSE);
+}
+
+static void
+gimp_mypaint_brush_select_opacity_update (GtkAdjustment   *adjustment,
+                                  GimpMypaintBrushSelect *select)
+{
+  gimp_context_set_opacity (GIMP_PDB_DIALOG (select)->context,
+                            gtk_adjustment_get_value (adjustment) / 100.0);
+}
+
+static void
+gimp_mypaint_brush_select_mode_update (GtkWidget       *widget,
+                               GimpMypaintBrushSelect *select)
+{
+  gint paint_mode;
+
+  if (gimp_int_combo_box_get_active (GIMP_INT_COMBO_BOX (widget),
+                                     &paint_mode))
+    {
+      gimp_context_set_paint_mode (GIMP_PDB_DIALOG (select)->context,
+                                   (GimpLayerModeEffects) paint_mode);
+    }
+}
+
+static void
+gimp_mypaint_brush_select_spacing_update (GtkAdjustment   *adjustment,
+                                  GimpMypaintBrushSelect *select)
+{
+  gdouble value = gtk_adjustment_get_value (adjustment);
+
+  if (select->spacing != value)
+    {
+      select->spacing = value;
+
+      gimp_pdb_dialog_run_callback (GIMP_PDB_DIALOG (select), FALSE);
+    }
+}
+#endif
diff -Naur gimp-2.8.14/app/widgets/gimpmypaintbrushselect.h gimp-2.8.14-new/app/widgets/gimpmypaintbrushselect.h
--- gimp-2.8.14/app/widgets/gimpmypaintbrushselect.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimpmypaintbrushselect.h	2015-01-27 17:48:55.407751577 +0800
@@ -0,0 +1,60 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimpbrushselect.h
+ * Copyright (C) 2004 Michael Natterer <mitch@gimp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_MYPAINT_BRUSH_SELECT_H__
+#define __GIMP_MYPAINT_BRUSH_SELECT_H__
+
+#include "gimppdbdialog.h"
+
+G_BEGIN_DECLS
+
+
+#define GIMP_TYPE_MYPAINT_BRUSH_SELECT            (gimp_mypaint_brush_select_get_type ())
+#define GIMP_MYPAINT_BRUSH_SELECT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MYPAINT_BRUSH_SELECT, GimpMypaintBrushSelect))
+#define GIMP_MYPAINT_BRUSH_SELECT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MYPAINT_BRUSH_SELECT, GimpMypaintBrushSelectClass))
+#define GIMP_IS_MYPAINT_BRUSH_SELECT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MYPAINT_BRUSH_SELECT))
+#define GIMP_IS_MYPAINT_BRUSH_SELECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MYPAINT_BRUSH_SELECT))
+#define GIMP_MYPAINT_BRUSH_SELECT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MYPAINT_BRUSH_SELECT, GimpMypaintBrushSelectClass))
+
+
+typedef struct _GimpMypaintBrushSelectClass  GimpMypaintBrushSelectClass;
+
+struct _GimpMypaintBrushSelect
+{
+  GimpPdbDialog         parent_instance;
+
+/*  gdouble               initial_opacity; */
+/*  GimpLayerModeEffects  initial_mode; */
+
+/*  GtkWidget            *paint_mode_menu; */
+};
+
+struct _GimpMypaintBrushSelectClass
+{
+  GimpPdbDialogClass  parent_class;
+};
+
+
+GType  gimp_mypaint_brush_select_get_type (void) G_GNUC_CONST;
+
+
+G_END_DECLS
+
+#endif /* __GIMP_MYPAINT_BRUSH_SELECT_H__ */
diff -Naur gimp-2.8.14/app/widgets/gimppaletteview.c gimp-2.8.14-new/app/widgets/gimppaletteview.c
--- gimp-2.8.14/app/widgets/gimppaletteview.c	2015-01-27 17:28:36.934833806 +0800
+++ gimp-2.8.14-new/app/widgets/gimppaletteview.c	2015-01-27 17:48:55.408751577 +0800
@@ -42,6 +42,7 @@
   ENTRY_SELECTED,
   ENTRY_ACTIVATED,
   ENTRY_CONTEXT,
+  ENTRY_CONFIRMED,
   COLOR_DROPPED,
   LAST_SIGNAL
 };
@@ -51,6 +52,8 @@
                                                   GdkEventExpose   *eevent);
 static gboolean gimp_palette_view_button_press   (GtkWidget        *widget,
                                                   GdkEventButton   *bevent);
+static gboolean gimp_palette_view_button_release (GtkWidget        *widget,
+                                                  GdkEventButton   *bevent);
 static gboolean gimp_palette_view_key_press      (GtkWidget        *widget,
                                                   GdkEventKey      *kevent);
 static gboolean gimp_palette_view_focus          (GtkWidget        *widget,
@@ -130,6 +133,16 @@
                   G_TYPE_NONE, 1,
                   G_TYPE_POINTER);
 
+  view_signals[ENTRY_CONFIRMED] =
+    g_signal_new ("entry-confirmed",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_FIRST,
+                  G_STRUCT_OFFSET (GimpPaletteViewClass, entry_confirmed),
+                  NULL, NULL,
+                  gimp_marshal_VOID__POINTER,
+                  G_TYPE_NONE, 1,
+                  G_TYPE_POINTER);
+
   view_signals[COLOR_DROPPED] =
     g_signal_new ("color-dropped",
                   G_TYPE_FROM_CLASS (klass),
@@ -141,12 +154,13 @@
                   G_TYPE_POINTER,
                   GIMP_TYPE_RGB);
 
-  widget_class->expose_event       = gimp_palette_view_expose;
-  widget_class->button_press_event = gimp_palette_view_button_press;
-  widget_class->key_press_event    = gimp_palette_view_key_press;
-  widget_class->focus              = gimp_palette_view_focus;
+  widget_class->expose_event         = gimp_palette_view_expose;
+  widget_class->button_press_event   = gimp_palette_view_button_press;
+  widget_class->button_release_event = gimp_palette_view_button_release;
+  widget_class->key_press_event      = gimp_palette_view_key_press;
+  widget_class->focus                = gimp_palette_view_focus;
 
-  view_class->set_viewable         = gimp_palette_view_set_viewable;
+  view_class->set_viewable           = gimp_palette_view_set_viewable;
 }
 
 static void
@@ -219,7 +233,7 @@
 {
   GimpPaletteView  *view = GIMP_PALETTE_VIEW (widget);
   GimpPaletteEntry *entry;
-
+  
   if (gtk_widget_get_can_focus (widget) && ! gtk_widget_has_focus (widget))
     gtk_widget_grab_focus (widget);
 
@@ -257,6 +271,31 @@
 }
 
 static gboolean
+gimp_palette_view_button_release (GtkWidget      *widget,
+                                  GdkEventButton *bevent)
+{
+  GimpPaletteView  *view = GIMP_PALETTE_VIEW (widget);
+  GimpPaletteEntry *entry;
+  
+  if (gtk_widget_get_can_focus (widget) && ! gtk_widget_has_focus (widget))
+    gtk_widget_grab_focus (widget);
+
+  entry = gimp_palette_view_find_entry (view, bevent->x, bevent->y);
+
+  view->dnd_entry = entry;
+
+  if (! entry || bevent->button == 2)
+    return FALSE;
+
+  if (bevent->button == 1 && view->selected == entry)
+    {
+      g_signal_emit (view, view_signals[ENTRY_CONFIRMED], 0, entry);
+    }
+
+  return FALSE;
+}
+
+static gboolean
 gimp_palette_view_key_press (GtkWidget   *widget,
                              GdkEventKey *kevent)
 {
diff -Naur gimp-2.8.14/app/widgets/gimppaletteview.h gimp-2.8.14-new/app/widgets/gimppaletteview.h
--- gimp-2.8.14/app/widgets/gimppaletteview.h	2015-01-27 17:28:36.946833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimppaletteview.h	2015-01-27 17:48:55.408751577 +0800
@@ -55,6 +55,8 @@
                             GimpPaletteEntry *entry);
   void (* entry_context)   (GimpPaletteView  *view,
                             GimpPaletteEntry *entry);
+  void (* entry_confirmed) (GimpPaletteView  *view,
+                            GimpPaletteEntry *entry);
   void (* color_dropped)   (GimpPaletteView  *view,
                             GimpPaletteEntry *entry,
                             const GimpRGB    *color);
diff -Naur gimp-2.8.14/app/widgets/gimppopupbutton.c gimp-2.8.14-new/app/widgets/gimppopupbutton.c
--- gimp-2.8.14/app/widgets/gimppopupbutton.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimppopupbutton.c	2015-01-27 17:48:55.409751577 +0800
@@ -0,0 +1,681 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * GimpPopup.c
+ * Copyright (C) 2003-2005 Michael Natterer <mitch@gimp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+#include <gdk/gdkkeysyms.h>
+
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "widgets-types.h"
+
+#include "core/gimpcontext.h"
+#include "core/gimpcontainer.h"
+#include "core/gimpmarshal.h"
+
+#include "gimpviewrenderer.h"
+
+#include "gimppopupbutton.h"
+
+#include "gimp-intl.h"
+enum
+{
+  CANCEL = 0,
+  CONFIRM,
+  LAST_SIGNAL
+};
+
+
+static void     gimp_popup_finalize     (GObject            *object);
+
+static void     gimp_popup_map          (GtkWidget          *widget);
+static gboolean gimp_popup_button_press (GtkWidget          *widget,
+                                          GdkEventButton     *bevent);
+static gboolean gimp_popup_key_press    (GtkWidget          *widget,
+                                          GdkEventKey        *kevent);
+
+static void     gimp_popup_real_cancel  (GimpPopup *popup);
+static void     gimp_popup_real_confirm (GimpPopup *popup);
+
+
+G_DEFINE_TYPE (GimpPopup, gimp_popup, GTK_TYPE_WINDOW)
+
+#define parent_class gimp_popup_parent_class
+
+static guint popup_signals[LAST_SIGNAL];
+
+
+static void
+gimp_popup_class_init (GimpPopupClass *klass)
+{
+  GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
+  GtkBindingSet  *binding_set;
+
+  popup_signals[CANCEL] =
+    g_signal_new ("cancel",
+                  G_OBJECT_CLASS_TYPE (klass),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                  G_STRUCT_OFFSET (GimpPopupClass, cancel),
+                  NULL, NULL,
+                  gimp_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+
+  popup_signals[CONFIRM] =
+    g_signal_new ("confirm",
+                  G_OBJECT_CLASS_TYPE (klass),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                  G_STRUCT_OFFSET (GimpPopupClass, confirm),
+                  NULL, NULL,
+                  gimp_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+
+  object_class->finalize           = gimp_popup_finalize;
+
+  widget_class->map                = gimp_popup_map;
+  widget_class->button_press_event = gimp_popup_button_press;
+  widget_class->key_press_event    = gimp_popup_key_press;
+
+  klass->cancel                    = gimp_popup_real_cancel;
+  klass->confirm                   = gimp_popup_real_confirm;
+
+
+  binding_set = gtk_binding_set_by_class (klass);
+
+  gtk_binding_entry_add_signal (binding_set, GDK_Escape, 0,
+                                "cancel", 0);
+/*
+  gtk_binding_entry_add_signal (binding_set, GDK_Return, 0,
+                                "confirm", 0);
+  gtk_binding_entry_add_signal (binding_set, GDK_KP_Enter, 0,
+                                "confirm", 0);
+  gtk_binding_entry_add_signal (binding_set, GDK_ISO_Enter, 0,
+                                "confirm", 0);
+  gtk_binding_entry_add_signal (binding_set, GDK_space, 0,
+                                "confirm", 0);
+  gtk_binding_entry_add_signal (binding_set, GDK_KP_Space, 0,
+                                "confirm", 0);
+*/
+}
+
+static void
+gimp_popup_init (GimpPopup *popup)
+{
+//  popup->view_type         = GIMP_VIEW_TYPE_LIST;
+  popup->default_view_size = GIMP_VIEW_SIZE_SMALL;
+  popup->view_size         = GIMP_VIEW_SIZE_SMALL;
+  popup->view_border_width = 1;
+
+  popup->frame = gtk_frame_new (NULL);
+  gtk_frame_set_shadow_type (GTK_FRAME (popup->frame), GTK_SHADOW_OUT);
+  gtk_container_add (GTK_CONTAINER (popup), popup->frame);
+  gtk_widget_show (popup->frame);
+}
+
+static void
+gimp_popup_finalize (GObject *object)
+{
+/*
+  GimpPopup *popup = GIMP_POPUP (object);
+*/
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gimp_popup_grab_notify (GtkWidget *widget,
+                        gboolean   was_grabbed)
+{
+  if (was_grabbed)
+    return;
+
+  /* ignore grabs on one of our children, like the scrollbar */
+  if (gtk_widget_is_ancestor (gtk_grab_get_current (), widget))
+    return;
+
+/*  g_signal_emit (widget, popup_signals[CANCEL], 0); */
+}
+
+static gboolean
+gimp_popup_grab_broken_event (GtkWidget          *widget,
+                              GdkEventGrabBroken *event)
+{
+  gimp_popup_grab_notify (widget, FALSE);
+
+  return FALSE;
+}
+
+static void
+gimp_popup_map (GtkWidget *widget)
+{
+  GTK_WIDGET_CLASS (parent_class)->map (widget);
+
+  /*  grab with owner_events == TRUE so the popup's widgets can
+   *  receive events. we filter away events outside this toplevel
+   *  away in button_press()
+   */
+  if (gdk_pointer_grab (gtk_widget_get_window (widget), TRUE,
+                        GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+                        GDK_POINTER_MOTION_MASK,
+                        NULL, NULL, GDK_CURRENT_TIME) == 0)
+    {
+      if (gdk_keyboard_grab (gtk_widget_get_window (widget), TRUE,
+                             GDK_CURRENT_TIME) == 0)
+        {
+          gtk_grab_add (widget);
+
+          g_signal_connect (widget, "grab-notify",
+                            G_CALLBACK (gimp_popup_grab_notify),
+                            widget);
+          g_signal_connect (widget, "grab-broken-event",
+                            G_CALLBACK (gimp_popup_grab_broken_event),
+                            widget);
+
+          return;
+        }
+      else
+        {
+          gdk_display_pointer_ungrab (gtk_widget_get_display (widget),
+                                      GDK_CURRENT_TIME);
+        }
+    }
+
+  /*  if we could not grab, destroy the popup instead of leaving it
+   *  around uncloseable.
+   */
+  g_signal_emit (widget, popup_signals[CANCEL], 0);
+}
+
+static gboolean
+gimp_popup_button_press (GtkWidget      *widget,
+                         GdkEventButton *bevent)
+{
+  GtkWidget *event_widget;
+  gboolean   cancel = FALSE;
+
+  event_widget = gtk_get_event_widget ((GdkEvent *) bevent);
+
+  if (event_widget == widget)
+    {
+      GtkAllocation allocation;
+
+      gtk_widget_get_allocation (widget, &allocation);
+
+      /*  the event was on the popup, which can either be really on the
+       *  popup or outside gimp (owner_events == TRUE, see map())
+       */
+      if (bevent->x < 0                ||
+          bevent->y < 0                ||
+          bevent->x > allocation.width ||
+          bevent->y > allocation.height)
+        {
+          /*  the event was outsde gimp  */
+          cancel = TRUE;
+        }
+    }
+  else if (gtk_widget_get_toplevel (event_widget) != widget)
+    {
+      /* GtkWidget *parent; */
+      /*  the event was on a gimp widget, but not inside the popup  */
+
+      cancel = TRUE;
+      
+    }
+
+  if (cancel)
+    g_signal_emit (widget, popup_signals[CANCEL], 0);
+
+//  return cancel;
+  return FALSE;
+}
+
+static gboolean
+gimp_popup_key_press (GtkWidget   *widget,
+                      GdkEventKey *kevent)
+{
+  GtkBindingSet *binding_set;
+
+  binding_set =
+    gtk_binding_set_by_class (GIMP_POPUP_GET_CLASS (widget));
+
+  /*  invoke the popup's binding entries manually, because otherwise
+   *  the focus widget (GtkTreeView e.g.) would consume it
+   */
+  if (gtk_binding_set_activate (binding_set,
+                                kevent->keyval,
+                                kevent->state,
+                                GTK_OBJECT (widget)))
+    {
+      return TRUE;
+    }
+
+  return GTK_WIDGET_CLASS (parent_class)->key_press_event (widget, kevent);
+}
+
+static void
+gimp_popup_real_cancel (GimpPopup *popup)
+{
+  GtkWidget *widget = GTK_WIDGET (popup);
+
+  if (gtk_grab_get_current () == widget)
+    gtk_grab_remove (widget);
+
+  gtk_widget_destroy (widget);
+}
+
+static void
+gimp_popup_real_confirm (GimpPopup *popup)
+{
+  gimp_popup_close (popup);
+}
+
+
+void
+gimp_popup_close (GimpPopup *popup)
+{
+  GtkWidget  *widget = GTK_WIDGET (popup);
+  if (gtk_grab_get_current () == widget)
+    gtk_grab_remove (widget);
+
+  gtk_widget_destroy (widget);
+//  g_object_unref (G_OBJECT (widget));
+}
+
+GtkWidget *
+gimp_popup_new (GtkWidget *view)
+{
+  GimpPopup *popup;
+
+  popup = g_object_new (GIMP_TYPE_POPUP,
+                        "type", GTK_WINDOW_POPUP,
+                        NULL);
+  gtk_window_set_resizable (GTK_WINDOW (popup), FALSE);
+
+  popup->default_view_size = 0;
+  popup->view_size         = 0;
+  popup->view_border_width = 0;
+
+  gimp_popup_set_view (popup, view);
+
+  return GTK_WIDGET (popup);
+}
+
+
+void
+gimp_popup_show (GimpPopup *popup,
+                 GdkScreen *screen,
+                 gint targetLeft,
+                 gint targetTop,
+                 gint targetRight,
+                 gint targetBottom,
+                 GtkCornerType pos)
+{
+  GtkRequisition  requisition;
+  GdkRectangle    rect;
+  gint            monitor;
+  gint            x;
+  gint            y;
+
+  g_return_if_fail (GIMP_IS_POPUP (popup));
+  g_return_if_fail (GDK_IS_SCREEN (screen));
+
+  gtk_widget_size_request (GTK_WIDGET (popup), &requisition);
+
+  monitor = gdk_screen_get_monitor_at_point (screen, targetLeft, targetTop);
+  gdk_screen_get_monitor_geometry (screen, monitor, &rect);
+
+  x = targetLeft;
+  if (pos == GTK_CORNER_TOP_RIGHT || pos == GTK_CORNER_BOTTOM_RIGHT)
+    {
+      x = targetRight - requisition.width;
+
+      if (x < rect.x)
+        x = targetLeft;
+    }
+  else
+    {
+      x = targetLeft;
+
+      if (x + requisition.width > rect.x + rect.width)
+        x = targetRight - requisition.width;
+    }
+
+  if (pos == GTK_CORNER_BOTTOM_LEFT || pos == GTK_CORNER_BOTTOM_RIGHT)
+    {
+      y = targetBottom;
+
+      if (y + requisition.height > rect.y + rect.height)
+        y = targetTop - requisition.height;
+    }
+  else
+    {
+      y = targetTop - requisition.height;
+      
+      if (y < rect.y)
+        y = targetBottom;
+    }
+
+  gtk_window_move (GTK_WINDOW (popup), x, y);
+  gtk_widget_show (GTK_WIDGET (popup));
+}
+
+void
+gimp_popup_show_over_widget (GimpPopup *popup,
+                             GtkWidget *widget)
+{
+  GdkScreen      *screen;
+  GtkRequisition  requisition;
+  GtkAllocation   allocation;
+  gint            orig_x;
+  gint            orig_y;
+
+  g_return_if_fail (GIMP_IS_POPUP (popup));
+  g_return_if_fail (GTK_IS_WIDGET (widget));
+
+  gtk_widget_size_request (GTK_WIDGET (popup), &requisition);
+
+  gtk_widget_get_allocation (widget, &allocation);
+  gdk_window_get_origin (gtk_widget_get_window (widget), &orig_x, &orig_y);
+
+  if (! gtk_widget_get_has_window (widget))
+    {
+      orig_x += allocation.x;
+      orig_y += allocation.y;
+    }
+
+  screen = gtk_widget_get_screen (widget);
+
+  gimp_popup_show (popup, screen, orig_x, orig_y, 
+                   orig_x + allocation.width, orig_y + allocation.height, 
+                   GTK_CORNER_BOTTOM_LEFT);
+}
+
+
+void
+gimp_popup_set_view_size (GimpPopup *popup,
+                          gint       view_size)
+{
+  if (view_size != popup->view_size)
+    {
+      popup->view_size = view_size;
+    }
+}
+
+
+void
+gimp_popup_set_view (GimpPopup *popup, GtkWidget *view)
+{
+  popup->view = view;
+  
+  gtk_container_add (GTK_CONTAINER (popup->frame), GTK_WIDGET (popup->view));
+  gtk_widget_show (GTK_WIDGET (popup->view));
+
+  gtk_widget_grab_focus (GTK_WIDGET (popup->view));
+}
+/*  private functions  */
+/* no private functions */
+
+
+/**
+ * GimpPopupButton
+ */
+
+enum
+{
+  PROP_0 = 0,
+  PROP_POPUP_VIEW_SIZE
+};
+
+enum
+{
+  CREATE_VIEW = 0,
+  POPUP_BUTTON_LAST_SIGNAL
+};
+
+
+static void     gimp_popup_button_finalize     (GObject            *object);
+static void     gimp_popup_button_set_property (GObject            *object,
+                                                   guint               property_id,
+                                                   const GValue       *value,
+                                                   GParamSpec         *pspec);
+static void     gimp_popup_button_get_property (GObject            *object,
+                                                   guint               property_id,
+                                                   GValue             *value,
+                                                   GParamSpec         *pspec);
+static gboolean gimp_popup_button_scroll_event (GtkWidget          *widget,
+                                                   GdkEventScroll     *sevent);
+static gboolean gimp_popup_button_button_press (GtkWidget          *button,
+                                                 GdkEventButton *bevent);
+
+static void     gimp_popup_button_popup_closed (GimpPopup *popup,
+                                                   GimpPopupButton *button);
+
+static guint popup_button_signals[POPUP_BUTTON_LAST_SIGNAL];
+
+G_DEFINE_TYPE (GimpPopupButton, gimp_popup_button, GIMP_TYPE_BUTTON)
+#undef parent_class
+#define parent_class gimp_popup_button_parent_class
+
+
+static void
+gimp_popup_button_class_init (GimpPopupButtonClass *klass)
+{
+  GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
+//  GtkButtonClass *button_class = GTK_BUTTON_CLASS (klass);
+
+  object_class->finalize     = gimp_popup_button_finalize;
+  object_class->get_property = gimp_popup_button_get_property;
+  object_class->set_property = gimp_popup_button_set_property;
+
+  widget_class->scroll_event = gimp_popup_button_scroll_event;
+
+  widget_class->button_press_event = gimp_popup_button_button_press;
+
+  popup_button_signals[CREATE_VIEW] =
+    g_signal_new ("create-view",
+                  G_OBJECT_CLASS_TYPE (klass),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                  0,
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__POINTER,
+                  G_TYPE_NONE, 1, G_TYPE_POINTER);
+
+  g_object_class_install_property (object_class, PROP_POPUP_VIEW_SIZE,
+                                   g_param_spec_int ("popup-view-size",
+                                                     NULL, NULL,
+                                                     GIMP_VIEW_SIZE_TINY,
+                                                     GIMP_VIEW_SIZE_GIGANTIC,
+                                                     GIMP_VIEW_SIZE_SMALL,
+                                                     GIMP_PARAM_READWRITE));
+}
+
+static void
+gimp_popup_button_init (GimpPopupButton *button)
+{
+  button->popup_view_type   = GIMP_VIEW_TYPE_LIST;
+  button->popup_view_size   = GIMP_VIEW_SIZE_SMALL;
+
+  button->button_view_size  = GIMP_VIEW_SIZE_SMALL;
+  button->view_border_width = 1;
+}
+
+static void
+gimp_popup_button_finalize (GObject *object)
+{
+//  GimpPopupButton *button = GIMP_POPUP_BUTTON (object);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gimp_popup_button_set_property (GObject      *object,
+                                   guint         property_id,
+                                   const GValue *value,
+                                   GParamSpec   *pspec)
+{
+  GimpPopupButton *button = GIMP_POPUP_BUTTON (object);
+
+  switch (property_id)
+    {
+   case PROP_POPUP_VIEW_SIZE:
+      gimp_popup_button_set_view_size (button, g_value_get_int (value));
+      break;
+   default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+static void
+gimp_popup_button_get_property (GObject    *object,
+                                   guint       property_id,
+                                   GValue     *value,
+                                   GParamSpec *pspec)
+{
+  GimpPopupButton *button = GIMP_POPUP_BUTTON (object);
+
+  switch (property_id)
+    {
+   case PROP_POPUP_VIEW_SIZE:
+      g_value_set_int (value, button->popup_view_size);
+      break;
+   default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+static gboolean
+gimp_popup_button_scroll_event (GtkWidget      *widget,
+                                GdkEventScroll *sevent)
+{
+  return TRUE;
+}
+
+static gboolean
+gimp_popup_button_button_press (GtkWidget      *widget,
+                                GdkEventButton *bevent)
+{
+  GtkButton       *button       = GTK_BUTTON (widget);
+  GimpPopupButton *popup_button = GIMP_POPUP_BUTTON (button);
+  GtkWidget       *popup;
+  GtkWidget       *view;
+  GtkWidget       *parent;
+  
+  view = gimp_popup_button_create_view (popup_button);
+  
+  g_return_val_if_fail (GTK_IS_WIDGET (view), FALSE );
+
+  popup = gimp_popup_new (view);
+
+  g_signal_connect (popup, "cancel",
+                    G_CALLBACK (gimp_popup_button_popup_closed),
+                    button);
+  g_signal_connect (popup, "confirm",
+                    G_CALLBACK (gimp_popup_button_popup_closed),
+                    button);
+
+  if (popup_button->parent)
+    parent = popup_button->parent;
+  else
+    parent = GTK_WIDGET (button);
+
+  gimp_popup_show_over_widget (GIMP_POPUP (popup), parent);
+  
+  return FALSE;
+}
+
+static void
+gimp_popup_button_popup_closed (GimpPopup *popup,
+                                   GimpPopupButton *button)
+{
+/*
+  gimp_popup_button_set_view_type (button,
+                                   gimp_popup_get_view_type (popup));
+  gimp_popup_button_set_view_size (button,
+                                   gimp_popup_get_view_size (popup));
+*/
+}
+
+
+/*  public functions  */
+
+GtkWidget *
+gimp_popup_button_new (GtkWidget *label)
+{
+  GimpPopupButton *button;
+
+  button = g_object_new (GIMP_TYPE_POPUP_BUTTON,
+                         NULL);
+
+  button->button_view_size  = 0;
+  button->view_border_width = 0;
+  button->parent            = NULL;
+
+  button->label = label;
+  gtk_container_add (GTK_CONTAINER (button), button->label);
+  gtk_widget_show (button->label);
+
+  return GTK_WIDGET (button);
+}
+
+GtkWidget *
+gimp_popup_button_new_with_parent (GtkWidget *label, GtkWidget *parent)
+{
+  GimpPopupButton *button = GIMP_POPUP_BUTTON (gimp_popup_button_new (label));
+  
+  button->parent          = GTK_WIDGET (parent);
+  return GTK_WIDGET (button);
+}
+
+gint
+gimp_popup_button_get_view_size (GimpPopupButton *button)
+{
+  g_return_val_if_fail (GIMP_IS_POPUP_BUTTON (button), GIMP_VIEW_SIZE_SMALL);
+
+  return button->popup_view_size;
+}
+
+void
+gimp_popup_button_set_view_size (GimpPopupButton *button,
+                                    gint                view_size)
+{
+  g_return_if_fail (GIMP_IS_POPUP_BUTTON (button));
+
+  if (view_size != button->popup_view_size)
+    {
+      button->popup_view_size = view_size;
+
+      g_object_notify (G_OBJECT (button), "popup-view-size");
+    }
+}
+
+GtkWidget*
+gimp_popup_button_create_view (GimpPopupButton *button)
+{
+  GtkWidget *result = NULL;
+  g_signal_emit (G_OBJECT(button), popup_button_signals[CREATE_VIEW], 0, &result, NULL);
+  
+  g_return_val_if_fail (GTK_IS_WIDGET (result), NULL);
+  
+  return result;
+}
+
diff -Naur gimp-2.8.14/app/widgets/gimppopupbutton.h gimp-2.8.14-new/app/widgets/gimppopupbutton.h
--- gimp-2.8.14/app/widgets/gimppopupbutton.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimppopupbutton.h	2015-01-27 17:48:55.409751577 +0800
@@ -0,0 +1,139 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimppopupbutton.h
+ * Copyright (C) 2003-2005 Michael Natterer <mitch@gimp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_POPUP_BUTTON_H__
+#define __GIMP_POPUP_BUTTON_H__
+#define __GIMP_WIDGETS_H_INSIDE__
+#define GIMP_WIDGETS_COMPILATION
+#include "libgimpwidgets/gimpbutton.h"
+
+
+#define GIMP_TYPE_POPUP            (gimp_popup_get_type ())
+#define GIMP_POPUP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_POPUP, GimpPopup))
+#define GIMP_POPUP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_POPUP, GimpPopupClass))
+#define GIMP_IS_POPUP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_POPUP))
+#define GIMP_IS_POPUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_POPUP))
+#define GIMP_POPUP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_POPUP, GimpPopupClass))
+
+
+typedef struct _GimpPopupClass  GimpPopupClass;
+typedef struct _GimpPopup       GimpPopup;
+
+struct _GimpPopup
+{
+  GtkWindow            parent_instance;
+/*
+  GimpContainer       *container;
+  GimpContext         *orig_context;
+  GimpContext         *context;
+
+  GimpViewType         view_type;
+*/
+  gint                 default_view_size;
+  gint                 view_size;
+  gint                 view_border_width;
+
+  GtkWidget           *frame;
+  GtkWidget           *view;
+/*
+  GimpContainerEditor *editor;
+
+  GimpDialogFactory   *dialog_factory;
+  gchar               *dialog_identifier;
+  gchar               *dialog_stock_id;
+  gchar               *dialog_tooltip;
+*/
+};
+
+struct _GimpPopupClass
+{
+  GtkWindowClass  parent_instance;
+
+  void (* cancel)  (GimpPopup *popup);
+  void (* confirm) (GimpPopup *popup);
+};
+
+
+GType       gimp_popup_get_type (void) G_GNUC_CONST;
+
+GtkWidget * gimp_popup_new      (GtkWidget *view);
+void gimp_popup_close (GimpPopup *popup);
+void gimp_popup_show (GimpPopup *popup, GdkScreen *screen,
+                       gint targetLeft, gint targetTop,
+                       gint targetRight, gint targetBottom,
+                       GtkCornerType pos);
+void        gimp_popup_show_over_widget (GimpPopup *popup,
+                                          GtkWidget          *widget);
+
+gint     gimp_popup_get_view_size (GimpPopup *popup);
+void    gimp_popup_set_view_size (GimpPopup *popup,
+                                   gint       view_size);
+void     gimp_popup_set_view  (GimpPopup *popup, GtkWidget *widget);
+
+
+
+G_BEGIN_DECLS
+
+#define GIMP_TYPE_POPUP_BUTTON            (gimp_popup_button_get_type ())
+#define GIMP_POPUP_BUTTON(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_POPUP_BUTTON, GimpPopupButton))
+#define GIMP_POPUP_BUTTON_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_POPUP_BUTTON, GimpPopupButtonClass))
+#define GIMP_IS_POPUP_BUTTON(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_POPUP_BUTTON))
+#define GIMP_IS_POPUP_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_POPUP_BUTTON))
+#define GIMP_POPUP_BUTTON_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_POPUP_BUTTON, GimpPopupButtonClass))
+
+
+typedef struct _GimpPopupButtonClass GimpPopupButtonClass;
+typedef struct _GimpPopupButton      GimpPopupButton;
+
+struct _GimpPopupButton
+{
+  GimpButton         parent_instance;
+
+  GimpViewType       popup_view_type;
+  gint               popup_view_size;
+
+  gint               button_view_size;
+  gint               view_border_width;
+
+  GtkWidget         *label;
+  GtkWidget         *parent;
+};
+
+struct _GimpPopupButtonClass
+{
+  GimpButtonClass  parent_class;
+};
+
+GType       gimp_popup_button_get_type (void) G_GNUC_CONST;
+
+GtkWidget * gimp_popup_button_new             (GtkWidget *label);
+GtkWidget * gimp_popup_button_new_with_parent (GtkWidget *label, GtkWidget *parent);
+
+gint         gimp_popup_button_get_view_size (GimpPopupButton *button);
+void         gimp_popup_button_set_view_size (GimpPopupButton *button,
+                                                 gint                view_size);
+GtkWidget* gimp_popup_button_create_view (GimpPopupButton *button);
+
+G_END_DECLS
+
+#undef __GIMP_WIDGETS_H_INSIDE__
+#undef GIMP_WIDGETS_COMPILATION
+
+#endif  /*  __GIMP_POPUP_BUTTON_H__  */
diff -Naur gimp-2.8.14/app/widgets/gimpsessioninfo-dock.c gimp-2.8.14-new/app/widgets/gimpsessioninfo-dock.c
--- gimp-2.8.14/app/widgets/gimpsessioninfo-dock.c	2015-01-27 17:28:36.937833806 +0800
+++ gimp-2.8.14-new/app/widgets/gimpsessioninfo-dock.c	2015-01-27 17:48:55.410751577 +0800
@@ -46,7 +46,8 @@
 {
   SESSION_INFO_SIDE,
   SESSION_INFO_POSITION,
-  SESSION_INFO_BOOK
+  SESSION_INFO_BOOK,
+  SESSION_INFO_SHADED,
 };
 
 
@@ -132,6 +133,8 @@
   for (list = dock_info->books; list; list = g_list_next (list))
     gimp_session_info_book_serialize (writer, list->data);
 
+  gimp_session_write_boolean (writer, "shaded", dock_info->shaded);
+
   gimp_config_writer_close (writer);
 }
 
@@ -152,6 +155,8 @@
                               GINT_TO_POINTER (SESSION_INFO_POSITION));
   g_scanner_scope_add_symbol (scanner, scope, "book",
                               GINT_TO_POINTER (SESSION_INFO_BOOK));
+  g_scanner_scope_add_symbol (scanner, scope, "shaded",
+                              GINT_TO_POINTER (SESSION_INFO_SHADED));
 
   *dock_info = gimp_session_info_dock_new (dock_type);
 
@@ -206,6 +211,12 @@
 
               break;
 
+            case SESSION_INFO_SHADED:
+              token = G_TOKEN_IDENTIFIER;
+              if (! gimp_scanner_parse_boolean (scanner, &((*dock_info)->shaded)))
+                (*dock_info)->shaded = FALSE;
+              break;
+
             default:
               return token;
             }
@@ -224,6 +235,7 @@
   g_scanner_scope_remove_symbol (scanner, scope, "book");
   g_scanner_scope_remove_symbol (scanner, scope, "position");
   g_scanner_scope_remove_symbol (scanner, scope, "side");
+  g_scanner_scope_remove_symbol (scanner, scope, "shaded");
 
   return token;
 }
@@ -252,6 +264,7 @@
 
   dock_info->books = g_list_reverse (dock_info->books);
   dock_info->side  = gimp_session_info_dock_get_side (dock);
+  dock_info->shaded = gimp_dock_is_shaded (dock);
 
   parent = gtk_widget_get_parent (GTK_WIDGET (dock));
 
@@ -365,6 +378,8 @@
       return NULL;
     }
 
+  gimp_dock_set_shaded (GIMP_DOCK (dock), dock_info->shaded);
+
   gtk_widget_show (dock);
 
   return GIMP_DOCK (dock);
diff -Naur gimp-2.8.14/app/widgets/gimpsessioninfo-dock.h gimp-2.8.14-new/app/widgets/gimpsessioninfo-dock.h
--- gimp-2.8.14/app/widgets/gimpsessioninfo-dock.h	2015-01-27 17:28:36.942833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpsessioninfo-dock.h	2015-01-27 17:48:55.410751577 +0800
@@ -44,6 +44,9 @@
 
   /*  list of GimpSessionInfoBook  */
   GList             *books;
+
+  /* dock is shaded or not */
+  gboolean           shaded;
 };
 
 GimpSessionInfoDock * gimp_session_info_dock_new         (const gchar          *dock_type);
diff -Naur gimp-2.8.14/app/widgets/gimptitlebaricon-pixbuf.h gimp-2.8.14-new/app/widgets/gimptitlebaricon-pixbuf.h
--- gimp-2.8.14/app/widgets/gimptitlebaricon-pixbuf.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimptitlebaricon-pixbuf.h	2015-01-27 17:48:55.410751577 +0800
@@ -0,0 +1,52 @@
+#ifndef __GIMPTITLEBARICON_PIXBUF_H__
+#define __GIMPTITLEBARICON_PIXBUF_H__
+/* GdkPixbuf RGBA C-Source image dump 1-byte-run-length-encoded */
+
+static const GdkPixdata gimp_dock_titlebar_minimize = {
+  0x47646b50, /* Pixbuf magic: 'GdkP' */
+  24 + 25, /* header length + pixel_data length */
+  0x2010002, /* pixdata_type */
+  64, /* rowstride */
+  16, /* width */
+  16, /* height */
+  /* pixel_data: */
+  "\364\0\0\0\0\210iii\377\210\0\0\0\0\210iii\377\364\0\0\0\0",
+};
+
+
+/* GdkPixbuf RGBA C-Source image dump 1-byte-run-length-encoded */
+
+static const GdkPixdata gimp_dock_titlebar_maximize = {
+  0x47646b50, /* Pixbuf magic: 'GdkP' */
+  24 + 85, /* header length + pixel_data length */
+  0x2010002, /* pixdata_type */
+  64, /* rowstride */
+  16, /* width */
+  16, /* height */
+  /* pixel_data: */
+  "\307\0\0\0\0\202iii\377\216\0\0\0\0\202iii\377\216\0\0\0\0\202iii\377"
+  "\213\0\0\0\0\210iii\377\210\0\0\0\0\210iii\377\213\0\0\0\0\202iii\377"
+  "\216\0\0\0\0\202iii\377\216\0\0\0\0\202iii\377\307\0\0\0\0",
+};
+
+
+/* GdkPixbuf RGBA C-Source image dump 1-byte-run-length-encoded */
+
+static const GdkPixdata gimp_dock_titlebar_close = {
+  0x47646b50, /* Pixbuf magic: 'GdkP' */
+  24 + 155, /* header length + pixel_data length */
+  0x2010002, /* pixdata_type */
+  64, /* rowstride */
+  16, /* width */
+  16, /* height */
+  /* pixel_data: */
+  "\303\0\0\0\0\202iii\377\205\0\0\0\0\202iii\377\207\0\0\0\0\203iii\377"
+  "\203\0\0\0\0\203iii\377\210\0\0\0\0\203iii\377\1\0\0\0\0\203iii\377\212"
+  "\0\0\0\0\205iii\377\214\0\0\0\0\203iii\377\214\0\0\0\0\205iii\377\212"
+  "\0\0\0\0\203iii\377\1\0\0\0\0\203iii\377\210\0\0\0\0\203iii\377\203\0"
+  "\0\0\0\203iii\377\207\0\0\0\0\202iii\377\205\0\0\0\0\202iii\377\264\0"
+  "\0\0\0",
+};
+
+#endif
+
diff -Naur gimp-2.8.14/app/widgets/gimptooloptionstoolbar.c gimp-2.8.14-new/app/widgets/gimptooloptionstoolbar.c
--- gimp-2.8.14/app/widgets/gimptooloptionstoolbar.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimptooloptionstoolbar.c	2015-01-27 17:48:55.410751577 +0800
@@ -0,0 +1,383 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * GimpToolOptionsToolbar.c
+ * Copyright (C) 2003 Michael Natterer <mitch@gimp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+
+#include "libgimpwidgets/gimpwidgets.h"
+
+#include "widgets-types.h"
+
+#include "core/gimp.h"
+#include "core/gimpcontext.h"
+#include "core/gimplist.h"
+#include "core/gimptoolinfo.h"
+#include "core/gimptooloptions.h"
+#include "core/gimptoolpreset.h"
+
+#include "gimpdnd.h"
+#include "gimpdocked.h"
+#include "gimphelp-ids.h"
+#include "gimpmenufactory.h"
+#include "gimppropwidgets.h"
+#include "gimpview.h"
+#include "gimpviewrenderer.h"
+#include "gimptooloptionstoolbar.h"
+#include "gimpuimanager.h"
+#include "gimpwidgets-utils.h"
+
+#include "gimp-intl.h"
+
+enum
+{
+  PROP_0,
+  PROP_GIMP,
+};
+
+struct _GimpToolOptionsToolbarPrivate
+{
+  Gimp            *gimp;
+
+  GimpToolOptions *visible_tool_options;
+  
+  GtkWidget *scrolled_window;
+  GtkWidget *view;
+  GtkWidget *options_hbox;
+
+};
+
+
+static GObject   * gimp_tool_options_toolbar_constructor       (GType                  type,
+                                                               guint                  n_params,
+                                                               GObjectConstructParam *params);
+static void        gimp_tool_options_toolbar_dispose           (GObject               *object);
+static void        gimp_tool_options_toolbar_set_property      (GObject               *object,
+                                                               guint                  property_id,
+                                                               const GValue          *value,
+                                                               GParamSpec            *pspec);
+static void        gimp_tool_options_toolbar_get_property      (GObject               *object,
+                                                               guint                  property_id,
+                                                               GValue                *value,
+                                                               GParamSpec            *pspec);
+
+static void        gimp_tool_options_toolbar_tool_changed      (GimpContext           *context,
+                                                               GimpToolInfo          *tool_info,
+                                                               GimpToolOptionsToolbar *toolbar);
+
+
+G_DEFINE_TYPE (GimpToolOptionsToolbar, gimp_tool_options_toolbar, GTK_TYPE_TOOLBAR)
+
+#define parent_class gimp_tool_options_toolbar_parent_class
+
+
+static void
+gimp_tool_options_toolbar_class_init (GimpToolOptionsToolbarClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->constructor  = gimp_tool_options_toolbar_constructor;
+  object_class->dispose      = gimp_tool_options_toolbar_dispose;
+  object_class->set_property = gimp_tool_options_toolbar_set_property;
+  object_class->get_property = gimp_tool_options_toolbar_get_property;
+
+  g_object_class_install_property (object_class, PROP_GIMP,
+                                   g_param_spec_object ("gimp",
+                                                        NULL, NULL,
+                                                        GIMP_TYPE_GIMP,
+                                                        GIMP_PARAM_READWRITE |
+                                                        G_PARAM_CONSTRUCT_ONLY));
+
+  g_type_class_add_private (klass, sizeof (GimpToolOptionsToolbarPrivate));
+}
+
+static void
+gimp_tool_options_toolbar_init (GimpToolOptionsToolbar *toolbar)
+{
+
+  toolbar->p = G_TYPE_INSTANCE_GET_PRIVATE (toolbar,
+                                            GIMP_TYPE_TOOL_OPTIONS_TOOLBAR,
+                                            GimpToolOptionsToolbarPrivate);
+                                           
+}
+
+static GObject *
+gimp_tool_options_toolbar_constructor (GType                  type,
+                                      guint                  n_params,
+                                      GObjectConstructParam *params)
+{
+  GObject               *object       = NULL;
+  GimpToolOptionsToolbar *toolbar       = NULL;
+  GimpContext           *user_context = NULL;
+  GtkToolItem *item;
+  GtkLayout     *scrolled_window;
+
+  object = G_OBJECT_CLASS (parent_class)->constructor (type, n_params, params);
+
+  toolbar = GIMP_TOOL_OPTIONS_TOOLBAR (object);
+
+  user_context = gimp_get_user_context (toolbar->p->gimp);
+
+
+  item = gtk_tool_item_new ();
+  gtk_tool_item_set_expand (GTK_TOOL_ITEM (item), TRUE);
+  toolbar->p->scrolled_window = gtk_layout_new (NULL, NULL);
+  scrolled_window             = GTK_LAYOUT (toolbar->p->scrolled_window);
+  gtk_widget_show (toolbar->p->scrolled_window);
+  
+  /*  The hbox containing the tool options  */
+  toolbar->p->options_hbox = gtk_hbox_new (FALSE, 6);
+  gtk_layout_put (scrolled_window, toolbar->p->options_hbox, 0, 0);
+  gtk_widget_show (toolbar->p->options_hbox);  
+  
+  /* The toolbar item containing scrolled_window */
+  gtk_container_add (GTK_CONTAINER (item), toolbar->p->scrolled_window);
+  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);
+  gtk_widget_show (GTK_WIDGET(item));
+
+
+  g_signal_connect_object (user_context, "tool-changed",
+                           G_CALLBACK (gimp_tool_options_toolbar_tool_changed),
+                           toolbar,
+                           0);
+
+  gimp_tool_options_toolbar_tool_changed (user_context,
+                                         gimp_context_get_tool (user_context),
+                                         toolbar);
+
+  return object;
+}
+
+static void
+gimp_tool_options_toolbar_dispose (GObject *object)
+{
+  GimpToolOptionsToolbar *toolbar = GIMP_TOOL_OPTIONS_TOOLBAR (object);
+  if (toolbar->p->options_hbox)
+    {
+      GList *options;
+      GList *list;
+
+      options =
+        gtk_container_get_children (GTK_CONTAINER (toolbar->p->options_hbox));
+
+      for (list = options; list; list = g_list_next (list))
+        {
+          g_object_ref (list->data);
+          gtk_container_remove (GTK_CONTAINER (toolbar->p->options_hbox),
+                                GTK_WIDGET (list->data));
+        }
+
+      g_list_free (options);
+      toolbar->p->options_hbox = NULL;
+    }
+
+/*
+  gimp_tool_options_toolbar_save_presets (toolbar);
+*/
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+gimp_tool_options_toolbar_set_property (GObject      *object,
+                                       guint         property_id,
+                                       const GValue *value,
+                                       GParamSpec   *pspec)
+{
+  GimpToolOptionsToolbar *toolbar = GIMP_TOOL_OPTIONS_TOOLBAR (object);
+
+  switch (property_id)
+    {
+    case PROP_GIMP:
+      toolbar->p->gimp = g_value_get_object (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+static void
+gimp_tool_options_toolbar_get_property (GObject    *object,
+                                       guint       property_id,
+                                       GValue     *value,
+                                       GParamSpec *pspec)
+{
+  GimpToolOptionsToolbar *toolbar = GIMP_TOOL_OPTIONS_TOOLBAR (object);
+
+  switch (property_id)
+    {
+    case PROP_GIMP:
+      g_value_set_object (value, toolbar->p->gimp);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+    }
+}
+
+#if 0
+static GtkWidget *
+gimp_tool_options_toolbar_get_preview (GimpDocked   *docked,
+                                      GimpContext  *context,
+                                      GtkIconSize   size)
+{
+  GtkSettings *settings = gtk_widget_get_settings (GTK_WIDGET (docked));
+  GtkWidget   *view;
+  gint         width;
+  gint         height;
+
+  gtk_icon_size_lookup_for_settings (settings, size, &width, &height);
+
+  view = gimp_prop_view_new (G_OBJECT (context), "tool", context, height);
+  GIMP_VIEW (view)->renderer->size = -1;
+  gimp_view_renderer_set_size_full (GIMP_VIEW (view)->renderer,
+                                    width, height, 0);
+
+  return view;
+}
+
+static gchar *
+gimp_tool_options_toolbar_get_title (GimpDocked *docked)
+{
+  GimpToolOptionsToolbar *toolbar = GIMP_TOOL_OPTIONS_TOOLBAR (docked);
+  GimpContext           *context;
+  GimpToolInfo          *tool_info;
+
+  context = gimp_get_user_context (toolbar->p->gimp);
+
+  tool_info = gimp_context_get_tool (context);
+
+  return tool_info ? g_strdup (tool_info->blurb) : NULL;
+}
+
+static gboolean
+gimp_tool_options_toolbar_get_prefer_icon (GimpDocked *docked)
+{
+  /* We support get_preview() for tab tyles, but we prefer to show our
+   * icon
+   */
+  return TRUE;
+}
+#endif
+
+/*  public functions  */
+
+GtkWidget *
+gimp_tool_options_toolbar_new (Gimp            *gimp,
+                              GimpMenuFactory *menu_factory)
+{
+  g_return_val_if_fail (GIMP_IS_GIMP (gimp), NULL);
+//  g_return_val_if_fail (GIMP_IS_MENU_FACTORY (menu_factory), NULL);
+
+  return g_object_new (GIMP_TYPE_TOOL_OPTIONS_TOOLBAR,
+                       "gimp",            gimp,
+//                       "menu-factory",    menu_factory,
+//                       "menu-identifier", "<ToolOptions>",
+//                       "ui-path",         "/tool-options-popup",
+                       NULL);
+}
+
+GimpToolOptions *
+gimp_tool_options_toolbar_get_tool_options (GimpToolOptionsToolbar *toolbar)
+{
+  g_return_val_if_fail (GIMP_IS_TOOL_OPTIONS_TOOLBAR (toolbar), NULL);
+
+  return toolbar->p->visible_tool_options;
+}
+
+/*  private functions  */
+#if 0
+static void
+gimp_tool_options_toolbar_menu_pos (GtkMenu  *menu,
+                                   gint     *x,
+                                   gint     *y,
+                                   gpointer  data)
+{
+  gimp_button_menu_position (GTK_WIDGET (data), menu, GTK_POS_RIGHT, x, y);
+}
+
+static void
+gimp_tool_options_toolbar_menu_popup (GimpToolOptionsToolbar *toolbar,
+                                     GtkWidget             *button,
+                                     const gchar           *path)
+{
+/*
+  GimpToolbar *GIMP_EDITOR = GIMP_EDITOR (toolbar);
+
+  gtk_ui_manager_get_widget (GTK_UI_MANAGER (GIMP_EDITOR->ui_manager),
+                             GIMP_EDITOR->ui_path);
+  gimp_ui_manager_update (GIMP_EDITOR->ui_manager, GIMP_EDITOR->popup_data);
+
+  gimp_ui_manager_ui_popup (GIMP_EDITOR->ui_manager, path,
+                            button,
+                            gimp_tool_options_toolbar_menu_pos, button,
+                            NULL, NULL);
+*/
+}
+#endif
+
+static void
+gimp_tool_options_toolbar_tool_changed (GimpContext           *context,
+                                       GimpToolInfo          *tool_info,
+                                       GimpToolOptionsToolbar *toolbar)
+{
+  GtkWidget       *options_gui;
+
+  if (tool_info && tool_info->tool_options == toolbar->p->visible_tool_options)
+    return;
+
+  if (toolbar->p->visible_tool_options)
+    {
+
+      options_gui = g_object_get_data (G_OBJECT (toolbar->p->visible_tool_options),
+                                       "gimp-tool-options-toolbar-gui");
+
+      if (options_gui)
+        gtk_widget_hide (options_gui);
+
+      toolbar->p->visible_tool_options = NULL;
+    }
+
+  if (tool_info && tool_info->tool_options)
+    {
+      GtkRequisition req;
+      
+      options_gui = g_object_get_data (G_OBJECT (tool_info->tool_options),
+                                       "gimp-tool-options-toolbar-gui");
+
+
+      if (! gtk_widget_get_parent (options_gui))
+        gtk_box_pack_start (GTK_BOX (toolbar->p->options_hbox), options_gui,
+                            TRUE, FALSE, 0);
+
+      gtk_widget_size_request (options_gui, &req);
+      gtk_widget_set_size_request (toolbar->p->scrolled_window, -1, req.height);
+      gtk_widget_show (options_gui);
+
+      toolbar->p->visible_tool_options = tool_info->tool_options;
+    }
+  else
+    {
+    }
+
+}
+
diff -Naur gimp-2.8.14/app/widgets/gimptooloptionstoolbar.h gimp-2.8.14-new/app/widgets/gimptooloptionstoolbar.h
--- gimp-2.8.14/app/widgets/gimptooloptionstoolbar.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/app/widgets/gimptooloptionstoolbar.h	2015-01-27 17:48:55.411751577 +0800
@@ -0,0 +1,58 @@
+/* GIMP - The GNU Image Manipulation Program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * gimptooloptionstoolbar.h
+ * Copyright (C) 2003 Michael Natterer <mitch@gimp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __GIMP_TOOL_OPTIONS_TOOLBAR_H__
+#define __GIMP_TOOL_OPTIONS_TOOLBAR_H__
+
+
+#include <gtk/gtk.h>
+#include "core/gimptooloptions.h"
+
+#define GIMP_TYPE_TOOL_OPTIONS_TOOLBAR            (gimp_tool_options_toolbar_get_type ())
+#define GIMP_TOOL_OPTIONS_TOOLBAR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOL_OPTIONS_TOOLBAR, GimpToolOptionsToolbar))
+#define GIMP_TOOL_OPTIONS_TOOLBAR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOL_OPTIONS_TOOLBAR, GimpToolOptionsToolbarClass))
+#define GIMP_IS_TOOL_OPTIONS_TOOLBAR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOL_OPTIONS_TOOLBAR))
+#define GIMP_IS_TOOL_OPTIONS_TOOLBAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOL_OPTIONS_TOOLBAR))
+#define GIMP_TOOL_OPTIONS_TOOLBAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOL_OPTIONS_TOOLBAR, GimpToolOptionsToolbarClass))
+
+typedef struct _GimpToolOptionsToolbar         GimpToolOptionsToolbar;
+typedef struct _GimpToolOptionsToolbarPrivate  GimpToolOptionsToolbarPrivate;
+typedef struct _GimpToolOptionsToolbarClass    GimpToolOptionsToolbarClass;
+
+struct _GimpToolOptionsToolbar
+{
+  GtkToolbar                    parent_instance;
+
+  GimpToolOptionsToolbarPrivate *p;
+};
+
+struct _GimpToolOptionsToolbarClass
+{
+  GtkToolbarClass  parent_class;
+};
+
+
+GType             gimp_tool_options_toolbar_get_type         (void) G_GNUC_CONST;
+GtkWidget       * gimp_tool_options_toolbar_new              (Gimp                  *gimp,
+                                                             GimpMenuFactory       *menu_factory);
+GimpToolOptions * gimp_tool_options_toolbar_get_tool_options (GimpToolOptionsToolbar *toolbar);
+
+
+#endif  /*  __GIMP_TOOL_OPTIONS_TOOLBAR_H__  */
diff -Naur gimp-2.8.14/app/widgets/gimpwidgets-constructors.c gimp-2.8.14-new/app/widgets/gimpwidgets-constructors.c
--- gimp-2.8.14/app/widgets/gimpwidgets-constructors.c	2015-01-27 17:28:36.936833806 +0800
+++ gimp-2.8.14-new/app/widgets/gimpwidgets-constructors.c	2015-01-27 17:48:55.411751577 +0800
@@ -102,7 +102,7 @@
   GtkWidget    *combo;
 
   store = gimp_enum_store_new_with_values (GIMP_TYPE_LAYER_MODE_EFFECTS,
-                                           21,
+                                           25,
                                            GIMP_NORMAL_MODE,
                                            GIMP_DISSOLVE_MODE,
 
@@ -128,7 +128,12 @@
                                            GIMP_HUE_MODE,
                                            GIMP_SATURATION_MODE,
                                            GIMP_COLOR_MODE,
-                                           GIMP_VALUE_MODE);
+                                           GIMP_VALUE_MODE,
+
+                                           GIMP_SRC_IN_MODE,
+                                           GIMP_DST_IN_MODE,
+                                           GIMP_SRC_OUT_MODE,
+                                           GIMP_DST_OUT_MODE);
 
   gimp_int_store_insert_separator_after (GIMP_INT_STORE (store),
                                          GIMP_DISSOLVE_MODE, -1);
@@ -145,6 +150,9 @@
   gimp_int_store_insert_separator_after (GIMP_INT_STORE (store),
                                          GIMP_DIVIDE_MODE, -1);
 
+  gimp_int_store_insert_separator_after (GIMP_INT_STORE (store),
+                                         GIMP_VALUE_MODE, -1);
+
   if (with_behind_mode)
     {
       gimp_enum_store_insert_value_after (GIMP_ENUM_STORE (store),
diff -Naur gimp-2.8.14/app/widgets/gimpwidgets-utils.c gimp-2.8.14-new/app/widgets/gimpwidgets-utils.c
--- gimp-2.8.14/app/widgets/gimpwidgets-utils.c	2015-01-27 17:28:36.947833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpwidgets-utils.c	2015-01-27 17:48:55.411751577 +0800
@@ -1327,3 +1327,19 @@
 
   g_type_class_unref (klass);
 }
+
+void
+gimp_session_write_boolean (GimpConfigWriter *writer,
+                            gchar            *name,
+                            gboolean          value)
+{
+  GimpSessionInfoClass *klass;
+
+  klass = g_type_class_ref (GIMP_TYPE_SESSION_INFO);
+
+  gimp_config_writer_open (writer, name);
+  gimp_config_writer_printf (writer, "%s", value ? "true":"false");
+  gimp_config_writer_close (writer);
+
+  g_type_class_unref (klass);
+}
diff -Naur gimp-2.8.14/app/widgets/gimpwidgets-utils.h gimp-2.8.14-new/app/widgets/gimpwidgets-utils.h
--- gimp-2.8.14/app/widgets/gimpwidgets-utils.h	2015-01-27 17:28:36.949833805 +0800
+++ gimp-2.8.14-new/app/widgets/gimpwidgets-utils.h	2015-01-27 17:48:55.412751577 +0800
@@ -100,6 +100,10 @@
 const gchar     * gimp_print_event                 (const GdkEvent       *event);
 void              gimp_session_write_position      (GimpConfigWriter     *writer,
                                                     gint                  position);
+void              gimp_session_write_boolean       (GimpConfigWriter     *writer,
+                                                    gchar                *name,
+                                                    gboolean              value);
+
 
 
 #endif /* __GIMP_WIDGETS_UTILS_H__ */
diff -Naur gimp-2.8.14/app/widgets/Makefile.am gimp-2.8.14-new/app/widgets/Makefile.am
--- gimp-2.8.14/app/widgets/Makefile.am	2015-01-27 17:28:36.952833805 +0800
+++ gimp-2.8.14-new/app/widgets/Makefile.am	2015-01-27 17:48:55.401751578 +0800
@@ -42,6 +42,10 @@
 	gimpbrushfactoryview.h		\
 	gimpbrushselect.c		\
 	gimpbrushselect.h		\
+	gimpmypaintbrushfactoryview.c	\
+	gimpmypaintbrushfactoryview.h	\
+	gimpmypaintbrushselect.c	\
+	gimpmypaintbrushselect.h	\
 	gimpbufferview.c		\
 	gimpbufferview.h		\
 	gimpcairo.c			\
@@ -270,6 +274,8 @@
 	gimppixbuf.h			\
 	gimppluginaction.c		\
 	gimppluginaction.h		\
+	gimppopupbutton.c		\
+	gimppopupbutton.h		\
 	gimpprofilechooserdialog.c	\
 	gimpprofilechooserdialog.h	\
 	gimpprogressbox.c		\
@@ -337,6 +343,7 @@
 	gimptexttag.h			\
 	gimpthumbbox.c			\
 	gimpthumbbox.h			\
+  gimptitlebaricon-pixbuf.h \
 	gimptoggleaction.c		\
 	gimptoggleaction.h		\
 	gimptoolbox.c			\
@@ -355,6 +362,8 @@
 	gimptooloptionseditor.h		\
 	gimptoolpalette.c		\
 	gimptoolpalette.h		\
+	gimptooloptionstoolbar.c	\
+	gimptooloptionstoolbar.h	\
 	gimptoolpreseteditor.c		\
 	gimptoolpreseteditor.h		\
 	gimptoolpresetfactoryview.c	\
@@ -412,7 +421,9 @@
 	gtkwrapbox.c			\
 	gtkwrapbox.h			\
 	gtkhwrapbox.c			\
-	gtkhwrapbox.h
+	gtkhwrapbox.h		\
+	gimpmypaintbrusheditor.cpp		\
+	gimpmypaintbrusheditor.h
 
 libappwidgets_a_built_sources = widgets-enums.c
 
@@ -439,4 +450,4 @@
 		--dtail "    { 0, NULL, NULL }\n  };\n\n  static GType type = 0;\n\n  if (G_UNLIKELY (! type))\n    {\n      type = g_@type@_register_static (\"@EnumName@\", values);\n      gimp_type_set_translation_context (type, \"@enumnick@\");\n      gimp_@type@_set_value_descriptions (type, descs);\n    }\n\n  return type;\n}\n" \
 		$(srcdir)/widgets-enums.h > xgen-wec \
 	&& cp xgen-wec $(@F) \
-	&& rm -f xgen-wec
\ No newline at end of file
+	&& rm -f xgen-wec
diff -Naur gimp-2.8.14/app/widgets/widgets-types.h gimp-2.8.14-new/app/widgets/widgets-types.h
--- gimp-2.8.14/app/widgets/widgets-types.h	2015-01-27 17:28:36.932833806 +0800
+++ gimp-2.8.14-new/app/widgets/widgets-types.h	2015-01-27 17:48:55.412751577 +0800
@@ -58,7 +58,6 @@
 typedef struct _GimpErrorConsole             GimpErrorConsole;
 typedef struct _GimpToolOptionsEditor        GimpToolOptionsEditor;
 
-
 /*  GimpDataEditor widgets  */
 
 typedef struct _GimpBrushEditor              GimpBrushEditor;
@@ -67,6 +66,7 @@
 typedef struct _GimpGradientEditor           GimpGradientEditor;
 typedef struct _GimpPaletteEditor            GimpPaletteEditor;
 typedef struct _GimpToolPresetEditor         GimpToolPresetEditor;
+typedef struct _GimpMypaintBrushEditor       GimpMypaintBrushEditor;
 
 /*  GimpImageEditor widgets  */
 
@@ -117,6 +117,7 @@
 typedef struct _GimpDynamicsFactoryView      GimpDynamicsFactoryView;
 typedef struct _GimpPatternFactoryView       GimpPatternFactoryView;
 typedef struct _GimpToolPresetFactoryView    GimpToolPresetFactoryView;
+typedef struct _GimpMypaintBrushFactoryView  GimpMypaintBrushFactoryView;
 
 /*  menus  */
 
@@ -150,6 +151,7 @@
 typedef struct _GimpPaletteSelect            GimpPaletteSelect;
 typedef struct _GimpPatternSelect            GimpPatternSelect;
 typedef struct _GimpPdbDialog                GimpPdbDialog;
+typedef struct _GimpMypaintBrushSelect       GimpMypaintBrushSelect;
 
 
 /*  misc widgets  */
diff -Naur gimp-2.8.14/app/xcf/xcf-save.c gimp-2.8.14-new/app/xcf/xcf-save.c
--- gimp-2.8.14/app/xcf/xcf-save.c	2015-01-27 17:28:36.752833818 +0800
+++ gimp-2.8.14-new/app/xcf/xcf-save.c	2015-01-27 17:48:55.412751577 +0800
@@ -212,7 +212,7 @@
     save_version = 1;
 
   for (list = gimp_image_get_layer_iter (image);
-       list && save_version < 3;
+       list && save_version < 4;
        list = g_list_next (list))
     {
       GimpLayer *layer = GIMP_LAYER (list->data);
@@ -227,6 +227,13 @@
           save_version = MAX (2, save_version);
           break;
 
+        case GIMP_SRC_IN_MODE:
+        case GIMP_DST_IN_MODE:
+        case GIMP_SRC_OUT_MODE:
+        case GIMP_DST_OUT_MODE:
+          save_version = MAX (4, save_version);
+          break;
+
         default:
           break;
         }
diff -Naur gimp-2.8.14/configure.ac gimp-2.8.14-new/configure.ac
--- gimp-2.8.14/configure.ac	2015-01-27 17:28:36.980833803 +0800
+++ gimp-2.8.14-new/configure.ac	2015-01-27 17:48:55.413751577 +0800
@@ -163,6 +163,10 @@
 AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE, "$GETTEXT_PACKAGE",
                    [The prefix for our gettext translation domains.])
 
+# Determine a CXX compiler to use
+AC_PROG_CXX
+AC_PROG_CXX_C_O
+
 # Determine a C compiler to use
 AC_PROG_CC
 AM_PROG_CC_C_O
@@ -2409,6 +2413,12 @@
 data/tool-presets/Paint/Makefile
 data/tool-presets/Selection/Makefile
 data/tool-presets/Sketch/Makefile
+data/mypaint-brushes/Makefile
+data/mypaint-brushes/classic/Makefile
+data/mypaint-brushes/deevad/Makefile
+data/mypaint-brushes/tanda/Makefile
+data/mypaint-brushes/ramon/Makefile
+data/mypaint-brushes/experimental/Makefile
 desktop/Makefile
 desktop/gimp.desktop.in
 etc/Makefile
diff -Naur gimp-2.8.14/data/Makefile.am gimp-2.8.14-new/data/Makefile.am
--- gimp-2.8.14/data/Makefile.am	2015-01-27 17:28:37.401833774 +0800
+++ gimp-2.8.14-new/data/Makefile.am	2015-01-27 17:48:55.413751577 +0800
@@ -11,7 +11,8 @@
 	patterns	\
 	tips		\
 	tags		\
-	tool-presets
+	tool-presets	\
+	mypaint-brushes
 
 fontdir = $(gimpdatadir)/fonts
 
diff -Naur gimp-2.8.14/libgimp/gimpenums.c.tail gimp-2.8.14-new/libgimp/gimpenums.c.tail
--- gimp-2.8.14/libgimp/gimpenums.c.tail	2015-01-27 17:28:36.518833834 +0800
+++ gimp-2.8.14-new/libgimp/gimpenums.c.tail	2015-01-27 17:48:55.460751574 +0800
@@ -34,6 +34,7 @@
   gimp_mask_apply_mode_get_type,
   gimp_merge_type_get_type,
   gimp_message_handler_type_get_type,
+  gimp_mypaint_brush_mode_get_type,
   gimp_offset_type_get_type,
   gimp_orientation_type_get_type,
   gimp_pdb_arg_type_get_type,
@@ -91,6 +92,7 @@
   "GimpMaskApplyMode",
   "GimpMergeType",
   "GimpMessageHandlerType",
+  "GimpMypaintBrushMode",
   "GimpOffsetType",
   "GimpOrientationType",
   "GimpPDBArgType",
diff -Naur gimp-2.8.14/libgimp/gimpenums.h gimp-2.8.14-new/libgimp/gimpenums.h
--- gimp-2.8.14/libgimp/gimpenums.h	2015-01-27 17:28:36.529833833 +0800
+++ gimp-2.8.14-new/libgimp/gimpenums.h	2015-01-27 17:48:55.460751574 +0800
@@ -207,7 +207,11 @@
   GIMP_SOFTLIGHT_MODE,
   GIMP_GRAIN_EXTRACT_MODE,
   GIMP_GRAIN_MERGE_MODE,
-  GIMP_COLOR_ERASE_MODE
+  GIMP_COLOR_ERASE_MODE,
+  GIMP_SRC_IN_MODE,
+  GIMP_DST_IN_MODE,
+  GIMP_SRC_OUT_MODE,
+  GIMP_DST_OUT_MODE
 } GimpLayerModeEffects;
 
 
diff -Naur gimp-2.8.14/libgimp/gimpmypaintbrushselect_pdb.c gimp-2.8.14-new/libgimp/gimpmypaintbrushselect_pdb.c
--- gimp-2.8.14/libgimp/gimpmypaintbrushselect_pdb.c	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/libgimp/gimpmypaintbrushselect_pdb.c	2015-01-27 17:48:55.460751574 +0800
@@ -0,0 +1,131 @@
+/* LIBGIMP - The GIMP Library
+ * Copyright (C) 1995-2003 Peter Mattis and Spencer Kimball
+ *
+ * gimpmypaintbrushselect_pdb.c
+ *
+ * This library is free software: you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+/* NOTE: This file is auto-generated by pdbgen.pl */
+
+#include "config.h"
+
+#include "gimp.h"
+
+
+/**
+ * SECTION: gimpmypaintbrushselect
+ * @title: gimpmypaintbrushselect
+ * @short_description: Functions providing a mypaint brush selection dialog.
+ *
+ * Functions providing a mypaint brush selection dialog.
+ **/
+
+
+/**
+ * gimp_mypaint_brushes_popup:
+ * @mypaint_brush_callback: The callback PDB proc to call when mypaint brush selection is made.
+ * @popup_title: Title of the mypaint brush selection dialog.
+ * @initial_brush: The name of the mypaint brush to set as the first selected.
+ *
+ * Invokes the Gimp mypaint brush selection.
+ *
+ * This procedure opens the mypaint brush selection dialog.
+ *
+ * Returns: TRUE on success.
+ **/
+gboolean
+gimp_mypaint_brushes_popup (const gchar *mypaint_brush_callback,
+                            const gchar *popup_title,
+                            const gchar *initial_brush)
+{
+  GimpParam *return_vals;
+  gint nreturn_vals;
+  gboolean success = TRUE;
+
+  return_vals = gimp_run_procedure ("gimp-mypaint-brushes-popup",
+                                    &nreturn_vals,
+                                    GIMP_PDB_STRING, mypaint_brush_callback,
+                                    GIMP_PDB_STRING, popup_title,
+                                    GIMP_PDB_STRING, initial_brush,
+                                    GIMP_PDB_END);
+
+  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;
+
+  gimp_destroy_params (return_vals, nreturn_vals);
+
+  return success;
+}
+
+/**
+ * gimp_mypaint_brushes_close_popup:
+ * @mypaint_brush_callback: The name of the callback registered for this pop-up.
+ *
+ * Close the mypaint brush selection dialog.
+ *
+ * This procedure closes an opened brush selection dialog.
+ *
+ * Returns: TRUE on success.
+ **/
+gboolean
+gimp_mypaint_brushes_close_popup (const gchar *mypaint_brush_callback)
+{
+  GimpParam *return_vals;
+  gint nreturn_vals;
+  gboolean success = TRUE;
+
+  return_vals = gimp_run_procedure ("gimp-mypaint-brushes-close-popup",
+                                    &nreturn_vals,
+                                    GIMP_PDB_STRING, mypaint_brush_callback,
+                                    GIMP_PDB_END);
+
+  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;
+
+  gimp_destroy_params (return_vals, nreturn_vals);
+
+  return success;
+}
+
+/**
+ * gimp_mypaint_brushes_set_popup:
+ * @mypaint_brush_callback: The name of the callback registered for this pop-up.
+ * @mypaint_brush_name: The name of the brush to set as selected.
+ *
+ * Sets the current mypaint brush in a mypaint brush selection dialog.
+ *
+ * Sets the current mypaint brush in a mypaint brush selection dialog.
+ *
+ * Returns: TRUE on success.
+ **/
+gboolean
+gimp_mypaint_brushes_set_popup (const gchar *mypaint_brush_callback,
+                                const gchar *mypaint_brush_name)
+{
+  GimpParam *return_vals;
+  gint nreturn_vals;
+  gboolean success = TRUE;
+
+  return_vals = gimp_run_procedure ("gimp-mypaint-brushes-set-popup",
+                                    &nreturn_vals,
+                                    GIMP_PDB_STRING, mypaint_brush_callback,
+                                    GIMP_PDB_STRING, mypaint_brush_name,
+                                    GIMP_PDB_END);
+
+  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;
+
+  gimp_destroy_params (return_vals, nreturn_vals);
+
+  return success;
+}
diff -Naur gimp-2.8.14/libgimp/gimpmypaintbrushselect_pdb.h gimp-2.8.14-new/libgimp/gimpmypaintbrushselect_pdb.h
--- gimp-2.8.14/libgimp/gimpmypaintbrushselect_pdb.h	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/libgimp/gimpmypaintbrushselect_pdb.h	2015-01-27 17:48:55.461751574 +0800
@@ -0,0 +1,45 @@
+/* LIBGIMP - The GIMP Library
+ * Copyright (C) 1995-2003 Peter Mattis and Spencer Kimball
+ *
+ * gimpmypaintbrushselect_pdb.h
+ *
+ * This library is free software: you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+/* NOTE: This file is auto-generated by pdbgen.pl */
+
+#if !defined (__GIMP_H_INSIDE__) && !defined (GIMP_COMPILATION)
+#error "Only <libgimp/gimp.h> can be included directly."
+#endif
+
+#ifndef __GIMP_MYPAINT_BRUSH_SELECT_PDB_H__
+#define __GIMP_MYPAINT_BRUSH_SELECT_PDB_H__
+
+G_BEGIN_DECLS
+
+/* For information look into the C source or the html documentation */
+
+
+gboolean gimp_mypaint_brushes_popup       (const gchar *mypaint_brush_callback,
+                                           const gchar *popup_title,
+                                           const gchar *initial_brush);
+gboolean gimp_mypaint_brushes_close_popup (const gchar *mypaint_brush_callback);
+gboolean gimp_mypaint_brushes_set_popup   (const gchar *mypaint_brush_callback,
+                                           const gchar *mypaint_brush_name);
+
+
+G_END_DECLS
+
+#endif /* __GIMP_MYPAINT_BRUSH_SELECT_PDB_H__ */
diff -Naur gimp-2.8.14/libgimp/gimp_pdb_headers.h gimp-2.8.14-new/libgimp/gimp_pdb_headers.h
--- gimp-2.8.14/libgimp/gimp_pdb_headers.h	2015-01-27 17:28:36.519833834 +0800
+++ gimp-2.8.14-new/libgimp/gimp_pdb_headers.h	2015-01-27 17:48:55.460751574 +0800
@@ -58,6 +58,7 @@
 #include <libgimp/gimpitemtransform_pdb.h>
 #include <libgimp/gimplayer_pdb.h>
 #include <libgimp/gimpmessage_pdb.h>
+#include <libgimp/gimpmypaintbrushselect_pdb.h>
 #include <libgimp/gimppainttools_pdb.h>
 #include <libgimp/gimppalette_pdb.h>
 #include <libgimp/gimppalettes_pdb.h>
diff -Naur gimp-2.8.14/libgimpbase/gimpbaseenums.c gimp-2.8.14-new/libgimpbase/gimpbaseenums.c
--- gimp-2.8.14/libgimpbase/gimpbaseenums.c	2015-01-27 17:28:37.063833797 +0800
+++ gimp-2.8.14-new/libgimpbase/gimpbaseenums.c	2015-01-27 17:48:55.461751574 +0800
@@ -1258,6 +1258,40 @@
   return type;
 }
 
+GType
+gimp_mypaint_brush_mode_get_type (void)
+{
+  static const GEnumValue values[] =
+  {
+    { GIMP_MYPAINT_NORMAL, "GIMP_MYPAINT_NORMAL", "normal" },
+    { GIMP_MYPAINT_NORMAL_AND_ERASE, "GIMP_MYPAINT_NORMAL_AND_ERASE", "normal-and-erase" },
+    { GIMP_MYPAINT_LOCK_ALPHA, "GIMP_MYPAINT_LOCK_ALPHA", "lock-alpha" },
+    { GIMP_MYPAINT_COLORIZE, "GIMP_MYPAINT_COLORIZE", "colorize" },
+    { 0, NULL, NULL }
+  };
+
+  static const GimpEnumDesc descs[] =
+  {
+    { GIMP_MYPAINT_NORMAL, NC_("mypaint-brush-mode", "Normal"), NULL },
+    { GIMP_MYPAINT_NORMAL_AND_ERASE, NC_("mypaint-brush-mode", "Normal and Erase"), NULL },
+    { GIMP_MYPAINT_LOCK_ALPHA, NC_("mypaint-brush-mode", "Lock Alpha"), NULL },
+    { GIMP_MYPAINT_COLORIZE, NC_("mypaint-brush-mode", "Colorize"), NULL },
+    { 0, NULL, NULL }
+  };
+
+  static GType type = 0;
+
+  if (G_UNLIKELY (! type))
+    {
+      type = g_enum_register_static ("GimpMypaintBrushMode", values);
+      gimp_type_set_translation_domain (type, GETTEXT_PACKAGE "-libgimp");
+      gimp_type_set_translation_context (type, "mypaint-brush-mode");
+      gimp_enum_set_value_descriptions (type, descs);
+    }
+
+  return type;
+}
+
 
 /* Generated data ends here */
 
diff -Naur gimp-2.8.14/libgimpbase/gimpbaseenums.h gimp-2.8.14-new/libgimpbase/gimpbaseenums.h
--- gimp-2.8.14/libgimpbase/gimpbaseenums.h	2015-01-27 17:28:37.067833797 +0800
+++ gimp-2.8.14-new/libgimpbase/gimpbaseenums.h	2015-01-27 17:48:55.461751574 +0800
@@ -536,6 +536,20 @@
   GIMP_VECTORS_STROKE_TYPE_BEZIER
 } GimpVectorsStrokeType;
 
+
+#define GIMP_TYPE_MYPAINT_BRUSH_MODE (gimp_mypaint_brush_mode_get_type ())
+
+GType gimp_mypaint_brush_mode_get_type (void) G_GNUC_CONST;
+
+typedef enum
+{
+  GIMP_MYPAINT_NORMAL,            /*< desc="Normal"    >*/
+  GIMP_MYPAINT_NORMAL_AND_ERASE,  /*< desc="Normal and Erase" >*/
+  GIMP_MYPAINT_LOCK_ALPHA,        /*< desc="Lock Alpha">*/
+  GIMP_MYPAINT_COLORIZE,	  /*< desc="Colorize">*/
+} GimpMypaintBrushMode;
+
+
 G_END_DECLS
 
 #endif  /* __GIMP_BASE_ENUMS_H__ */
diff -Naur gimp-2.8.14/libgimpcolor/gimpcairocolor.h gimp-2.8.14-new/libgimpcolor/gimpcairocolor.h
--- gimp-2.8.14/libgimpcolor/gimpcairocolor.h	2015-01-27 17:28:37.084833796 +0800
+++ gimp-2.8.14-new/libgimpcolor/gimpcairocolor.h	2015-01-27 17:48:55.461751574 +0800
@@ -23,6 +23,7 @@
 #ifndef __GIMP_CAIRO_COLOR_H__
 #define __GIMP_CAIRO_COLOR_H__
 
+#include <cairo.h>
 
 void              gimp_cairo_set_source_rgb      (cairo_t       *cr,
                                                   const GimpRGB *color);
diff -Naur gimp-2.8.14/libgimpconfig/gimpconfig-params.h gimp-2.8.14-new/libgimpconfig/gimpconfig-params.h
--- gimp-2.8.14/libgimpconfig/gimpconfig-params.h	2015-01-27 17:28:37.062833797 +0800
+++ gimp-2.8.14-new/libgimpconfig/gimpconfig-params.h	2015-01-27 17:48:55.462751574 +0800
@@ -75,74 +75,74 @@
   g_object_class_install_property (class, id,\
                                    g_param_spec_boolean (name, NULL, blurb,\
                                    default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_RGB(class, id, name, blurb, has_alpha, default, flags) \
   g_object_class_install_property (class, id,\
                                    gimp_param_spec_rgb (name, NULL, blurb,\
                                    has_alpha, default, \
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_DOUBLE(class, id, name, blurb, min, max, default, flags)\
   g_object_class_install_property (class, id,\
                                    g_param_spec_double (name, NULL, blurb,\
                                    min, max, default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_RESOLUTION(class, id, name, blurb, default, flags)\
   g_object_class_install_property (class, id,\
                                    g_param_spec_double (name, NULL, blurb,\
                                    GIMP_MIN_RESOLUTION, GIMP_MAX_RESOLUTION, \
                                    default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_ENUM(class, id, name, blurb, enum_type, default, flags)\
   g_object_class_install_property (class, id,\
                                    g_param_spec_enum (name, NULL, blurb,\
                                    enum_type, default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_INT(class, id, name, blurb, min, max, default, flags)\
   g_object_class_install_property (class, id,\
                                    g_param_spec_int (name, NULL, blurb,\
                                    min, max, default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_MATRIX2(class, id, name, blurb, default, flags)\
   g_object_class_install_property (class, id,\
                                    gimp_param_spec_matrix2 (name, NULL, blurb,\
                                    default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_MEMSIZE(class, id, name, blurb, min, max, default, flags)\
   g_object_class_install_property (class, id,\
                                    gimp_param_spec_memsize (name, NULL, blurb,\
                                    min, max, default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_PATH(class, id, name, blurb, path_type, default, flags)\
   g_object_class_install_property (class, id,\
                                    gimp_param_spec_config_path (name, NULL, blurb,\
                                    path_type, default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_STRING(class, id, name, blurb, default, flags)\
   g_object_class_install_property (class, id,\
                                    g_param_spec_string (name, NULL, blurb,\
                                    default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_UINT(class, id, name, blurb, min, max, default, flags)\
   g_object_class_install_property (class, id,\
                                    g_param_spec_uint (name, NULL, blurb,\
                                    min, max, default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 #define GIMP_CONFIG_INSTALL_PROP_UNIT(class, id, name, blurb, pixels, percent, default, flags)\
   g_object_class_install_property (class, id,\
                                    gimp_param_spec_unit (name, NULL, blurb,\
                                    pixels, percent, default,\
-                                   flags | GIMP_CONFIG_PARAM_FLAGS))
+                                   (GParamFlags)(flags | GIMP_CONFIG_PARAM_FLAGS)))
 
 
 /*  object, boxed and pointer properties are _not_ G_PARAM_CONSTRUCT  */
@@ -151,24 +151,24 @@
   g_object_class_install_property (class, id,\
                                    g_param_spec_object (name, NULL, blurb,\
                                    object_type,\
-                                   flags |\
+                                   (GParamFlags)(flags |\
                                    G_PARAM_READWRITE |\
-                                   GIMP_CONFIG_PARAM_SERIALIZE))
+                                   GIMP_CONFIG_PARAM_SERIALIZE)))
 
 #define GIMP_CONFIG_INSTALL_PROP_BOXED(class, id, name, blurb, boxed_type, flags)\
   g_object_class_install_property (class, id,\
                                    g_param_spec_boxed (name, NULL, blurb,\
                                    boxed_type,\
-                                   flags |\
+                                   (GParamFlags)(flags |\
                                    G_PARAM_READWRITE |\
-                                   GIMP_CONFIG_PARAM_SERIALIZE))
+                                   GIMP_CONFIG_PARAM_SERIALIZE)))
 
 #define GIMP_CONFIG_INSTALL_PROP_POINTER(class, id, name, blurb, flags)\
   g_object_class_install_property (class, id,\
                                    g_param_spec_pointer (name, NULL, blurb,\
-                                   flags |\
+                                   (GParamFlags)(flags |\
                                    G_PARAM_READWRITE |\
-                                   GIMP_CONFIG_PARAM_SERIALIZE))
+                                   GIMP_CONFIG_PARAM_SERIALIZE)))
 
 
 G_END_DECLS
diff -Naur gimp-2.8.14/libgimpwidgets/gimpenumwidgets.c gimp-2.8.14-new/libgimpwidgets/gimpenumwidgets.c
--- gimp-2.8.14/libgimpwidgets/gimpenumwidgets.c	2015-01-27 17:28:37.114833794 +0800
+++ gimp-2.8.14-new/libgimpwidgets/gimpenumwidgets.c	2015-01-27 17:48:55.462751574 +0800
@@ -84,6 +84,7 @@
   return vbox;
 }
 
+
 /**
  * gimp_enum_radio_box_new_with_range:
  * @minimum:       the minimum enum value
@@ -102,15 +103,16 @@
  *
  * Since: GIMP 2.4
  **/
-GtkWidget *
-gimp_enum_radio_box_new_with_range (GType       enum_type,
-                                    gint        minimum,
-                                    gint        maximum,
-                                    GCallback   callback,
-                                    gpointer    callback_data,
-                                    GtkWidget **first_button)
+static GtkWidget *
+gimp_enum_radio_box_new_full (GType       enum_type,
+                              gint        minimum,
+                              gint        maximum,
+                              GCallback   callback,
+                              gpointer    callback_data,
+                              GtkWidget **first_button,
+                              GtkOrientation orientation)
 {
-  GtkWidget  *vbox;
+  GtkWidget  *box;
   GtkWidget  *button;
   GEnumClass *enum_class;
   GEnumValue *value;
@@ -119,9 +121,9 @@
   g_return_val_if_fail (G_TYPE_IS_ENUM (enum_type), NULL);
 
   enum_class = g_type_class_ref (enum_type);
-
-  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 1);
-  g_object_weak_ref (G_OBJECT (vbox),
+   
+  box = gtk_box_new (orientation, 1);
+  g_object_weak_ref (G_OBJECT (box),
                      (GWeakNotify) g_type_class_unref, enum_class);
 
   if (first_button)
@@ -142,7 +144,7 @@
         *first_button = button;
 
       group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (button));
-      gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
+      gtk_box_pack_start (GTK_BOX (box), button, FALSE, FALSE, 0);
       gtk_widget_show (button);
 
       g_object_set_data (G_OBJECT (button), "gimp-item-data",
@@ -154,9 +156,89 @@
                           callback_data);
     }
 
+  return box;
+}
+
+
+/**
+ * gimp_enum_radio_box_new_with_orientation:
+ * @enum_type:     the #GType of an enum.
+ * @callback:      a callback to connect to the "toggled" signal of each
+ *                 #GtkRadioButton that is created.
+ * @callback_data: data to pass to the @callback.
+ * @first_button:  returns the first button in the created group.
+ *
+ * Creates a new group of #GtkRadioButtons representing the enum
+ * values.  A group of radiobuttons is a good way to represent enums
+ * with up to three or four values. Often it is better to use a
+ * #GimpEnumComboBox instead.
+ *
+ * Return value: a new #GtkVBox holding a group of #GtkRadioButtons.
+ *
+ * Since: GIMP 2.4
+ **/
+GtkWidget *
+gimp_enum_radio_box_new_with_orientation (GType       enum_type,
+                                          GCallback   callback,
+                                          gpointer    callback_data,
+                                          GtkWidget **first_button,
+                                          GtkOrientation orientation)
+{
+  GEnumClass *enum_class;
+  GtkWidget  *vbox;
+
+  g_return_val_if_fail (G_TYPE_IS_ENUM (enum_type), NULL);
+
+  enum_class = g_type_class_ref (enum_type);
+
+  vbox = gimp_enum_radio_box_new_full (enum_type,
+                                       enum_class->minimum,
+                                       enum_class->maximum,
+                                       callback, callback_data,
+                                       first_button,
+                                       orientation);
+
+  g_type_class_unref (enum_class);
+
   return vbox;
 }
 
+
+/**
+ * gimp_enum_radio_box_new_with_range:
+ * @minimum:       the minimum enum value
+ * @maximum:       the maximum enum value
+ * @enum_type:     the #GType of an enum.
+ * @callback:      a callback to connect to the "toggled" signal of each
+ *                 #GtkRadioButton that is created.
+ * @callback_data: data to pass to the @callback.
+ * @first_button:  returns the first button in the created group.
+ *
+ * Just like gimp_enum_radio_box_new(), this function creates a group
+ * of radio buttons, but it allows to limit the range of available
+ * enum values.
+ *
+ * Return value: a new #GtkVBox holding a group of #GtkRadioButtons.
+ *
+ * Since: GIMP 2.4
+ **/
+GtkWidget *
+gimp_enum_radio_box_new_with_range (GType       enum_type,
+                                    gint        minimum,
+                                    gint        maximum,
+                                    GCallback   callback,
+                                    gpointer    callback_data,
+                                    GtkWidget **first_button)
+{
+  return gimp_enum_radio_box_new_full (enum_type,
+                                        minimum,
+                                        maximum,
+                                        callback,
+                                        callback_data,
+                                        first_button,
+                                        GTK_ORIENTATION_VERTICAL);
+}
+
 /**
  * gimp_enum_radio_frame_new:
  * @enum_type:     the #GType of an enum.
@@ -181,6 +263,41 @@
                            gpointer    callback_data,
                            GtkWidget **first_button)
 {
+  return gimp_enum_radio_frame_new_with_orientation (enum_type,
+                                                      label_widget,
+                                                      callback,
+                                                      callback_data,
+                                                      first_button,
+                                                      GTK_ORIENTATION_VERTICAL);
+}
+
+
+/**
+ * gimp_enum_radio_frame_new_with_orietation:
+ * @enum_type:     the #GType of an enum.
+ * @label_widget:  a widget to use as label for the frame that will
+ *                 hold the radio box.
+ * @callback:      a callback to connect to the "toggled" signal of each
+ *                 #GtkRadioButton that is created.
+ * @callback_data: data to pass to the @callback.
+ * @first_button:  returns the first button in the created group.
+ * @orientation:   alignment orientation of the radio buttons.
+ *
+ * Calls gimp_enum_radio_box_new() and puts the resulting vbox into a
+ * #GtkFrame.
+ *
+ * Return value: a new #GtkFrame holding a group of #GtkRadioButtons.
+ *
+ * Since: GIMP 2.4
+ **/
+GtkWidget *
+gimp_enum_radio_frame_new_with_orientation (GType       enum_type,
+                                            GtkWidget  *label_widget,
+                                            GCallback   callback,
+                                            gpointer    callback_data,
+                                            GtkWidget **first_button,
+                                            GtkOrientation orientation)
+{
   GtkWidget *frame;
   GtkWidget *radio_box;
 
@@ -196,15 +313,16 @@
       gtk_widget_show (label_widget);
     }
 
-  radio_box = gimp_enum_radio_box_new (enum_type,
-                                       callback, callback_data,
-                                       first_button);
+  radio_box = gimp_enum_radio_box_new_with_orientation (enum_type,
+                                                        callback, callback_data,
+                                                        first_button, orientation);
   gtk_container_add (GTK_CONTAINER (frame), radio_box);
   gtk_widget_show (radio_box);
 
   return frame;
 }
 
+
 /**
  * gimp_enum_radio_frame_new_with_range:
  * @enum_type:     the #GType of an enum.
@@ -232,6 +350,46 @@
                                       gpointer    callback_data,
                                       GtkWidget **first_button)
 {
+  return gimp_enum_radio_frame_new_full (enum_type,
+                                          minimum,
+                                          maximum,
+                                          label_widget,
+                                          callback,
+                                          callback_data,
+                                          first_button,
+                                          GTK_ORIENTATION_VERTICAL);
+}
+
+
+/**
+ * gimp_enum_radio_frame_new_full:
+ * @enum_type:     the #GType of an enum.
+ * @minimum:       the minimum enum value
+ * @maximum:       the maximum enum value
+ * @label_widget:  a widget to put into the frame that will hold the radio box.
+ * @callback:      a callback to connect to the "toggled" signal of each
+ *                 #GtkRadioButton that is created.
+ * @callback_data: data to pass to the @callback.
+ * @first_button:  returns the first button in the created group.
+ * @orientation:   alignment orientation of the radio buttons.
+ *
+ * Calls gimp_enum_radio_box_new_with_range() and puts the resulting
+ * vbox into a #GtkFrame.
+ *
+ * Return value: a new #GtkFrame holding a group of #GtkRadioButtons.
+ *
+ * Since: GIMP 2.4
+ **/
+GtkWidget *
+gimp_enum_radio_frame_new_full (GType       enum_type,
+                               gint        minimum,
+                               gint        maximum,
+                               GtkWidget  *label_widget,
+                               GCallback   callback,
+                               gpointer    callback_data,
+                               GtkWidget **first_button,
+                               GtkOrientation orientation)
+{
   GtkWidget *frame;
   GtkWidget *radio_box;
 
@@ -247,11 +405,12 @@
       gtk_widget_show (label_widget);
     }
 
-  radio_box = gimp_enum_radio_box_new_with_range (enum_type,
-                                                  minimum,
-                                                  maximum,
-                                                  callback, callback_data,
-                                                  first_button);
+  radio_box = gimp_enum_radio_box_new_full (enum_type,
+                                            minimum,
+                                            maximum,
+                                            callback, callback_data,
+                                            first_button,
+                                            orientation);
   gtk_container_add (GTK_CONTAINER (frame), radio_box);
   gtk_widget_show (radio_box);
 
@@ -304,6 +463,7 @@
   return box;
 }
 
+
 /**
  * gimp_enum_stock_box_new_with_range:
  * @enum_type:     the #GType of an enum.
@@ -324,15 +484,16 @@
  *
  * Since: GIMP 2.4
  **/
-GtkWidget *
-gimp_enum_stock_box_new_with_range (GType         enum_type,
-                                    gint          minimum,
-                                    gint          maximum,
-                                    const gchar  *stock_prefix,
-                                    GtkIconSize   icon_size,
-                                    GCallback     callback,
-                                    gpointer      callback_data,
-                                    GtkWidget   **first_button)
+static GtkWidget *
+gimp_enum_stock_box_new_full (GType         enum_type,
+                              gint          minimum,
+                              gint          maximum,
+                              const gchar  *stock_prefix,
+                              GtkIconSize   icon_size,
+                              GCallback     callback,
+                              gpointer      callback_data,
+                              GtkWidget   **first_button,
+                              GtkOrientation orientation)
 {
   GtkWidget  *hbox;
   GtkWidget  *button;
@@ -347,7 +508,7 @@
 
   enum_class = g_type_class_ref (enum_type);
 
-  hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+  hbox = gtk_box_new (orientation, 0);
   g_object_weak_ref (G_OBJECT (hbox),
                      (GWeakNotify) g_type_class_unref, enum_class);
 
@@ -400,6 +561,95 @@
 }
 
 /**
+ * gimp_enum_stock_box_new:
+ * @enum_type:     the #GType of an enum.
+ * @stock_prefix:  the prefix of the group of stock ids to use.
+ * @icon_size:     the icon size for the stock icons
+ * @callback:      a callback to connect to the "toggled" signal of each
+ *                 #GtkRadioButton that is created.
+ * @callback_data: data to pass to the @callback.
+ * @first_button:  returns the first button in the created group.
+ *
+ * Creates a horizontal box of radio buttons with stock icons.  The
+ * stock_id for each icon is created by appending the enum_value's
+ * nick to the given @stock_prefix.
+ *
+ * Return value: a new #GtkHBox holding a group of #GtkRadioButtons.
+ *
+ * Since: GIMP 2.4
+ **/
+GtkWidget *
+gimp_enum_stock_box_new_with_orientation (GType         enum_type,
+                                          const gchar  *stock_prefix,
+                                          GtkIconSize   icon_size,
+                                          GCallback     callback,
+                                          gpointer      callback_data,
+                                          GtkWidget   **first_button,
+                                          GtkOrientation orientation)
+{
+  GEnumClass *enum_class;
+  GtkWidget  *box;
+
+  g_return_val_if_fail (G_TYPE_IS_ENUM (enum_type), NULL);
+
+  enum_class = g_type_class_ref (enum_type);
+
+  box = gimp_enum_stock_box_new_full (enum_type,
+                                      enum_class->minimum,
+                                      enum_class->maximum,
+                                      stock_prefix, icon_size,
+                                      callback, callback_data,
+                                      first_button,
+                                      orientation);
+
+  g_type_class_unref (enum_class);
+
+  return box;
+}
+
+
+/**
+ * gimp_enum_stock_box_new_with_range:
+ * @enum_type:     the #GType of an enum.
+ * @minimum:       the minumim enum value
+ * @maximum:       the maximum enum value
+ * @stock_prefix:  the prefix of the group of stock ids to use.
+ * @icon_size:     the icon size for the stock icons
+ * @callback:      a callback to connect to the "toggled" signal of each
+ *                 #GtkRadioButton that is created.
+ * @callback_data: data to pass to the @callback.
+ * @first_button:  returns the first button in the created group.
+ *
+ * Just like gimp_enum_stock_box_new(), this function creates a group
+ * of radio buttons, but it allows to limit the range of available
+ * enum values.
+ *
+ * Return value: a new #GtkHBox holding a group of #GtkRadioButtons.
+ *
+ * Since: GIMP 2.4
+ **/
+GtkWidget *
+gimp_enum_stock_box_new_with_range (GType         enum_type,
+                                    gint          minimum,
+                                    gint          maximum,
+                                    const gchar  *stock_prefix,
+                                    GtkIconSize   icon_size,
+                                    GCallback     callback,
+                                    gpointer      callback_data,
+                                    GtkWidget   **first_button)
+{
+  return gimp_enum_stock_box_new_full (enum_type,
+                                        minimum,
+                                        maximum,
+                                        stock_prefix,
+                                        icon_size,
+                                        callback,
+                                        callback_data,
+                                        first_button,
+                                        GTK_ORIENTATION_HORIZONTAL);
+}
+
+/**
  * gimp_enum_stock_box_set_child_padding:
  * @stock_box: a stock box widget
  * @xpad:      horizontal padding
diff -Naur gimp-2.8.14/libgimpwidgets/gimpenumwidgets.h gimp-2.8.14-new/libgimpwidgets/gimpenumwidgets.h
--- gimp-2.8.14/libgimpwidgets/gimpenumwidgets.h	2015-01-27 17:28:37.106833794 +0800
+++ gimp-2.8.14-new/libgimpwidgets/gimpenumwidgets.h	2015-01-27 17:48:55.462751574 +0800
@@ -33,6 +33,11 @@
                                                    GCallback     callback,
                                                    gpointer      callback_data,
                                                    GtkWidget   **first_button);
+GtkWidget * gimp_enum_radio_box_new_with_orientation (GType         enum_type,
+                                                      GCallback     callback,
+                                                      gpointer      callback_data,
+                                                      GtkWidget   **first_button,
+                                                      GtkOrientation orientation);
 GtkWidget * gimp_enum_radio_box_new_with_range    (GType         enum_type,
                                                    gint          minimum,
                                                    gint          maximum,
@@ -45,6 +50,12 @@
                                                    GCallback     callback,
                                                    gpointer      callback_data,
                                                    GtkWidget   **first_button);
+GtkWidget * gimp_enum_radio_frame_new_with_orientation (GType         enum_type,
+                                                        GtkWidget    *label_widget,
+                                                        GCallback     callback,
+                                                        gpointer      callback_data,
+                                                        GtkWidget   **first_button,
+                                                        GtkOrientation orientation);
 GtkWidget * gimp_enum_radio_frame_new_with_range  (GType         enum_type,
                                                    gint          minimum,
                                                    gint          maximum,
@@ -52,6 +63,14 @@
                                                    GCallback     callback,
                                                    gpointer      callback_data,
                                                    GtkWidget   **first_button);
+GtkWidget * gimp_enum_radio_frame_new_full        (GType         enum_type,
+                                                   gint          minimum,
+                                                   gint          maximum,
+                                                   GtkWidget    *label_widget,
+                                                   GCallback     callback,
+                                                   gpointer      callback_data,
+                                                   GtkWidget   **first_button,
+                                                   GtkOrientation orientation);
 
 GtkWidget * gimp_enum_stock_box_new               (GType         enum_type,
                                                    const gchar  *stock_prefix,
@@ -59,6 +78,13 @@
                                                    GCallback     callback,
                                                    gpointer      callback_data,
                                                    GtkWidget   **first_button);
+GtkWidget * gimp_enum_stock_box_new_with_orientation (GType         enum_type,
+                                                      const gchar  *stock_prefix,
+                                                      GtkIconSize   icon_size,
+                                                      GCallback     callback,
+                                                      gpointer      callback_data,
+                                                      GtkWidget   **first_button,
+                                                      GtkOrientation orientation);
 GtkWidget * gimp_enum_stock_box_new_with_range    (GType         enum_type,
                                                    gint          minimum,
                                                    gint          maximum,
diff -Naur gimp-2.8.14/libgimpwidgets/gimppropwidgets.c gimp-2.8.14-new/libgimpwidgets/gimppropwidgets.c
--- gimp-2.8.14/libgimpwidgets/gimppropwidgets.c	2015-01-27 17:28:37.107833794 +0800
+++ gimp-2.8.14-new/libgimpwidgets/gimppropwidgets.c	2015-01-27 17:48:55.463751574 +0800
@@ -655,6 +655,39 @@
                                 gint         minimum,
                                 gint         maximum)
 {
+  return gimp_prop_enum_radio_frame_new_with_orientation (config,
+                                                           property_name,
+                                                           title,
+                                                           minimum,
+                                                           maximum,
+                                                           GTK_ORIENTATION_VERTICAL);
+}
+
+/**
+ * gimp_prop_enum_radio_frame_new_full:
+ * @config:        Object to which property is attached.
+ * @property_name: Name of enum property controlled by the radio buttons.
+ * @title:         Label for the frame holding the buttons
+ * @minimum:       Smallest value of enum to be included.
+ * @maximum:       Largest value of enum to be included.
+ *
+ * Creates a group of radio buttons which function to set and display
+ * the specified enum property.  The @minimum and @maximum arguments
+ * allow only a subset of the enum to be used.  If the two arguments
+ * are equal (e.g., 0, 0), then the full range of the enum will be used.
+ *
+ * Return value: A #GimpFrame containing the radio buttons.
+ *
+ * Since GIMP 2.4
+ */
+GtkWidget *
+gimp_prop_enum_radio_frame_new_with_orientation (GObject     *config,
+                                                 const gchar *property_name,
+                                                 const gchar *title,
+                                                 gint         minimum,
+                                                 gint         maximum,
+                                                 GtkOrientation orientation)
+{
   GParamSpec *param_spec;
   GtkWidget  *frame;
   GtkWidget  *button;
@@ -674,20 +707,22 @@
 
   if (minimum != maximum)
     {
-      frame = gimp_enum_radio_frame_new_with_range (param_spec->value_type,
-                                                    minimum, maximum,
-                                                    gtk_label_new (title),
-                                                    G_CALLBACK (gimp_prop_radio_button_callback),
-                                                    config,
-                                                    &button);
+      frame = gimp_enum_radio_frame_new_full (param_spec->value_type,
+                                              minimum, maximum,
+                                              gtk_label_new (title),
+                                              G_CALLBACK (gimp_prop_radio_button_callback),
+                                              config,
+                                              &button,
+                                              orientation);
     }
   else
     {
-      frame = gimp_enum_radio_frame_new (param_spec->value_type,
-                                         gtk_label_new (title),
-                                         G_CALLBACK (gimp_prop_radio_button_callback),
-                                         config,
-                                         &button);
+      frame = gimp_enum_radio_frame_new_with_orientation (param_spec->value_type,
+                                                          gtk_label_new (title),
+                                                          G_CALLBACK (gimp_prop_radio_button_callback),
+                                                          config,
+                                                          &button,
+                                                          orientation);
     }
 
   gimp_int_radio_group_set_active (GTK_RADIO_BUTTON (button), value);
@@ -859,6 +894,38 @@
                                    const gchar *true_text,
                                    const gchar *false_text)
 {
+  return gimp_prop_boolean_radio_frame_new_with_orientation (config,
+                                                              property_name,
+                                                              title,
+                                                              true_text, false_text,
+                                                              GTK_ORIENTATION_VERTICAL);
+}
+
+
+/**
+ * gimp_prop_boolean_radio_frame_new_with_orientation:
+ * @config:        Object to which property is attached.
+ * @property_name: Name of boolean property controlled by the radio buttons.
+ * @title:         Label for the frame.
+ * @true_text:     Label for the button corresponding to %TRUE.
+ * @false_text:    Label for the button corresponding to %FALSE.
+ * @orientation:   Alignment orientation of the radio buttons.
+ *
+ * Creates a pair of radio buttons which function to set and display
+ * the specified boolean property.
+ *
+ * Return value: A #GimpFrame containing the radio buttons.
+ *
+ * Since GIMP 2.4
+ */
+GtkWidget *
+gimp_prop_boolean_radio_frame_new_with_orientation (GObject     *config,
+                                                    const gchar *property_name,
+                                                    const gchar *title,
+                                                    const gchar *true_text,
+                                                    const gchar *false_text,
+                                                    GtkOrientation orientation)
+{
   GParamSpec *param_spec;
   GtkWidget  *frame;
   GtkWidget  *button;
@@ -877,9 +944,9 @@
                 NULL);
 
   frame =
-    gimp_int_radio_group_new (TRUE, title,
+    gimp_int_radio_group_new_with_orientation (TRUE, title,
                               G_CALLBACK (gimp_prop_radio_button_callback),
-                              config, value,
+                              config, orientation, value,
 
                               false_text, FALSE, &button,
                               true_text,  TRUE,  NULL,
@@ -922,6 +989,40 @@
                               gint         minimum,
                               gint         maximum)
 {
+  return gimp_prop_enum_stock_box_new_with_orientation (config,
+                                                         property_name,
+                                                         stock_prefix,
+                                                         minimum,
+                                                         maximum,
+                                                         GTK_ORIENTATION_VERTICAL);
+}
+
+/**
+ * gimp_prop_enum_stock_box_new_with_orientation:
+ * @config:        Object to which property is attached.
+ * @property_name: Name of enum property controlled by the radio buttons.
+ * @stock_prefix:  The prefix of the group of stock ids to use.
+ * @minimum:       Smallest value of enum to be included.
+ * @maximum:       Largest value of enum to be included.
+ *
+ * Creates a horizontal box of radio buttons with stock icons, which
+ * function to set and display the value of the specified Enum
+ * property.  The stock_id for each icon is created by appending the
+ * enum_value's nick to the given @stock_prefix.  See
+ * gimp_enum_stock_box_new() for more information.
+ *
+ * Return value: A #libgimpwidgets-gimpenumstockbox containing the radio buttons.
+ *
+ * Since GIMP 2.8
+ */
+GtkWidget *
+gimp_prop_enum_stock_box_new_with_orientation (GObject     *config,
+                                               const gchar *property_name,
+                                               const gchar *stock_prefix,
+                                               gint         minimum,
+                                               gint         maximum,
+                                               GtkOrientation orientation)
+{
   GParamSpec *param_spec;
   GtkWidget  *box;
   GtkWidget  *button;
diff -Naur gimp-2.8.14/libgimpwidgets/gimppropwidgets.h gimp-2.8.14-new/libgimpwidgets/gimppropwidgets.h
--- gimp-2.8.14/libgimpwidgets/gimppropwidgets.h	2015-01-27 17:28:37.106833794 +0800
+++ gimp-2.8.14-new/libgimpwidgets/gimppropwidgets.h	2015-01-27 17:48:55.463751574 +0800
@@ -43,6 +43,12 @@
                                                    const gchar  *title,
                                                    const gchar  *true_text,
                                                    const gchar  *false_text);
+GtkWidget     * gimp_prop_boolean_radio_frame_new_with_orientation (GObject      *config,
+                                                   const gchar  *property_name,
+                                                   const gchar  *title,
+                                                   const gchar  *true_text,
+                                                   const gchar  *false_text,
+                                                   GtkOrientation orientation);
 
 GtkWidget     * gimp_prop_expander_new            (GObject      *config,
                                                    const gchar  *property_name,
@@ -74,6 +80,12 @@
                                                    const gchar  *title,
                                                    gint          minimum,
                                                    gint          maximum);
+GtkWidget     * gimp_prop_enum_radio_frame_new_with_orientation (GObject     *config,
+                                                                 const gchar *property_name,
+                                                                 const gchar *title,
+                                                                 gint         minimum,
+                                                                 gint         maximum,
+                                                                 GtkOrientation orientation);
 GtkWidget     * gimp_prop_enum_radio_box_new      (GObject      *config,
                                                    const gchar  *property_name,
                                                    gint          minimum,
@@ -83,6 +95,12 @@
                                                    const gchar  *stock_prefix,
                                                    gint          minimum,
                                                    gint          maximum);
+GtkWidget     * gimp_prop_enum_stock_box_new_with_orientation (GObject      *config,
+                                                               const gchar  *property_name,
+                                                               const gchar  *stock_prefix,
+                                                               gint          minimum,
+                                                               gint          maximum,
+                                                               GtkOrientation orientation);
 
 GtkWidget     * gimp_prop_enum_label_new          (GObject      *config,
                                                    const gchar  *property_name);
diff -Naur gimp-2.8.14/libgimpwidgets/gimpstock.c gimp-2.8.14-new/libgimpwidgets/gimpstock.c
--- gimp-2.8.14/libgimpwidgets/gimpstock.c	2015-01-27 17:28:37.101833795 +0800
+++ gimp-2.8.14-new/libgimpwidgets/gimpstock.c	2015-01-27 17:48:55.464751573 +0800
@@ -342,7 +342,8 @@
   { GIMP_STOCK_TOOL_SMUDGE,              NULL,        0, 0, LIBGIMP_DOMAIN },
   { GIMP_STOCK_TOOL_TEXT,                NULL,        0, 0, LIBGIMP_DOMAIN },
   { GIMP_STOCK_TOOL_THRESHOLD,           NULL,        0, 0, LIBGIMP_DOMAIN },
-  { GIMP_STOCK_TOOL_ZOOM,                NULL,        0, 0, LIBGIMP_DOMAIN }
+  { GIMP_STOCK_TOOL_ZOOM,                NULL,        0, 0, LIBGIMP_DOMAIN },
+  { GIMP_STOCK_TOOL_MYPAINT,             NULL,        0, 0, LIBGIMP_DOMAIN }
 };
 
 static const struct
@@ -498,6 +499,7 @@
   { GIMP_STOCK_TOOL_TEXT,                stock_tool_text_22                },
   { GIMP_STOCK_TOOL_THRESHOLD,           stock_tool_threshold_22           },
   { GIMP_STOCK_TOOL_ZOOM,                stock_tool_zoom_22                },
+  { GIMP_STOCK_TOOL_MYPAINT,             stock_tool_mypaint_22             },
 
   { GIMP_STOCK_INFO,                     stock_info_24                     },
   { GIMP_STOCK_WARNING,                  stock_warning_24                  },
diff -Naur gimp-2.8.14/libgimpwidgets/gimpstock.h gimp-2.8.14-new/libgimpwidgets/gimpstock.h
--- gimp-2.8.14/libgimpwidgets/gimpstock.h	2015-01-27 17:28:37.105833794 +0800
+++ gimp-2.8.14-new/libgimpwidgets/gimpstock.h	2015-01-27 17:48:55.464751573 +0800
@@ -143,6 +143,7 @@
 #define GIMP_STOCK_TOOL_TEXT                "gimp-tool-text"
 #define GIMP_STOCK_TOOL_THRESHOLD           "gimp-tool-threshold"
 #define GIMP_STOCK_TOOL_ZOOM                "gimp-tool-zoom"
+#define GIMP_STOCK_TOOL_MYPAINT             "gimp-tool-mypaint"
 
 
 /*  in menu size:  */
@@ -284,6 +285,7 @@
 #define GIMP_STOCK_PALETTE                  GTK_STOCK_SELECT_COLOR
 #define GIMP_STOCK_PATTERN                  GIMP_STOCK_TOOL_BUCKET_FILL
 #define GIMP_STOCK_CONTROLLER_MOUSE         GIMP_STOCK_CURSOR
+#define GIMP_STOCK_MYPAINT_BRUSH            GIMP_STOCK_TOOL_MYPAINT
 
 
 void   gimp_stock_init (void);
diff -Naur gimp-2.8.14/libgimpwidgets/gimpwidgets.c gimp-2.8.14-new/libgimpwidgets/gimpwidgets.c
--- gimp-2.8.14/libgimpwidgets/gimpwidgets.c	2015-01-27 17:28:37.110833794 +0800
+++ gimp-2.8.14-new/libgimpwidgets/gimpwidgets.c	2015-01-27 17:48:55.464751573 +0800
@@ -363,6 +363,126 @@
 }
 
 /**
+ * gimp_int_radio_group_new_with_orientation:
+ * @in_frame:              %TRUE if you want a #GtkFrame around the
+ *                         radio button group.
+ * @frame_title:           The title of the Frame or %NULL if you don't want
+ *                         a title.
+ * @radio_button_callback: The callback each button's "toggled" signal will
+ *                         be connected with.
+ * @radio_button_callback_data:
+ *                         The data which will be passed to g_signal_connect().
+ * @orientation:           Alignment orientation of the radio buttons.
+ * @initial:               The @item_data of the initially pressed radio button.
+ * @...:                   A %NULL-terminated @va_list describing
+ *                         the radio buttons.
+ *
+ * Convenience function to create a group of radio buttons embedded into
+ * a #GtkFrame or #GtkVBox. This function does the same thing as
+ * gimp_radio_group_new2(), but it takes integers as @item_data instead of
+ * pointers, since that is a very common case (mapping an enum to a radio
+ * group).
+ *
+ * Returns: A #GtkFrame or #GtkVBox (depending on @in_frame).
+ **/
+GtkWidget *
+gimp_int_radio_group_new_with_orientation (gboolean         in_frame,
+                                           const gchar     *frame_title,
+                                           GCallback        radio_button_callback,
+                                           gpointer         callback_data,
+                                           GtkOrientation   orientation,
+                                           gint             initial, /* item_data */
+ 
+                                           /* specify radio buttons as va_list:
+                                            *  const gchar *label,
+                                            *  gint         item_data,
+                                            *  GtkWidget  **widget_ptr,
+                                            */
+ 
+                                           ...)
+{
+  GtkWidget *vbox;
+  GtkWidget *button;
+  GSList    *group;
+
+  /*  radio button variables  */
+  const gchar *label;
+  gint         item_data;
+  gpointer     item_ptr;
+  GtkWidget  **widget_ptr;
+
+  va_list args;
+
+  switch (orientation)
+    {
+    case GTK_ORIENTATION_HORIZONTAL:
+      vbox = gtk_hbox_new (FALSE, 2);
+      break;
+    case GTK_ORIENTATION_VERTICAL:
+    default:
+      vbox = gtk_vbox_new (FALSE, 2);
+      break;
+    }
+  group = NULL;
+
+  /*  create the radio buttons  */
+  va_start (args, initial);
+  label = va_arg (args, const gchar *);
+
+  while (label)
+    {
+      item_data  = va_arg (args, gint);
+      widget_ptr = va_arg (args, GtkWidget **);
+
+      item_ptr = GINT_TO_POINTER (item_data);
+
+      if (label != GINT_TO_POINTER (1))
+        button = gtk_radio_button_new_with_mnemonic (group, label);
+      else
+        button = gtk_radio_button_new (group);
+
+      group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (button));
+      gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
+
+      if (item_data)
+        {
+          g_object_set_data (G_OBJECT (button), "gimp-item-data", item_ptr);
+
+          /*  backward compatibility  */
+          g_object_set_data (G_OBJECT (button), "user_data", item_ptr);
+        }
+
+      if (widget_ptr)
+        *widget_ptr = button;
+
+      if (initial == item_data)
+        gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button), TRUE);
+
+      g_signal_connect (button, "toggled",
+                        radio_button_callback,
+                        callback_data);
+
+      gtk_widget_show (button);
+
+      label = va_arg (args, const gchar *);
+    }
+  va_end (args);
+
+  if (in_frame)
+    {
+      GtkWidget *frame;
+
+      frame = gimp_frame_new (frame_title);
+      gtk_container_add (GTK_CONTAINER (frame), vbox);
+      gtk_widget_show (vbox);
+
+      return frame;
+    }
+
+  return vbox;
+}
+
+/**
  * gimp_radio_group_set_active:
  * @radio_button: Pointer to a #GtkRadioButton.
  * @item_data: The @item_data of the radio button you want to select.
diff -Naur gimp-2.8.14/libgimpwidgets/gimpwidgets.h gimp-2.8.14-new/libgimpwidgets/gimpwidgets.h
--- gimp-2.8.14/libgimpwidgets/gimpwidgets.h	2015-01-27 17:28:37.100833795 +0800
+++ gimp-2.8.14-new/libgimpwidgets/gimpwidgets.h	2015-01-27 17:48:55.465751573 +0800
@@ -107,6 +107,21 @@
 
                                       ...) G_GNUC_NULL_TERMINATED;
 
+GtkWidget * gimp_int_radio_group_new_with_orientation (gboolean          in_frame,
+                                                       const gchar      *frame_title,
+                                                       GCallback         radio_button_callback,
+                                                       gpointer          radio_button_callback_data,
+                                                       GtkOrientation    orientation,
+                                                       gint              initial, /* item_data */
+
+                                                       /* specify radio buttons as va_list:
+                                                        *  const gchar  *label,
+                                                        *  gint          item_data,
+                                                        *  GtkWidget   **widget_ptr,
+                                                        */
+
+                                                       ...) G_GNUC_NULL_TERMINATED;
+
 void        gimp_int_radio_group_set_active (GtkRadioButton *radio_button,
                                              gint            item_data);
 
diff -Naur gimp-2.8.14/menus/dialogs-menuitems.xml gimp-2.8.14-new/menus/dialogs-menuitems.xml
--- gimp-2.8.14/menus/dialogs-menuitems.xml	2015-01-27 17:28:37.018833800 +0800
+++ gimp-2.8.14-new/menus/dialogs-menuitems.xml	2015-01-27 17:48:55.465751573 +0800
@@ -22,6 +22,7 @@
   <menuitem action="dialogs-gradients" />
   <menuitem action="dialogs-palettes" />
   <menuitem action="dialogs-fonts" />
+  <menuitem action="dialogs-mypaint-brushes" />
   <menuitem action="dialogs-tool-presets" />
   <menuitem action="dialogs-buffers" />
   <separator />
diff -Naur gimp-2.8.14/menus/Makefile.am gimp-2.8.14-new/menus/Makefile.am
--- gimp-2.8.14/menus/Makefile.am	2015-01-27 17:28:37.017833800 +0800
+++ gimp-2.8.14-new/menus/Makefile.am	2015-01-27 17:48:55.465751573 +0800
@@ -38,7 +38,9 @@
 	text-tool-menu.xml		\
 	tool-options-menu.xml		\
 	undo-menu.xml			\
-	vectors-menu.xml
+	vectors-menu.xml		\
+	mypaint-brushes-menu.xml	\
+	mypaint-brush-editor-menu.xml
 
 EXTRA_DIST = \
 	$(menudata_DATA)		\
diff -Naur gimp-2.8.14/menus/mypaint-brush-editor-menu.xml gimp-2.8.14-new/menus/mypaint-brush-editor-menu.xml
--- gimp-2.8.14/menus/mypaint-brush-editor-menu.xml	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/menus/mypaint-brush-editor-menu.xml	2015-01-27 17:48:55.465751573 +0800
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE ui SYSTEM "gtkuimanager.dtd">
+
+<ui>
+  <popup action="mypaint-brush-editor-popup">
+    <menuitem action="mypaint-brush-editor-edit-active" />
+  </popup>
+</ui>
diff -Naur gimp-2.8.14/menus/mypaint-brushes-menu.xml gimp-2.8.14-new/menus/mypaint-brushes-menu.xml
--- gimp-2.8.14/menus/mypaint-brushes-menu.xml	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/menus/mypaint-brushes-menu.xml	2015-01-27 17:48:55.465751573 +0800
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE ui SYSTEM "gtkuimanager.dtd">
+
+<ui>
+  <popup action="mypaint-brushes-popup">
+    <menuitem action="mypaint-brushes-edit" />
+    <separator />
+<!--    <menuitem action="brushes-new" /> -->
+    <menuitem action="mypaint-brushes-duplicate" />
+    <menuitem action="mypaint-brushes-copy-location" />
+    <menuitem action="mypaint-brushes-delete" />
+    <separator />
+    <menuitem action="mypaint-brushes-refresh" />
+    <separator />
+  </popup>
+</ui>
diff -Naur gimp-2.8.14/plug-ins/script-fu/scheme-wrapper.c gimp-2.8.14-new/plug-ins/script-fu/scheme-wrapper.c
--- gimp-2.8.14/plug-ins/script-fu/scheme-wrapper.c	2015-01-27 17:28:37.178833789 +0800
+++ gimp-2.8.14-new/plug-ins/script-fu/scheme-wrapper.c	2015-01-27 17:48:55.466751573 +0800
@@ -147,6 +147,10 @@
   { "COLOR",                GIMP_COLOR_MODE        },
   { "VALUE",                GIMP_VALUE_MODE        },
   { "DIVIDE",               GIMP_DIVIDE_MODE       },
+  { "SRC-IN",               GIMP_SRC_IN_MODE       },
+  { "DST-IN",               GIMP_DST_IN_MODE       },
+  { "SRC-OUT",              GIMP_SRC_OUT_MODE      },
+  { "DST-OUT",              GIMP_DST_OUT_MODE      },
 
   { "BLUR",                 GIMP_BLUR_CONVOLVE     },
   { "SHARPEN",              GIMP_SHARPEN_CONVOLVE  },
diff -Naur gimp-2.8.14/themes/Default/images/Makefile.am gimp-2.8.14-new/themes/Default/images/Makefile.am
--- gimp-2.8.14/themes/Default/images/Makefile.am	2015-01-27 17:28:37.121833793 +0800
+++ gimp-2.8.14-new/themes/Default/images/Makefile.am	2015-01-27 17:48:55.466751573 +0800
@@ -348,8 +348,10 @@
 	tools/stock-tool-threshold-16.png		\
 	tools/stock-tool-threshold-22.png		\
 	tools/stock-tool-zoom-16.png			\
-	tools/stock-tool-zoom-22.png
-
+	tools/stock-tool-zoom-22.png			\
+	tools/stock-tool-mypaint-16.png			\
+	tools/stock-tool-mypaint-22.png		
+	
 STOCK_IMAGES = \
 	$(STOCK_MENU_IMAGES) 	\
 	$(STOCK_BUTTON_IMAGES)	\
diff -Naur gimp-2.8.14/tools/pdbgen/enums.pl gimp-2.8.14-new/tools/pdbgen/enums.pl
--- gimp-2.8.14/tools/pdbgen/enums.pl	2015-01-27 17:28:37.266833784 +0800
+++ gimp-2.8.14-new/tools/pdbgen/enums.pl	2015-01-27 17:48:55.466751573 +0800
@@ -412,6 +412,16 @@
 	  symbols => [ qw(GIMP_VECTORS_STROKE_TYPE_BEZIER) ],
 	  mapping => { GIMP_VECTORS_STROKE_TYPE_BEZIER => '0' }
 	},
+    GimpMypaintBrushMode =>
+	{ contig => 1,
+	  header => 'libgimpbase/gimpbaseenums.h',
+	  symbols => [ qw(GIMP_MYPAINT_NORMAL GIMP_MYPAINT_NORMAL_AND_ERASE
+			  GIMP_MYPAINT_LOCK_ALPHA GIMP_MYPAINT_COLORIZE) ],
+	  mapping => { GIMP_MYPAINT_NORMAL => '0',
+		       GIMP_MYPAINT_NORMAL_AND_ERASE => '1',
+		       GIMP_MYPAINT_LOCK_ALPHA => '2',
+		       GIMP_MYPAINT_COLORIZE => '3' }
+	},
     GimpHistogramChannel =>
 	{ contig => 1,
 	  header => 'base/base-enums.h',
@@ -437,7 +447,9 @@
 			  GIMP_VALUE_MODE GIMP_DIVIDE_MODE GIMP_DODGE_MODE
 			  GIMP_BURN_MODE GIMP_HARDLIGHT_MODE
 			  GIMP_SOFTLIGHT_MODE GIMP_GRAIN_EXTRACT_MODE
-			  GIMP_GRAIN_MERGE_MODE GIMP_COLOR_ERASE_MODE) ],
+			  GIMP_GRAIN_MERGE_MODE GIMP_COLOR_ERASE_MODE
+			  GIMP_SRC_IN_MODE GIMP_DST_IN_MODE
+			  GIMP_SRC_OUT_MODE GIMP_DST_OUT_MODE) ],
 	  mapping => { GIMP_NORMAL_MODE => '0',
 		       GIMP_DISSOLVE_MODE => '1',
 		       GIMP_BEHIND_MODE => '2',
@@ -460,7 +472,11 @@
 		       GIMP_SOFTLIGHT_MODE => '19',
 		       GIMP_GRAIN_EXTRACT_MODE => '20',
 		       GIMP_GRAIN_MERGE_MODE => '21',
-		       GIMP_COLOR_ERASE_MODE => '22' }
+		       GIMP_COLOR_ERASE_MODE => '22',
+		       GIMP_SRC_IN_MODE => '23',
+		       GIMP_DST_IN_MODE => '24',
+		       GIMP_SRC_OUT_MODE => '25',
+		       GIMP_DST_OUT_MODE => '26' }
 	},
     GimpHueRange =>
 	{ contig => 1,
diff -Naur gimp-2.8.14/tools/pdbgen/groups.pl gimp-2.8.14-new/tools/pdbgen/groups.pl
--- gimp-2.8.14/tools/pdbgen/groups.pl	2015-01-27 17:28:37.266833784 +0800
+++ gimp-2.8.14-new/tools/pdbgen/groups.pl	2015-01-27 17:48:55.467751573 +0800
@@ -50,4 +50,5 @@
     undo
     unit
     vectors
+    mypaint_brush_select
 );
diff -Naur gimp-2.8.14/tools/pdbgen/Makefile.am gimp-2.8.14-new/tools/pdbgen/Makefile.am
--- gimp-2.8.14/tools/pdbgen/Makefile.am	2015-01-27 17:28:37.267833783 +0800
+++ gimp-2.8.14-new/tools/pdbgen/Makefile.am	2015-01-27 17:48:55.466751573 +0800
@@ -51,7 +51,8 @@
 	pdb/transform_tools.pdb		\
 	pdb/undo.pdb			\
 	pdb/unit.pdb			\
-	pdb/vectors.pdb
+	pdb/vectors.pdb			\
+	pdb/mypaint_brush_select.pdb
 
 EXTRA_DIST = \
 	README			\
diff -Naur gimp-2.8.14/tools/pdbgen/pdb/mypaint_brush_select.pdb gimp-2.8.14-new/tools/pdbgen/pdb/mypaint_brush_select.pdb
--- gimp-2.8.14/tools/pdbgen/pdb/mypaint_brush_select.pdb	1970-01-01 08:00:00.000000000 +0800
+++ gimp-2.8.14-new/tools/pdbgen/pdb/mypaint_brush_select.pdb	2015-01-27 17:48:55.467751573 +0800
@@ -0,0 +1,116 @@
+# GIMP - The GNU Image Manipulation Program
+# Copyright (C) 1995 Spencer Kimball and Peter Mattis
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# "Copied" from brush_select.pdb by sigetch <sigetch@gmail.com>
+
+sub mypaint_brushes_popup {
+    $blurb = 'Invokes the Gimp mypaint brush selection.';
+    $help  = 'This procedure opens the mypaint brush selection dialog.';
+
+    &andy_pdb_misc('2012');
+
+    @inargs = (
+	{ name => 'mypaint_brush_callback', type => 'string', non_empty => 1,
+	  desc => 'The callback PDB proc to call when mypaint brush selection is
+		   made' },
+	{ name => 'popup_title', type => 'string',
+	  desc => 'Title of the mypaint brush selection dialog' },
+	{ name => 'initial_brush', type => 'string', null_ok => 1,
+	  desc => 'The name of the mypaint brush to set as the first selected' }
+    );
+
+    %invoke = (
+	code => <<'CODE'
+{
+  if (gimp->no_interface ||
+      ! gimp_pdb_lookup_procedure (gimp->pdb, mypaint_brush_callback) ||
+      ! gimp_pdb_dialog_new (gimp, context, progress,
+                             gimp_data_factory_get_container (gimp->mypaint_brush_factory),
+                             popup_title, mypaint_brush_callback, initial_brush,
+                             NULL))
+    success = FALSE;
+}
+CODE
+    );
+}
+
+sub mypaint_brushes_close_popup {
+    $blurb = 'Close the mypaint brush selection dialog.';
+    $help  = 'This procedure closes an opened brush selection dialog.';
+
+    &andy_pdb_misc('2012');
+
+    @inargs = (
+	{ name => 'mypaint_brush_callback', type => 'string', non_empty => 1,
+	  desc => 'The name of the callback registered for this pop-up' }
+    );
+
+    %invoke = (
+	code => <<'CODE'
+{
+  if (gimp->no_interface ||
+      ! gimp_pdb_lookup_procedure (gimp->pdb, mypaint_brush_callback) ||
+      ! gimp_pdb_dialog_close (gimp, gimp_data_factory_get_container (gimp->mypaint_brush_factory),
+                               mypaint_brush_callback))
+    success = FALSE;
+}
+CODE
+    );
+}
+
+sub mypaint_brushes_set_popup {
+    $blurb = 'Sets the current mypaint brush in a mypaint brush selection dialog.';
+    $help  = $blurb;
+
+    &andy_pdb_misc('2012');
+
+    @inargs = (
+	{ name => 'mypaint_brush_callback', type => 'string', non_empty => 1,
+	  desc => 'The name of the callback registered for this pop-up' },
+	{ name => 'mypaint_brush_name', type => 'string',
+	  desc => 'The name of the brush to set as selected' }
+    );
+
+    %invoke = (
+	code => <<'CODE'
+{
+  if (gimp->no_interface ||
+      ! gimp_pdb_lookup_procedure (gimp->pdb, mypaint_brush_callback) ||
+      ! gimp_pdb_dialog_set (gimp, gimp_data_factory_get_container (gimp->mypaint_brush_factory),
+                             mypaint_brush_callback, mypaint_brush_name,
+                             NULL))
+    success = FALSE;
+}
+CODE
+    );
+}
+
+
+@headers = qw("core/gimp.h"
+              "core/gimpdatafactory.h");
+
+@procs = qw(mypaint_brushes_popup
+            mypaint_brushes_close_popup
+            mypaint_brushes_set_popup);
+
+%exports = (app => [@procs], lib => [@procs]);
+
+$desc = 'Mypaint Brush UI';
+$doc_title = 'gimpmypaintbrushselect';
+$doc_short_desc = 'Functions providing a mypaint brush selection dialog.';
+$doc_long_desc = 'Functions providing a mypaint brush selection dialog.';
+
+1;
